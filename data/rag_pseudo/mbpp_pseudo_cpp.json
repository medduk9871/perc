[
    {
        "id": "11",
        "prompt": "Write a python function to remove first and last occurrence of a given character from the string.",
        "solution": "def remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s ",
        "code": [
            "def remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s "
        ],
        "pseudo": "# Find the index of the first occurrence of the given character in the string\n# Find the index of the last occurrence of the given character in the string\n\n# If both indices are valid\n    # Remove the first occurrence of the character from the string\n    # Decrement the index of the last occurrence by 1 to account for the removal\n    # Remove the last occurrence of the character from the string\n\n# Return the modified string",
        "test": [
            "assert remove_Occ(\"hello\",\"l\") == \"heo\"",
            "assert remove_Occ(\"abcda\",\"a\") == \"bcd\"",
            "assert remove_Occ(\"PHP\",\"P\") == \"H\""
        ],
        "draft_plan": [
            "# Find the index of the first occurrence of the given character in the string\n# Find the index of the last occurrence of the given character in the string\n\n# If both indices are valid\n    # Remove the first occurrence of the character from the string\n    # Decrement the index of the last occurrence by 1 to account for the removal\n    # Remove the last occurrence of the character from the string\n\n# Return the modified string"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::string remove_first_and_last_occurrence(std::string text, char c) {\n    int first_index = text.find(c);\n    int last_index = text.rfind(c);\n    \n    if (first_index != std::string::npos && last_index != std::string::npos && first_index != last_index) {\n        text.erase(first_index, 1);\n        last_index--;\n        text.erase(last_index, 1);\n    }\n    \n    return text;\n}"
        ]
    },
    {
        "id": "12",
        "prompt": "Write a function to sort a given matrix in ascending order according to the sum of its rows.",
        "solution": "def sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result",
        "code": [
            "def sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result"
        ],
        "pseudo": "# Calculate the sum of each row in the matrix\n\n# Create a list of tuples, where each tuple contains the index of the row and its corresponding sum\n\n# Sort the list of tuples based on the sum in ascending order\n\n# Create an empty sorted matrix\n\n# Iterate through the sorted list of tuples\n    # Append the corresponding row from the original matrix to the sorted matrix\n\n# Return the sorted matrix",
        "test": [
            "assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]",
            "assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]",
            "assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]"
        ],
        "draft_plan": [
            "# Calculate the sum of each row in the matrix\n\n# Create a list of tuples, where each tuple contains the index of the row and its corresponding sum\n\n# Sort the list of tuples based on the sum in ascending order\n\n# Create an empty sorted matrix\n\n# Iterate through the sorted list of tuples\n    # Append the corresponding row from the original matrix to the sorted matrix\n\n# Return the sorted matrix"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> sort_matrix_by_row_sum(std::vector<std::vector<int>> matrix) {\n    std::vector<std::pair<int, int>> row_sum;\n\n    for (int i = 0; i < matrix.size(); i++) {\n        int sum = 0;\n        for (int j = 0; j < matrix[i].size(); j++) {\n            sum += matrix[i][j];\n        }\n        row_sum.push_back(std::make_pair(i, sum));\n    }\n\n    std::sort(row_sum.begin(), row_sum.end(), [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n        return a.second < b.second;\n    });\n\n    std::vector<std::vector<int>> sorted_matrix;\n\n    for (const auto& row : row_sum) {\n        sorted_matrix.push_back(matrix[row.first]);\n    }\n\n    return sorted_matrix;\n}"
        ]
    },
    {
        "id": "14",
        "prompt": "Write a python function to find the volume of a triangular prism.",
        "solution": "def find_Volume(l,b,h) : \n    return ((l * b * h) / 2) ",
        "code": [
            "def find_Volume(l,b,h) : \n    return ((l * b * h) / 2) "
        ],
        "pseudo": "# Define a function to calculate the volume of a triangular prism\n    # Accept the base length, base width, and height of the prism as input parameters\n    # Calculate the area of the base triangle by multiplying the base length and base width, and dividing by 2\n    # Calculate the volume by multiplying the area of the base triangle by the height of the prism\n    # Return the calculated volume\n\n# Example usage:\n# volume = calculate_volume_of_triangular_prism(5, 6, 10)",
        "test": [
            "assert find_Volume(10,8,6) == 240",
            "assert find_Volume(3,2,2) == 6",
            "assert find_Volume(1,2,1) == 1"
        ],
        "draft_plan": [
            "# Define a function to calculate the volume of a triangular prism\n    # Accept the base length, base width, and height of the prism as input parameters\n    # Calculate the area of the base triangle by multiplying the base length and base width, and dividing by 2\n    # Calculate the volume by multiplying the area of the base triangle by the height of the prism\n    # Return the calculated volume\n\n# Example usage:\n# volume = calculate_volume_of_triangular_prism(5, 6, 10)"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n\ndouble calculate_volume_of_triangular_prism(double base_length, double base_width, double height) {\n    double base_area = (base_length * base_width) / 2;\n    double volume = base_area * height;\n    return volume;\n}\n\nint main() {\n    double base_length = 5;\n    double base_width = 6;\n    double height = 10;\n\n    double volume = calculate_volume_of_triangular_prism(base_length, base_width, height);\n    std::cout << \"Volume of triangular prism: \" << volume << std::endl;\n\n    return 0;\n}"
        ]
    },
    {
        "id": "16",
        "prompt": "Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.",
        "solution": "import re\ndef text_lowercase_underscore(text):\n        patterns = '^[a-z]+_[a-z]+$'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False",
        "code": [
            "import re\ndef text_lowercase_underscore(text):\n        patterns = '^[a-z]+_[a-z]+$'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False"
        ],
        "pseudo": "# Split the input string by the underscore character to get a list of substrings\n# Iterate through each substring in the list\n    # Check if the substring consists of lowercase letters only\n        # If not, return False\n\n# If all substrings are valid, return True",
        "test": [
            "assert text_lowercase_underscore(\"aab_cbbbc\")==(True)",
            "assert text_lowercase_underscore(\"aab_Abbbc\")==(False)",
            "assert text_lowercase_underscore(\"Aaab_abbbc\")==(False)"
        ],
        "draft_plan": [
            "# Split the input string by the underscore character to get a list of substrings\n# Iterate through each substring in the list\n    # Check if the substring consists of lowercase letters only\n        # If not, return False\n\n# If all substrings are valid, return True"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nbool check_lowercase_with_underscore(std::string input_string) {\n    std::vector<std::string> substrings;\n    std::istringstream iss(input_string);\n    std::string substring;\n\n    while (getline(iss, substring, '_')) {\n        substrings.push_back(substring);\n    }\n\n    for (const auto& sub : substrings) {\n        for (char c : sub) {\n            if (!islower(c)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}"
        ]
    },
    {
        "id": "17",
        "prompt": "Write a function that returns the perimeter of a square given its side length as input.",
        "solution": "def square_perimeter(a):\n  perimeter=4*a\n  return perimeter",
        "code": [
            "def square_perimeter(a):\n  perimeter=4*a\n  return perimeter"
        ],
        "pseudo": "# Define a function named \"square_perimeter\" that takes a parameter \"side_length\"\n    # Calculate the perimeter of the square by multiplying the side length by 4\n    # Return the perimeter\n\n# Call the function with a test value for the side length to verify the result",
        "test": [
            "assert square_perimeter(10)==40",
            "assert square_perimeter(5)==20",
            "assert square_perimeter(4)==16"
        ],
        "draft_plan": [
            "# Define a function named \"square_perimeter\" that takes a parameter \"side_length\"\n    # Calculate the perimeter of the square by multiplying the side length by 4\n    # Return the perimeter\n\n# Call the function with a test value for the side length to verify the result"
        ],
        "final_plan": [
            "```cpp\n#include <assert.h>\n\nint square_perimeter(int side_length) {\n    int perimeter = side_length * 4;\n    return perimeter;\n}\n\nint main() {\n    int side_length = 5;\n    int result = square_perimeter(side_length);\n    assert(result == 20);\n    return 0;\n}\n```"
        ]
    },
    {
        "id": "18",
        "prompt": "Write a function to remove characters from the first string which are present in the second string.",
        "solution": "NO_OF_CHARS = 256\ndef str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind]) ",
        "code": [
            "NO_OF_CHARS = 256\ndef str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind]) "
        ],
        "pseudo": "# Convert the second string into a set for efficient lookup\n\n# Initialize an empty string to store the result\n\n# Iterate through each character in the first string\n    # Check if the character is not present in the second string\n        # Append the character to the result string\n\n# Return the result string",
        "test": [
            "assert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'",
            "assert remove_dirty_chars(\"digitalindia\", \"talent\") == 'digiidi'",
            "assert remove_dirty_chars(\"exoticmiles\", \"toxic\") == 'emles'"
        ],
        "draft_plan": [
            "# Convert the second string into a set for efficient lookup\n\n# Initialize an empty string to store the result\n\n# Iterate through each character in the first string\n    # Check if the character is not present in the second string\n        # Append the character to the result string\n\n# Return the result string"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <string>\n#include <unordered_set>\n\nstd::string remove_common_chars(std::string str1, std::string str2) {\n    std::unordered_set<char> common_chars;\n    \n    for (char ch : str2) {\n        common_chars.insert(ch);\n    }\n    \n    std::string result;\n    \n    for (char ch : str1) {\n        if (common_chars.find(ch) == common_chars.end()) {\n            result += ch;\n        }\n    }\n    \n    return result;\n}"
        ]
    },
    {
        "id": "19",
        "prompt": "Write a function to find whether a given array of integers contains any duplicate element.",
        "solution": "def test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     ",
        "code": [
            "def test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)     "
        ],
        "pseudo": "# Initialize an empty set\n\n# Iterate through each element in the input array\n    # Check if the element is already present in the set\n        # If yes, return True as duplicate element found\n        # If not, add the element to the set\n\n# If no duplicate element is found, return False",
        "test": [
            "assert test_duplicate(([1,2,3,4,5]))==False",
            "assert test_duplicate(([1,2,3,4, 4]))==True",
            "assert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
        ],
        "draft_plan": [
            "# Initialize an empty set\n\n# Iterate through each element in the input array\n    # Check if the element is already present in the set\n        # If yes, return True as duplicate element found\n        # If not, add the element to the set\n\n# If no duplicate element is found, return False"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <unordered_set>\n#include <vector>\n\nbool contains_duplicate(std::vector<int>& nums) {\n    std::unordered_set<int> numSet;\n\n    for (int num : nums) {\n        if (numSet.find(num) != numSet.end()) {\n            return true;\n        }\n        numSet.insert(num);\n    }\n\n    return false;\n}"
        ]
    },
    {
        "id": "20",
        "prompt": "Write a function to check if the given number is woodball or not.",
        "solution": "def is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False",
        "code": [
            "def is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False"
        ],
        "pseudo": "# Check if the given number is less than or equal to 1\n    # If it is, return False as woodball numbers must be greater than 1\n\n# Initialize a variable to keep track of the previous number in the sequence\n# Start a loop from 2 to the square root of the given number\n    # Check if the given number is divisible by the current loop variable\n        # If it is, check if the current loop variable is equal to the previous number plus 1\n            # If it is, update the previous number to the current loop variable\n            # If it is not, return False as the sequence is broken\n\n# If the loop completes without returning False, return True as the given number is a woodball number",
        "test": [
            "assert is_woodall(383) == True",
            "assert is_woodall(254) == False",
            "assert is_woodall(200) == False"
        ],
        "draft_plan": [
            "# Check if the given number is less than or equal to 1\n    # If it is, return False as woodball numbers must be greater than 1\n\n# Initialize a variable to keep track of the previous number in the sequence\n# Start a loop from 2 to the square root of the given number\n    # Check if the given number is divisible by the current loop variable\n        # If it is, check if the current loop variable is equal to the previous number plus 1\n            # If it is, update the previous number to the current loop variable\n            # If it is not, return False as the sequence is broken\n\n# If the loop completes without returning False, return True as the given number is a woodball number"
        ],
        "final_plan": [
            "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_woodball(int num) {\n    if (num <= 1) {\n        return false;\n    }\n\n    int prev_num = 1;\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) {\n            if (i != prev_num + 1) {\n                return false;\n            }\n            prev_num = i;\n        }\n    }\n\n    return true;\n}"
        ]
    },
    {
        "id": "56",
        "prompt": "Write a python function to check if a given number is one less than twice its reverse.",
        "solution": "def rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \ndef check(n):    \n    return (2 * rev(n) == n + 1)  ",
        "code": [
            "def rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \ndef check(n):    \n    return (2 * rev(n) == n + 1)  "
        ],
        "pseudo": "# Convert the given number to a string and reverse it\n# Convert the reversed string back to an integer\n# Check if the given number is equal to twice the reversed number plus 1\n# If the condition is true, return True. Otherwise, return False.",
        "test": [
            "assert check(70) == False",
            "assert check(23) == False",
            "assert check(73) == True"
        ],
        "draft_plan": [
            "# Convert the given number to a string and reverse it\n# Convert the reversed string back to an integer\n# Check if the given number is equal to twice the reversed number plus 1\n# If the condition is true, return True. Otherwise, return False."
        ],
        "final_plan": [
            "#include <assert.h>\n#include <string>\n#include <algorithm>\n\nbool is_one_less_than_twice_reverse(int num) {\n    std::string num_str = std::to_string(num);\n    std::reverse(num_str.begin(), num_str.end());\n    int reversed_num = std::stoi(num_str);\n    \n    return num == 2 * reversed_num + 1;\n}"
        ]
    },
    {
        "id": "57",
        "prompt": "Write a python function to find the largest number that can be formed with the given list of digits.",
        "solution": "def find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num ",
        "code": [
            "def find_Max_Num(arr) : \n    n = len(arr)\n    arr.sort(reverse = True) \n    num = arr[0] \n    for i in range(1,n) : \n        num = num * 10 + arr[i] \n    return num "
        ],
        "pseudo": "# Sort the list of digits in descending order\n\n# Concatenate all the digits in the sorted list\n\n# Convert the concatenated string to an integer and return it",
        "test": [
            "assert find_Max_Num([1,2,3]) == 321",
            "assert find_Max_Num([4,5,6,1]) == 6541",
            "assert find_Max_Num([1,2,3,9]) == 9321"
        ],
        "draft_plan": [
            "# Sort the list of digits in descending order\n\n# Concatenate all the digits in the sorted list\n\n# Convert the concatenated string to an integer and return it"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n\nstd::string largest_number(std::vector<int> digits) {\n    std::sort(digits.begin(), digits.end(), [](int a, int b) {\n        return std::to_string(a) + std::to_string(b) > std::to_string(b) + std::to_string(a);\n    });\n\n    std::string result;\n    for (int digit : digits) {\n        result += std::to_string(digit);\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "58",
        "prompt": "Write a python function to check whether the given two integers have opposite sign or not.",
        "solution": "def opposite_Signs(x,y): \n    return ((x ^ y) < 0); ",
        "code": [
            "def opposite_Signs(x,y): \n    return ((x ^ y) < 0); "
        ],
        "pseudo": "# Check if the product of the two integers is negative\n    # If the product is negative, it means the two integers have opposite signs\n        # Return True\n\n# If the product is not negative, it means the two integers have the same sign\n    # Return False",
        "test": [
            "assert opposite_Signs(1,-2) == True",
            "assert opposite_Signs(3,2) == False",
            "assert opposite_Signs(-10,-10) == False",
            "assert opposite_Signs(-2,2) == True"
        ],
        "draft_plan": [
            "# Check if the product of the two integers is negative\n    # If the product is negative, it means the two integers have opposite signs\n        # Return True\n\n# If the product is not negative, it means the two integers have the same sign\n    # Return False"
        ],
        "final_plan": [
            "#include <assert.h>\n\nbool have_opposite_sign(int a, int b) {\n    return (a * b < 0);\n}"
        ]
    },
    {
        "id": "59",
        "prompt": "Write a function to find the nth octagonal number.",
        "solution": "def is_octagonal(n): \n\treturn 3 * n * n - 2 * n ",
        "code": [
            "def is_octagonal(n): \n\treturn 3 * n * n - 2 * n "
        ],
        "pseudo": "# Function to find the nth octagonal number\ndef find_octagonal_number(n):\n    # Calculate the nth octagonal number using the formula\n    octagonal_number = 3 * n * (n - 1) + 1\n    \n    # Return the result\n    return octagonal_number\n\n# Test the function\nn = 5\nresult = find_octagonal_number(n)\nprint(f\"The {n}th octagonal number is: {result}\")",
        "test": [
            "assert is_octagonal(5) == 65",
            "assert is_octagonal(10) == 280",
            "assert is_octagonal(15) == 645"
        ],
        "draft_plan": [
            "# Function to find the nth octagonal number\ndef find_octagonal_number(n):\n    # Calculate the nth octagonal number using the formula\n    octagonal_number = 3 * n * (n - 1) + 1\n    \n    # Return the result\n    return octagonal_number\n\n# Test the function\nn = 5\nresult = find_octagonal_number(n)\nprint(f\"The {n}th octagonal number is: {result}\")"
        ],
        "final_plan": [
            "```cpp\n#include <iostream>\n\n// Function to find the nth octagonal number\nlong find_octagonal_number(int n) {\n    // Calculate the nth octagonal number using the formula\n    long octagonal_number = 3 * n * (n - 1) + 1;\n    \n    // Return the result\n    return octagonal_number;\n}\n\nint main() {\n    int n = 5;\n    long result = find_octagonal_number(n);\n    std::cout << \"The \" << n << \"th octagonal number is: \" << result << std::endl;\n\n    return 0;\n}\n```"
        ]
    },
    {
        "id": "61",
        "prompt": "Write a python function to count the number of substrings with the sum of digits equal to their length.",
        "solution": "from collections import defaultdict\ndef count_Substrings(s):\n    n = len(s)\n    count,sum = 0,0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count",
        "code": [
            "from collections import defaultdict\ndef count_Substrings(s):\n    n = len(s)\n    count,sum = 0,0\n    mp = defaultdict(lambda : 0)\n    mp[0] += 1\n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    return count"
        ],
        "pseudo": "# Initialize a counter variable to keep track of the number of substrings\n\n# Iterate through each starting index of the substring\n    # Iterate through each ending index of the substring\n        # Get the substring from the starting index to the ending index\n        # Compute the sum of the digits in the substring\n        # Check if the sum of the digits is equal to the length of the substring\n            # If true, increment the counter variable\n\n# Return the counter variable with the total number of substrings",
        "test": [
            "assert count_Substrings('112112') == 6",
            "assert count_Substrings('111') == 6",
            "assert count_Substrings('1101112') == 12"
        ],
        "draft_plan": [
            "# Initialize a counter variable to keep track of the number of substrings\n\n# Iterate through each starting index of the substring\n    # Iterate through each ending index of the substring\n        # Get the substring from the starting index to the ending index\n        # Compute the sum of the digits in the substring\n        # Check if the sum of the digits is equal to the length of the substring\n            # If true, increment the counter variable\n\n# Return the counter variable with the total number of substrings"
        ],
        "final_plan": [
            "#include <iostream>\n#include <string>\n\nint count_substrings(std::string str) {\n    int count = 0;\n    for (int i = 0; i < str.length(); i++) {\n        for (int j = i; j < str.length(); j++) {\n            std::string substring = str.substr(i, j-i+1);\n            int sum = 0;\n            for (char ch : substring) {\n                sum += ch - '0';\n            }\n            if (sum == substring.length()) {\n                count++;\n            }\n        }\n    }\n    return count;\n}"
        ]
    },
    {
        "id": "62",
        "prompt": "Write a python function to find smallest number in a list.",
        "solution": "def smallest_num(xs):\n  return min(xs)\n",
        "code": [
            "def smallest_num(xs):\n  return min(xs)\n"
        ],
        "pseudo": "# Initialize the smallest number as the first element of the list\n\n# Iterate through each element in the list\n    # Check if the current element is smaller than the smallest number\n        # If yes, update the smallest number with the current element\n\n# Return the smallest number",
        "test": [
            "assert smallest_num([10, 20, 1, 45, 99]) == 1",
            "assert smallest_num([1, 2, 3]) == 1",
            "assert smallest_num([45, 46, 50, 60]) == 45"
        ],
        "draft_plan": [
            "# Initialize the smallest number as the first element of the list\n\n# Iterate through each element in the list\n    # Check if the current element is smaller than the smallest number\n        # If yes, update the smallest number with the current element\n\n# Return the smallest number"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\nint find_smallest_number(const std::vector<int>& num_list) {\n    if (num_list.empty()) {\n        throw std::invalid_argument(\"Input list is empty\");\n    }\n\n    int smallest = num_list[0];\n\n    for (int i = 1; i < num_list.size(); i++) {\n        if (num_list[i] < smallest) {\n            smallest = num_list[i];\n        }\n    }\n\n    return smallest;\n}"
        ]
    },
    {
        "id": "63",
        "prompt": "Write a function to find the maximum difference between available pairs in the given tuple list.",
        "solution": "def max_difference(test_list):\n  temp = [abs(b - a) for a, b in test_list]\n  res = max(temp)\n  return (res) ",
        "code": [
            "def max_difference(test_list):\n  temp = [abs(b - a) for a, b in test_list]\n  res = max(temp)\n  return (res) "
        ],
        "pseudo": "# Initialize the maximum difference variable to 0\n\n# Iterate through each pair in the list\n    # Calculate the difference between the second element and the first element of the current pair\n    # Check if the current difference is greater than the maximum difference\n        # If it is, update the maximum difference\n\n# Return the maximum difference",
        "test": [
            "assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7",
            "assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15",
            "assert max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23"
        ],
        "draft_plan": [
            "# Initialize the maximum difference variable to 0\n\n# Iterate through each pair in the list\n    # Calculate the difference between the second element and the first element of the current pair\n    # Check if the current difference is greater than the maximum difference\n        # If it is, update the maximum difference\n\n# Return the maximum difference"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nlong find_maximum_difference(std::vector<std::pair<long, long>> pair_list) {\n    long max_difference = 0;\n\n    for (const auto& pair : pair_list) {\n        long difference = pair.second - pair.first;\n        if (difference > max_difference) {\n            max_difference = difference;\n        }\n    }\n\n    return max_difference;\n}"
        ]
    },
    {
        "id": "64",
        "prompt": "Write a function to sort a list of tuples using the second value of each tuple.",
        "solution": "def subject_marks(subjectmarks):\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks",
        "code": [
            "def subject_marks(subjectmarks):\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\n subjectmarks.sort(key = lambda x: x[1])\n return subjectmarks"
        ],
        "pseudo": "# Define a function to sort a list of tuples by the second value\n    # Use the sorted() function and a lambda function as the key parameter\n    # The lambda function will extract the second value from each tuple for sorting\n    \n# Call the sorted() function with the list of tuples and the custom sorting function as arguments\n# Return the sorted list of tuples",
        "test": [
            "assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]",
            "assert subject_marks([('Telugu',49),('Hindhi',54),('Social',33)])==([('Social',33),('Telugu',49),('Hindhi',54)])",
            "assert subject_marks([('Physics',96),('Chemistry',97),('Biology',45)])==([('Biology',45),('Physics',96),('Chemistry',97)])"
        ],
        "draft_plan": [
            "# Define a function to sort a list of tuples by the second value\n    # Use the sorted() function and a lambda function as the key parameter\n    # The lambda function will extract the second value from each tuple for sorting\n    \n# Call the sorted() function with the list of tuples and the custom sorting function as arguments\n# Return the sorted list of tuples"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nbool sort_by_second(const std::tuple<int, int>& tuple1, const std::tuple<int, int>& tuple2) {\n    return std::get<1>(tuple1) < std::get<1>(tuple2);\n}\n\nstd::vector<std::tuple<int, int>> sort_tuples_by_second(std::vector<std::tuple<int, int>> tuples) {\n    std::sort(tuples.begin(), tuples.end(), sort_by_second);\n    return tuples;\n}"
        ]
    },
    {
        "id": "65",
        "prompt": "Write a function to flatten a list and sum all of its elements.",
        "solution": "def recursive_list_sum(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + recursive_list_sum(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total",
        "code": [
            "def recursive_list_sum(data_list):\n\ttotal = 0\n\tfor element in data_list:\n\t\tif type(element) == type([]):\n\t\t\ttotal = total + recursive_list_sum(element)\n\t\telse:\n\t\t\ttotal = total + element\n\treturn total"
        ],
        "pseudo": "# Initialize a variable to store the sum of all elements\n\n# Iterate through each element in the list\n    # Check if the current element is a list\n        # If it is a list, recursively call the flatten_and_sum function on the current element and add the result to the sum\n    # If it is not a list, add the current element to the sum\n\n# Return the sum",
        "test": [
            "assert recursive_list_sum(([1, 2, [3,4],[5,6]]))==21",
            "assert recursive_list_sum(([7, 10, [15,14],[19,41]]))==106",
            "assert recursive_list_sum(([10, 20, [30,40],[50,60]]))==210"
        ],
        "draft_plan": [
            "# Initialize a variable to store the sum of all elements\n\n# Iterate through each element in the list\n    # Check if the current element is a list\n        # If it is a list, recursively call the flatten_and_sum function on the current element and add the result to the sum\n    # If it is not a list, add the current element to the sum\n\n# Return the sum"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint flatten_and_sum(std::vector<int> lst) {\n    int sum = 0;\n\n    for (auto element : lst) {\n        if (std::vector<int>* sublst = dynamic_cast<std::vector<int>*>(&element)) {\n            sum += flatten_and_sum(*sublst);\n        } else {\n            sum += element;\n        }\n    }\n\n    return sum;\n}"
        ]
    },
    {
        "id": "66",
        "prompt": "Write a python function to count the number of positive numbers in a list.",
        "solution": "def pos_count(list):\n  pos_count= 0\n  for num in list: \n    if num >= 0: \n      pos_count += 1\n  return pos_count ",
        "code": [
            "def pos_count(list):\n  pos_count= 0\n  for num in list: \n    if num >= 0: \n      pos_count += 1\n  return pos_count "
        ],
        "pseudo": "# Initialize a variable count to 0\n\n# Iterate through each number in the list\n    # Check if the number is greater than 0\n        # If it is, increment the count\n\n# Return the count",
        "test": [
            "assert pos_count([1,-2,3,-4]) == 2",
            "assert pos_count([3,4,5,-1]) == 3",
            "assert pos_count([1,2,3,4]) == 4"
        ],
        "draft_plan": [
            "# Initialize a variable count to 0\n\n# Iterate through each number in the list\n    # Check if the number is greater than 0\n        # If it is, increment the count\n\n# Return the count"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\nint count_positive_numbers(std::vector<int> numbers) {\n    int count = 0;\n\n    for (int num : numbers) {\n        if (num > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}"
        ]
    },
    {
        "id": "67",
        "prompt": "Write a function to find the number of ways to partition a set of Bell numbers.",
        "solution": "def bell_number(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] ",
        "code": [
            "def bell_number(n):   \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] "
        ],
        "pseudo": "# Import the math module to use the factorial function\nimport math\n\n# Define a function to calculate the Bell numbers\ndef calculate_bell_number(n):\n    # Create a 2D array to store the Bell numbers\n    bell = [[0 for j in range(n+1)] for i in range(n+1)]\n\n    # Initialize the first Bell number as 1\n    bell[0][0] = 1\n\n    # Calculate the Bell numbers using dynamic programming\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n\n    # Return the last Bell number\n    return bell[n][0]\n\n# Define a function to calculate the number of ways to partition a set of Bell numbers\ndef calculate_partition_ways(n):\n    # Calculate the Bell number for n\n    bell_number = calculate_bell_number(n)\n\n    # Calculate the number of ways to partition the set\n    partition_ways = math.factorial(n) * bell_number\n\n    # Return the number of ways to partition the set\n    return partition_ways",
        "test": [
            "assert bell_number(2)==2",
            "assert bell_number(10)==115975",
            "assert bell_number(56)==6775685320645824322581483068371419745979053216268760300"
        ],
        "draft_plan": [
            "# Import the math module to use the factorial function\nimport math\n\n# Define a function to calculate the Bell numbers\ndef calculate_bell_number(n):\n    # Create a 2D array to store the Bell numbers\n    bell = [[0 for j in range(n+1)] for i in range(n+1)]\n\n    # Initialize the first Bell number as 1\n    bell[0][0] = 1\n\n    # Calculate the Bell numbers using dynamic programming\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n\n    # Return the last Bell number\n    return bell[n][0]\n\n# Define a function to calculate the number of ways to partition a set of Bell numbers\ndef calculate_partition_ways(n):\n    # Calculate the Bell number for n\n    bell_number = calculate_bell_number(n)\n\n    # Calculate the number of ways to partition the set\n    partition_ways = math.factorial(n) * bell_number\n\n    # Return the number of ways to partition the set\n    return partition_ways"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nlong long calculate_bell_number(int n) {\n    std::vector<std::vector<long long>> bell(n+1, std::vector<long long>(n+1, 0));\n\n    bell[0][0] = 1;\n\n    for (int i = 1; i <= n; i++) {\n        bell[i][0] = bell[i-1][i-1];\n        for (int j = 1; j <= i; j++) {\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1];\n        }\n    }\n\n    return bell[n][0];\n}\n\nlong long calculate_partition_ways(int n) {\n    long long bell_number = calculate_bell_number(n);\n    long long partition_ways = factorial(n) * bell_number;\n    return partition_ways;\n}\n\nint main() {\n    assert(calculate_partition_ways(3) == 12);\n    assert(calculate_partition_ways(4) == 288);\n    assert(calculate_partition_ways(5) == 8640);\n    return 0;\n}"
        ]
    },
    {
        "id": "68",
        "prompt": "Write a python function to check whether the given array is monotonic or not.",
        "solution": "def is_Monotonic(A): \n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) ",
        "code": [
            "def is_Monotonic(A): \n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) "
        ],
        "pseudo": "# Check if the length of the array is less than or equal to 2\n    # If true, return True as any array with 0 or 1 element is considered monotonic\n\n# Initialize two variables to track if the array is non-increasing and non-decreasing\n    # Set both variables to True initially\n\n# Iterate through each element in the array starting from index 1\n    # Check if the current element is greater than the previous element\n        # If true, set the non-increasing variable to False\n    # Check if the current element is less than the previous element\n        # If true, set the non-decreasing variable to False\n\n# Check if either the non-increasing or non-decreasing variable is True\n    # If true, return True as the array is monotonic\n    # Otherwise, return False as the array is not monotonic",
        "test": [
            "assert is_Monotonic([6, 5, 4, 4]) == True",
            "assert is_Monotonic([1, 2, 2, 3]) == True",
            "assert is_Monotonic([1, 3, 2]) == False"
        ],
        "draft_plan": [
            "# Check if the length of the array is less than or equal to 2\n    # If true, return True as any array with 0 or 1 element is considered monotonic\n\n# Initialize two variables to track if the array is non-increasing and non-decreasing\n    # Set both variables to True initially\n\n# Iterate through each element in the array starting from index 1\n    # Check if the current element is greater than the previous element\n        # If true, set the non-increasing variable to False\n    # Check if the current element is less than the previous element\n        # If true, set the non-decreasing variable to False\n\n# Check if either the non-increasing or non-decreasing variable is True\n    # If true, return True as the array is monotonic\n    # Otherwise, return False as the array is not monotonic"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <vector>\n\nbool isMonotonic(std::vector<int>& nums) {\n    int n = nums.size();\n    if (n <= 2) {\n        return true;\n    }\n\n    bool nonIncreasing = true;\n    bool nonDecreasing = true;\n\n    for (int i = 1; i < n; i++) {\n        if (nums[i] > nums[i-1]) {\n            nonIncreasing = false;\n        }\n        if (nums[i] < nums[i-1]) {\n            nonDecreasing = false;\n        }\n    }\n\n    return nonIncreasing || nonDecreasing;\n}"
        ]
    },
    {
        "id": "69",
        "prompt": "Write a function to check whether a list contains the given sublist or not.",
        "solution": "def is_sublist(l, s):\n\tsub_set = False\n\tif s == []:\n\t\tsub_set = True\n\telif s == l:\n\t\tsub_set = True\n\telif len(s) > len(l):\n\t\tsub_set = False\n\telse:\n\t\tfor i in range(len(l)):\n\t\t\tif l[i] == s[0]:\n\t\t\t\tn = 1\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\n\t\t\t\t\tn += 1\t\t\t\t\n\t\t\t\tif n == len(s):\n\t\t\t\t\tsub_set = True\n\treturn sub_set",
        "code": [
            "def is_sublist(l, s):\n\tsub_set = False\n\tif s == []:\n\t\tsub_set = True\n\telif s == l:\n\t\tsub_set = True\n\telif len(s) > len(l):\n\t\tsub_set = False\n\telse:\n\t\tfor i in range(len(l)):\n\t\t\tif l[i] == s[0]:\n\t\t\t\tn = 1\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\n\t\t\t\t\tn += 1\t\t\t\t\n\t\t\t\tif n == len(s):\n\t\t\t\t\tsub_set = True\n\treturn sub_set"
        ],
        "pseudo": "# Iterate through each index in the main list\n    # Check if the current index and the sublist length is less than or equal to the main list length\n        # Check if the sublist matches the elements starting from the current index in the main list\n\n# If the sublist is found, return True\n# Otherwise, return False",
        "test": [
            "assert is_sublist([2,4,3,5,7],[3,7])==False",
            "assert is_sublist([2,4,3,5,7],[4,3])==True",
            "assert is_sublist([2,4,3,5,7],[1,6])==False"
        ],
        "draft_plan": [
            "# Iterate through each index in the main list\n    # Check if the current index and the sublist length is less than or equal to the main list length\n        # Check if the sublist matches the elements starting from the current index in the main list\n\n# If the sublist is found, return True\n# Otherwise, return False"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nbool contains_sublist(const std::vector<int>& main_list, const std::vector<int>& sublist) {\n    for (int i = 0; i <= main_list.size() - sublist.size(); i++) {\n        if (std::equal(main_list.begin() + i, main_list.begin() + i + sublist.size(), sublist.begin())) {\n            return true;\n        }\n    }\n    return false;\n}"
        ]
    },
    {
        "id": "70",
        "prompt": "Write a function to find whether all the given tuples have equal length or not.",
        "solution": "def find_equal_tuple(Input):\n  k = 0 if not Input else len(Input[0])\n  flag = 1\n  for tuple in Input:\n    if len(tuple) != k:\n      flag = 0\n      break\n  return flag\ndef get_equal(Input):\n  return find_equal_tuple(Input) == 1",
        "code": [
            "def find_equal_tuple(Input):\n  k = 0 if not Input else len(Input[0])\n  flag = 1\n  for tuple in Input:\n    if len(tuple) != k:\n      flag = 0\n      break\n  return flag\ndef get_equal(Input):\n  return find_equal_tuple(Input) == 1"
        ],
        "pseudo": "# Get the length of the first tuple in the list\n\n# Iterate through each tuple in the list\n    # Check if the length of the current tuple is not equal to the length of the first tuple\n        # If lengths are not equal, return False\n\n# If all tuples have equal lengths, return True",
        "test": [
            "assert get_equal([(11, 22, 33), (44, 55, 66)]) == True",
            "assert get_equal([(1, 2, 3), (4, 5, 6, 7)]) == False",
            "assert get_equal([(1, 2), (3, 4)]) == True"
        ],
        "draft_plan": [
            "# Get the length of the first tuple in the list\n\n# Iterate through each tuple in the list\n    # Check if the length of the current tuple is not equal to the length of the first tuple\n        # If lengths are not equal, return False\n\n# If all tuples have equal lengths, return True"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nbool check_tuple_lengths(std::vector<std::tuple<int, int>>& tuples) {\n    int first_length = std::tuple_size<std::tuple<int, int>>::value;\n\n    for (const auto& tup : tuples) {\n        if (std::tuple_size<decltype(tup)>::value != first_length) {\n            return false;\n        }\n    }\n\n    return true;\n}"
        ]
    },
    {
        "id": "71",
        "prompt": "Write a function to sort a list of elements.",
        "solution": "def comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i+gaps]:\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums",
        "code": [
            "def comb_sort(nums):\n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i+gaps]:\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums"
        ],
        "pseudo": "# Use the built-in sorted() function to sort the list in ascending order\n# Return the sorted list",
        "test": [
            "assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]",
            "assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]",
            "assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]"
        ],
        "draft_plan": [
            "# Use the built-in sorted() function to sort the list in ascending order\n# Return the sorted list"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\ntemplate <typename T>\nstd::vector<T> sort_list(std::vector<T> elements) {\n    std::sort(elements.begin(), elements.end());\n    return elements;\n}"
        ]
    },
    {
        "id": "72",
        "prompt": "Write a python function to check whether the given number can be represented as the difference of two squares or not.",
        "solution": "def dif_Square(n): \n    if (n % 4 != 2): \n        return True\n    return False",
        "code": [
            "def dif_Square(n): \n    if (n % 4 != 2): \n        return True\n    return False"
        ],
        "pseudo": "# Iterate through all numbers from 1 to sqrt(n)\n    # Calculate the square of the current number\n    # Check if the difference between n and the square is a perfect square\n\n# If a perfect square difference is found, return True\n# If no perfect square difference is found, return False",
        "test": [
            "assert dif_Square(5) == True",
            "assert dif_Square(10) == False",
            "assert dif_Square(15) == True"
        ],
        "draft_plan": [
            "# Iterate through all numbers from 1 to sqrt(n)\n    # Calculate the square of the current number\n    # Check if the difference between n and the square is a perfect square\n\n# If a perfect square difference is found, return True\n# If no perfect square difference is found, return False"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <cmath>\n\nbool check_difference_of_squares(int n) {\n    for (int i = 1; i <= sqrt(n); i++) {\n        int square = i * i;\n        int difference = n - square;\n\n        if (sqrt(difference) == int(sqrt(difference))) {\n            return true;\n        }\n    }\n\n    return false;\n}"
        ]
    },
    {
        "id": "74",
        "prompt": "Write a function to check whether it follows the sequence given in the patterns array.",
        "solution": "def is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    sdict = {}\n    pset = set()\n    sset = set()    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict.keys():\n            sdict[patterns[i]] = []\n\n        keys = sdict[patterns[i]]\n        keys.append(colors[i])\n        sdict[patterns[i]] = keys\n\n    if len(pset) != len(sset):\n        return False   \n\n    for values in sdict.values():\n\n        for i in range(len(values) - 1):\n            if values[i] != values[i+1]:\n                return False\n\n    return True",
        "code": [
            "def is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    sdict = {}\n    pset = set()\n    sset = set()    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict.keys():\n            sdict[patterns[i]] = []\n\n        keys = sdict[patterns[i]]\n        keys.append(colors[i])\n        sdict[patterns[i]] = keys\n\n    if len(pset) != len(sset):\n        return False   \n\n    for values in sdict.values():\n\n        for i in range(len(values) - 1):\n            if values[i] != values[i+1]:\n                return False\n\n    return True"
        ],
        "pseudo": "# Initialize a pointer to keep track of the current position in the patterns array\n\n# Iterate through each character in the input string\n    # Check if the current character matches the character at the pointer position in the patterns array\n        # If it matches, move the pointer to the next position in the patterns array\n        # If the pointer reaches the end of the patterns array, return True as the sequence is followed\n\n# If the loop completes without returning True, return False as the sequence is not followed",
        "test": [
            "assert is_samepatterns([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True",
            "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\",\"b\"])==False",
            "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\"])==False"
        ],
        "draft_plan": [
            "# Initialize a pointer to keep track of the current position in the patterns array\n\n# Iterate through each character in the input string\n    # Check if the current character matches the character at the pointer position in the patterns array\n        # If it matches, move the pointer to the next position in the patterns array\n        # If the pointer reaches the end of the patterns array, return True as the sequence is followed\n\n# If the loop completes without returning True, return False as the sequence is not followed"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <string>\n#include <vector>\n\nbool follows_sequence(const std::string& input, const std::vector<char>& patterns) {\n    int ptr = 0; // pointer to keep track of current position in patterns array\n\n    for (char c : input) {\n        if (c == patterns[ptr]) {\n            ptr++;\n            if (ptr == patterns.size()) {\n                return true; // sequence followed\n            }\n        }\n    }\n\n    return false; // sequence not followed\n}"
        ]
    },
    {
        "id": "75",
        "prompt": "Write a function to find tuples which have all elements divisible by k from the given list of tuples.",
        "solution": "def find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res",
        "code": [
            "def find_tuples(test_list, K):\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\n  return res"
        ],
        "pseudo": "# Initialize an empty list to store the resulting tuples\n\n# Iterate through each tuple in the given list of tuples\n    # Initialize a flag variable to True\n    \n    # Iterate through each element in the tuple\n        # Check if the element is not divisible by k\n            # If not divisible, set the flag variable to False and break out of the loop\n    \n    # If the flag variable is still True after checking all elements, add the tuple to the resulting list\n\n# Return the resulting list of tuples",
        "test": [
            "assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]",
            "assert find_tuples([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == [(5, 25, 30)]",
            "assert find_tuples([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == [(8, 16, 4)]"
        ],
        "draft_plan": [
            "# Initialize an empty list to store the resulting tuples\n\n# Iterate through each tuple in the given list of tuples\n    # Initialize a flag variable to True\n    \n    # Iterate through each element in the tuple\n        # Check if the element is not divisible by k\n            # If not divisible, set the flag variable to False and break out of the loop\n    \n    # If the flag variable is still True after checking all elements, add the tuple to the resulting list\n\n# Return the resulting list of tuples"
        ],
        "final_plan": [
            "#include <vector>\n#include <tuple>\n\nstd::vector<std::tuple<int, int, int>> find_divisible_tuples(std::vector<std::tuple<int, int, int>> tuples, int k) {\n    std::vector<std::tuple<int, int, int>> result;\n\n    for (const auto& tup : tuples) {\n        bool flag = true;\n\n        for (int i = 0; i < std::tuple_size<decltype(tup)>::value; i++) {\n            if (std::get<i>(tup) % k != 0) {\n                flag = false;\n                break;\n            }\n        }\n\n        if (flag) {\n            result.push_back(tup);\n        }\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "77",
        "prompt": "Write a python function to find whether a number is divisible by 11.",
        "solution": "def is_Diff(n): \n    return (n % 11 == 0) ",
        "code": [
            "def is_Diff(n): \n    return (n % 11 == 0) "
        ],
        "pseudo": "To determine whether a number is divisible by 11, we can use the following logic:\n\n1. Convert the number to a string.\n2. Iterate through the digits of the number.\n3. Add the digits in odd positions (starting from the rightmost digit) and subtract the sum of the digits in even positions.\n4. If the result is divisible by 11, the original number is also divisible by 11.\n\nHere is the code implementing this logic:\n\n```python\ndef is_divisible_by_11(number):\n    # Convert the number to a string\n    number_str = str(number)\n    \n    # Iterate through the digits of the number\n    sum_odd = 0\n    sum_even = 0\n    for i in range(len(number_str)):\n        digit = int(number_str[i])\n        \n        # Add the digits in odd positions and subtract the digits in even positions\n        if i % 2 == 0:\n            sum_odd += digit\n        else:\n            sum_even += digit\n    \n    # Check if the result is divisible by 11\n    if (sum_odd - sum_even) % 11 == 0:\n        return True\n    else:\n        return False\n```\n\nYou can use this function to check if a number is divisible by 11. For example:\n\n```python\nprint(is_divisible_by_11(121))  # Output: True\nprint(is_divisible_by_11(123))  # Output: False\n```",
        "test": [
            "assert is_Diff (12345) == False",
            "assert is_Diff(1212112) == True",
            "assert is_Diff(1212) == False"
        ],
        "draft_plan": [
            "To determine whether a number is divisible by 11, we can use the following logic:\n\n1. Convert the number to a string.\n2. Iterate through the digits of the number.\n3. Add the digits in odd positions (starting from the rightmost digit) and subtract the sum of the digits in even positions.\n4. If the result is divisible by 11, the original number is also divisible by 11.\n\nHere is the code implementing this logic:\n\n```python\ndef is_divisible_by_11(number):\n    # Convert the number to a string\n    number_str = str(number)\n    \n    # Iterate through the digits of the number\n    sum_odd = 0\n    sum_even = 0\n    for i in range(len(number_str)):\n        digit = int(number_str[i])\n        \n        # Add the digits in odd positions and subtract the digits in even positions\n        if i % 2 == 0:\n            sum_odd += digit\n        else:\n            sum_even += digit\n    \n    # Check if the result is divisible by 11\n    if (sum_odd - sum_even) % 11 == 0:\n        return True\n    else:\n        return False\n```\n\nYou can use this function to check if a number is divisible by 11. For example:\n\n```python\nprint(is_divisible_by_11(121))  # Output: True\nprint(is_divisible_by_11(123))  # Output: False\n```"
        ],
        "final_plan": [
            "Here is the C++ code that implements the logic described in the plan:\n\n```cpp\n#include <iostream>\n#include <string>\n\nbool is_divisible_by_11(int number) {\n    // Convert the number to a string\n    std::string number_str = std::to_string(number);\n    \n    // Iterate through the digits of the number\n    int sum_odd = 0;\n    int sum_even = 0;\n    for (int i = 0; i < number_str.length(); i++) {\n        int digit = number_str[i] - '0';\n        \n        // Add the digits in odd positions and subtract the digits in even positions\n        if (i % 2 == 0) {\n            sum_odd += digit;\n        } else {\n            sum_even += digit;\n        }\n    }\n    \n    // Check if the result is divisible by 11\n    if ((sum_odd - sum_even) % 11 == 0) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    \n    std::cout << is_divisible_by_11(121) << std::endl;  // Output: true\n    std::cout << is_divisible_by_11(123) << std::endl;  // Output: false\n    \n    return 0;\n}\n```\n\nYou can run this code to check if a number is divisible by 11. The function `is_divisible_by_11` takes an integer as input and returns `true` if the number is divisible by 11, and `false` otherwise."
        ]
    },
    {
        "id": "79",
        "prompt": "Write a python function to check whether the length of the word is odd or not.",
        "solution": "def word_len(s): \n    s = s.split(' ')   \n    for word in s:    \n        if len(word)%2!=0: \n            return True  \n        else:\n          return False",
        "code": [
            "def word_len(s): \n    s = s.split(' ')   \n    for word in s:    \n        if len(word)%2!=0: \n            return True  \n        else:\n          return False"
        ],
        "pseudo": "# Get the length of the word\n# Check if the length of the word is odd or even\n    # If the length is odd, return True\n    # If the length is even, return False",
        "test": [
            "assert word_len(\"Hadoop\") == False",
            "assert word_len(\"great\") == True",
            "assert word_len(\"structure\") == True"
        ],
        "draft_plan": [
            "# Get the length of the word\n# Check if the length of the word is odd or even\n    # If the length is odd, return True\n    # If the length is even, return False"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n\nbool is_length_odd(std::string word) {\n    int length = word.length();\n    if (length % 2 == 1) {\n        return true;\n    }\n    return false;\n}"
        ]
    },
    {
        "id": "80",
        "prompt": "Write a function to find the nth tetrahedral number.",
        "solution": "def tetrahedral_number(n): \n\treturn (n * (n + 1) * (n + 2)) / 6",
        "code": [
            "def tetrahedral_number(n): \n\treturn (n * (n + 1) * (n + 2)) / 6"
        ],
        "pseudo": "# Initialize the tetrahedral number to 0\n\n# Iterate from 1 to n (inclusive)\n    # Add the current number to the tetrahedral number\n\n# Return the tetrahedral number",
        "test": [
            "assert tetrahedral_number(5) == 35",
            "assert tetrahedral_number(6) == 56",
            "assert tetrahedral_number(7) == 84"
        ],
        "draft_plan": [
            "# Initialize the tetrahedral number to 0\n\n# Iterate from 1 to n (inclusive)\n    # Add the current number to the tetrahedral number\n\n# Return the tetrahedral number"
        ],
        "final_plan": [
            "#include <assert.h>\n\nint find_nth_tetrahedral(int n) {\n    int tetrahedral_number = 0;\n\n    for (int i = 1; i <= n; i++) {\n        tetrahedral_number += (i * (i + 1) * (i + 2)) / 6;\n    }\n\n    return tetrahedral_number;\n}"
        ]
    },
    {
        "id": "82",
        "prompt": "Write a function to find the volume of a sphere.",
        "solution": "import math\ndef volume_sphere(r):\n  volume=(4/3)*math.pi*r*r*r\n  return volume",
        "code": [
            "import math\ndef volume_sphere(r):\n  volume=(4/3)*math.pi*r*r*r\n  return volume"
        ],
        "pseudo": "# Define a function called calculate_sphere_volume that takes a single parameter, radius\n\n# Calculate the volume of the sphere using the formula: (4/3) * pi * radius^3\n# Store the result in a variable called volume\n\n# Return the calculated volume",
        "test": [
            "assert math.isclose(volume_sphere(10), 4188.790204786391, rel_tol=0.001)",
            "assert math.isclose(volume_sphere(25), 65449.84694978735, rel_tol=0.001)",
            "assert math.isclose(volume_sphere(20), 33510.32163829113, rel_tol=0.001)"
        ],
        "draft_plan": [
            "# Define a function called calculate_sphere_volume that takes a single parameter, radius\n\n# Calculate the volume of the sphere using the formula: (4/3) * pi * radius^3\n# Store the result in a variable called volume\n\n# Return the calculated volume"
        ],
        "final_plan": [
            "#include <cassert>\n#include <cmath>\n\ndouble calculate_sphere_volume(double radius) {\n    double volume = (4.0 / 3.0) * M_PI * pow(radius, 3);\n    return volume;\n}"
        ]
    },
    {
        "id": "83",
        "prompt": "Write a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.",
        "solution": "def get_Char(strr):  \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    if (summ % 26 == 0): \n        return ord('z') \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)",
        "code": [
            "def get_Char(strr):  \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    if (summ % 26 == 0): \n        return ord('z') \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)"
        ],
        "pseudo": "# Define a function to calculate the character made by adding the ASCII values modulo 26\n    # Initialize a variable to store the sum of ASCII values\n    # Iterate through each character in the given string\n        # Add the ASCII value of the current character to the sum\n    # Calculate the modulo 26 of the sum\n    # Convert the result back to a character using the ASCII value\n    # Return the resulting character",
        "test": [
            "assert get_Char(\"abc\") == \"f\"",
            "assert get_Char(\"gfg\") == \"t\"",
            "assert get_Char(\"ab\") == \"c\""
        ],
        "draft_plan": [
            "# Define a function to calculate the character made by adding the ASCII values modulo 26\n    # Initialize a variable to store the sum of ASCII values\n    # Iterate through each character in the given string\n        # Add the ASCII value of the current character to the sum\n    # Calculate the modulo 26 of the sum\n    # Convert the result back to a character using the ASCII value\n    # Return the resulting character"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <string>\n\nchar calculate_ascii_sum_modulo_26(std::string str) {\n    int sum = 0;\n    for (char c : str) {\n        sum += static_cast<int>(c);\n    }\n    int result = sum % 26;\n    char ch = static_cast<char>(result + 65);\n    return ch;\n}"
        ]
    },
    {
        "id": "84",
        "prompt": "Write a function to find the nth number in the newman conway sequence.",
        "solution": "def sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\telse: \n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))",
        "code": [
            "def sequence(n): \n\tif n == 1 or n == 2: \n\t\treturn 1\n\telse: \n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))"
        ],
        "pseudo": "# Create a list to store the Newman-Conway sequence\n# Initialize the first two elements of the sequence\n# Iterate from index 3 up to the given number n\n    # Calculate the next element of the sequence using the previous elements\n# Return the nth element of the sequence",
        "test": [
            "assert sequence(10) == 6",
            "assert sequence(2) == 1",
            "assert sequence(3) == 2"
        ],
        "draft_plan": [
            "# Create a list to store the Newman-Conway sequence\n# Initialize the first two elements of the sequence\n# Iterate from index 3 up to the given number n\n    # Calculate the next element of the sequence using the previous elements\n# Return the nth element of the sequence"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <vector>\n\nint newman_conway(int n) {\n    assert(n > 0);\n\n    std::vector<int> sequence(n + 1);\n\n    // Base cases\n    sequence[1] = 1;\n    sequence[2] = 1;\n\n    for (int i = 3; i <= n; i++) {\n        sequence[i] = sequence[sequence[i - 1]] + sequence[i - sequence[i - 1]];\n    }\n\n    return sequence[n];\n}"
        ]
    },
    {
        "id": "85",
        "prompt": "Write a function to find the surface area of a sphere.",
        "solution": "import math\ndef surfacearea_sphere(r):\n  surfacearea=4*math.pi*r*r\n  return surfacearea",
        "code": [
            "import math\ndef surfacearea_sphere(r):\n  surfacearea=4*math.pi*r*r\n  return surfacearea"
        ],
        "pseudo": "import math\n\ndef surface_area_of_sphere(radius):\n    # Calculate the surface area of a sphere using the formula: 4\u03c0r^2\n    surface_area = 4 * math.pi * radius**2\n    \n    return surface_area",
        "test": [
            "assert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)",
            "assert math.isclose(surfacearea_sphere(15), 2827.4333882308138, rel_tol=0.001)",
            "assert math.isclose(surfacearea_sphere(20), 5026.548245743669, rel_tol=0.001)"
        ],
        "draft_plan": [
            "import math\n\ndef surface_area_of_sphere(radius):\n    # Calculate the surface area of a sphere using the formula: 4\u03c0r^2\n    surface_area = 4 * math.pi * radius**2\n    \n    return surface_area"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <cmath>\n\ndouble surface_area_of_sphere(double radius) {\n    // Calculate the surface area of a sphere using the formula: 4\u03c0r^2\n    double surface_area = 4 * M_PI * pow(radius, 2);\n    \n    return surface_area;\n}"
        ]
    },
    {
        "id": "86",
        "prompt": "Write a function to find nth centered hexagonal number.",
        "solution": "def centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1",
        "code": [
            "def centered_hexagonal_number(n):\n  return 3 * n * (n - 1) + 1"
        ],
        "pseudo": "# Initialize the centered hexagonal number formula: nth_centered_hexagonal = 3 * n * (n - 1) + 1\n\n# Define a function to calculate the nth centered hexagonal number\n    # Check if n is a positive integer, otherwise return None\n    # Calculate the nth centered hexagonal number using the formula\n    # Return the result\n\n# Call the function and provide the desired value of n to get the nth centered hexagonal number",
        "test": [
            "assert centered_hexagonal_number(10) == 271",
            "assert centered_hexagonal_number(2) == 7",
            "assert centered_hexagonal_number(9) == 217"
        ],
        "draft_plan": [
            "# Initialize the centered hexagonal number formula: nth_centered_hexagonal = 3 * n * (n - 1) + 1\n\n# Define a function to calculate the nth centered hexagonal number\n    # Check if n is a positive integer, otherwise return None\n    # Calculate the nth centered hexagonal number using the formula\n    # Return the result\n\n# Call the function and provide the desired value of n to get the nth centered hexagonal number"
        ],
        "final_plan": [
            "#include <cassert>\n\nlong long nth_centered_hexagonal(int n) {\n    if (n <= 0) {\n        return -1;\n    }\n\n    long long centered_hexagonal = 3 * n * (n - 1) + 1;\n    return centered_hexagonal;\n}"
        ]
    },
    {
        "id": "87",
        "prompt": "Write a function to merge three dictionaries into a single dictionary.",
        "solution": "import collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict",
        "code": [
            "import collections as ct\ndef merge_dictionaries_three(dict1,dict2, dict3):\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\n    return merged_dict"
        ],
        "pseudo": "# Initialize an empty dictionary to store the merged dictionaries\n\n# Iterate through each dictionary in the input list\n    # Iterate through each key-value pair in the current dictionary\n        # Add the key-value pair to the merged dictionary\n\n# Return the merged dictionary",
        "test": [
            "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}",
            "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{\"L\":\"lavender\",\"B\":\"Blue\"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'}",
            "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" },{\"L\":\"lavender\",\"B\":\"Blue\"},{ \"G\": \"Green\", \"W\": \"White\" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'}"
        ],
        "draft_plan": [
            "# Initialize an empty dictionary to store the merged dictionaries\n\n# Iterate through each dictionary in the input list\n    # Iterate through each key-value pair in the current dictionary\n        # Add the key-value pair to the merged dictionary\n\n# Return the merged dictionary"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::map<std::string, int> merge_dictionaries(std::vector<std::map<std::string, int>> dictionaries) {\n    std::map<std::string, int> merged_dictionary;\n\n    for (const auto& dictionary : dictionaries) {\n        for (const auto& pair : dictionary) {\n            merged_dictionary[pair.first] = pair.second;\n        }\n    }\n\n    return merged_dictionary;\n}"
        ]
    },
    {
        "id": "88",
        "prompt": "Write a function to get the frequency of all the elements in a list, returned as a dictionary.",
        "solution": "import collections\ndef freq_count(list1):\n  freq_count= collections.Counter(list1)\n  return freq_count",
        "code": [
            "import collections\ndef freq_count(list1):\n  freq_count= collections.Counter(list1)\n  return freq_count"
        ],
        "pseudo": "# Initialize an empty dictionary\n\n# Iterate through each element in the list\n    # Check if the element is already a key in the dictionary\n        # If it is, increment its value by 1\n        # If it is not, add it as a new key with value 1\n\n# Return the dictionary containing the frequency of elements",
        "test": [
            "assert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1})",
            "assert freq_count([1,2,3,4,3,2,4,1,3,1,4])==({1:3, 2:2,3:3,4:3})",
            "assert freq_count([5,6,7,4,9,10,4,5,6,7,9,5])==({10:1,5:3,6:2,7:2,4:2,9:2})"
        ],
        "draft_plan": [
            "# Initialize an empty dictionary\n\n# Iterate through each element in the list\n    # Check if the element is already a key in the dictionary\n        # If it is, increment its value by 1\n        # If it is not, add it as a new key with value 1\n\n# Return the dictionary containing the frequency of elements"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::map<int, int> get_frequency(std::vector<int> lst) {\n    std::map<int, int> freq;\n\n    for (const auto& num : lst) {\n        freq[num]++;\n    }\n\n    return freq;\n}"
        ]
    },
    {
        "id": "89",
        "prompt": "Write a function to find the closest smaller number than n.",
        "solution": "def closest_num(N):\n  return (N - 1)",
        "code": [
            "def closest_num(N):\n  return (N - 1)"
        ],
        "pseudo": "# Initialize a variable to store the closest smaller number\n# Iterate from n-1 to 1 in descending order\n    # Check if the current number is smaller than n\n        # If yes, update the closest smaller number and break the loop\n\n# Return the closest smaller number",
        "test": [
            "assert closest_num(11) == 10",
            "assert closest_num(7) == 6",
            "assert closest_num(12) == 11"
        ],
        "draft_plan": [
            "# Initialize a variable to store the closest smaller number\n# Iterate from n-1 to 1 in descending order\n    # Check if the current number is smaller than n\n        # If yes, update the closest smaller number and break the loop\n\n# Return the closest smaller number"
        ],
        "final_plan": [
            "#include <assert.h>\n\nint closest_smaller_number(int n) {\n    int closest_smaller = -1;\n\n    for (int i = n - 1; i >= 1; i--) {\n        if (i < n) {\n            closest_smaller = i;\n            break;\n        }\n    }\n\n    return closest_smaller;\n}"
        ]
    },
    {
        "id": "90",
        "prompt": "Write a python function to find the length of the longest word.",
        "solution": "def len_log(list1):\n    max=len(list1[0])\n    for i in list1:\n        if len(i)>max:\n            max=len(i)\n    return max",
        "code": [
            "def len_log(list1):\n    max=len(list1[0])\n    for i in list1:\n        if len(i)>max:\n            max=len(i)\n    return max"
        ],
        "pseudo": "# Split the input sentence into words using the split() function\n# Initialize a variable maxLength to 0\n\n# Iterate through each word in the list of words\n    # Check if the length of the current word is greater than maxLength\n        # If it is, update maxLength with the length of the current word\n\n# Return maxLength",
        "test": [
            "assert len_log([\"python\",\"PHP\",\"bigdata\"]) == 7",
            "assert len_log([\"a\",\"ab\",\"abc\"]) == 3",
            "assert len_log([\"small\",\"big\",\"tall\"]) == 5"
        ],
        "draft_plan": [
            "# Split the input sentence into words using the split() function\n# Initialize a variable maxLength to 0\n\n# Iterate through each word in the list of words\n    # Check if the length of the current word is greater than maxLength\n        # If it is, update maxLength with the length of the current word\n\n# Return maxLength"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint longest_word_length(std::string sentence) {\n    std::vector<std::string> words;\n    std::istringstream iss(sentence);\n    std::string word;\n\n    while (iss >> word) {\n        words.push_back(word);\n    }\n\n    int maxLength = 0;\n\n    for (const auto& word : words) {\n        if (word.length() > maxLength) {\n            maxLength = word.length();\n        }\n    }\n\n    return maxLength;\n}"
        ]
    },
    {
        "id": "91",
        "prompt": "Write a function to check if a string is present as a substring in a given list of string values.",
        "solution": "def find_substring(str1, sub_str):\n   if any(sub_str in s for s in str1):\n       return True\n   return False",
        "code": [
            "def find_substring(str1, sub_str):\n   if any(sub_str in s for s in str1):\n       return True\n   return False"
        ],
        "pseudo": "# Iterate through each string in the list\n    # Check if the given substring is present in the current string\n        # If found, return True\n\n# If the substring is not found in any string, return False",
        "test": [
            "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ack\")==True",
            "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"abc\")==False",
            "assert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ange\")==True"
        ],
        "draft_plan": [
            "# Iterate through each string in the list\n    # Check if the given substring is present in the current string\n        # If found, return True\n\n# If the substring is not found in any string, return False"
        ],
        "final_plan": [
            "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool is_substring_present(std::string substring, std::vector<std::string> string_list) {\n    for (const auto& str : string_list) {\n        if (str.find(substring) != std::string::npos) {\n            return true;\n        }\n    }\n\n    return false;\n}"
        ]
    },
    {
        "id": "92",
        "prompt": "Write a function to check whether the given number is undulating or not.",
        "solution": "def is_undulating(n): \n\tn = str(n)\n\tif (len(n) <= 2): \n\t\treturn False\n\tfor i in range(2, len(n)): \n\t\tif (n[i - 2] != n[i]): \n\t\t\treturn False\n\treturn True",
        "code": [
            "def is_undulating(n): \n\tn = str(n)\n\tif (len(n) <= 2): \n\t\treturn False\n\tfor i in range(2, len(n)): \n\t\tif (n[i - 2] != n[i]): \n\t\t\treturn False\n\treturn True"
        ],
        "pseudo": "To check whether a given number is undulating or not, we can follow these steps:\n\n1. Convert the given number into a string.\n2. Check if the length of the string is less than or equal to 2. If it is, return False since a number with length less than or equal to 2 cannot be undulating.\n3. Iterate through each digit in the string starting from the second digit.\n    - Check if the current digit is equal to the previous digit. If it is, return False since an undulating number cannot have consecutive same digits.\n    - Check if the current digit is greater than the previous digit. If it is, check if the previous digit is greater than the digit before it. If it is not, return False since an undulating number should have a decreasing trend after an increasing trend.\n    - Check if the current digit is less than the previous digit. If it is, check if the previous digit is less than the digit before it. If it is not, return False since an undulating number should have an increasing trend after a decreasing trend.\n4. If all the checks pass, return True since the number is undulating.\n\nHere is the code implementation of the logic:\n\n```python\ndef is_undulating_number(num):\n    num_str = str(num)\n    if len(num_str) <= 2:\n        return False\n    for i in range(1, len(num_str)):\n        if num_str[i] == num_str[i-1]:\n            return False\n        if num_str[i] > num_str[i-1] and num_str[i-1] <= num_str[i-2]:\n            return False\n        if num_str[i] < num_str[i-1] and num_str[i-1] >= num_str[i-2]:\n            return False\n    return True\n```\n\nYou can use the above function to check if a given number is undulating or not by passing the number as an argument to the function `is_undulating_number()`. The function will return `True` if the number is undulating, and `False` otherwise.",
        "test": [
            "assert is_undulating(1212121) == True",
            "assert is_undulating(1991) == False",
            "assert is_undulating(121) == True"
        ],
        "draft_plan": [
            "To check whether a given number is undulating or not, we can follow these steps:\n\n1. Convert the given number into a string.\n2. Check if the length of the string is less than or equal to 2. If it is, return False since a number with length less than or equal to 2 cannot be undulating.\n3. Iterate through each digit in the string starting from the second digit.\n    - Check if the current digit is equal to the previous digit. If it is, return False since an undulating number cannot have consecutive same digits.\n    - Check if the current digit is greater than the previous digit. If it is, check if the previous digit is greater than the digit before it. If it is not, return False since an undulating number should have a decreasing trend after an increasing trend.\n    - Check if the current digit is less than the previous digit. If it is, check if the previous digit is less than the digit before it. If it is not, return False since an undulating number should have an increasing trend after a decreasing trend.\n4. If all the checks pass, return True since the number is undulating.\n\nHere is the code implementation of the logic:\n\n```python\ndef is_undulating_number(num):\n    num_str = str(num)\n    if len(num_str) <= 2:\n        return False\n    for i in range(1, len(num_str)):\n        if num_str[i] == num_str[i-1]:\n            return False\n        if num_str[i] > num_str[i-1] and num_str[i-1] <= num_str[i-2]:\n            return False\n        if num_str[i] < num_str[i-1] and num_str[i-1] >= num_str[i-2]:\n            return False\n    return True\n```\n\nYou can use the above function to check if a given number is undulating or not by passing the number as an argument to the function `is_undulating_number()`. The function will return `True` if the number is undulating, and `False` otherwise."
        ],
        "final_plan": [
            "Certainly! Here's the C++ code for checking whether a given number is undulating or not:\n\n```cpp\n#include <iostream>\n#include <string>\n\nbool isUndulatingNumber(int num) {\n    std::string numStr = std::to_string(num);\n    \n    if (numStr.length() <= 2) {\n        return false;\n    }\n    \n    for (int i = 1; i < numStr.length(); i++) {\n        if (numStr[i] == numStr[i - 1]) {\n            return false;\n        }\n        \n        if (numStr[i] > numStr[i - 1] && numStr[i - 1] <= numStr[i - 2]) {\n            return false;\n        }\n        \n        if (numStr[i] < numStr[i - 1] && numStr[i - 1] >= numStr[i - 2]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    int num;\n    std::cout << \"Enter a number: \";\n    std::cin >> num;\n    \n    if (isUndulatingNumber(num)) {\n        std::cout << num << \" is an undulating number.\" << std::endl;\n    } else {\n        std::cout << num << \" is not an undulating number.\" << std::endl;\n    }\n    \n    return 0;\n}\n```\n\nIn the `main` function, we take input from the user and then call the `isUndulatingNumber` function to check if the given number is undulating or not. The function returns a boolean value indicating whether the number is undulating or not. Finally, we print the appropriate message based on the result."
        ]
    },
    {
        "id": "93",
        "prompt": "Write a function to calculate the value of 'a' to the power 'b'.",
        "solution": "def power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)",
        "code": [
            "def power(a,b):\n\tif b==0:\n\t\treturn 1\n\telif a==0:\n\t\treturn 0\n\telif b==1:\n\t\treturn a\n\telse:\n\t\treturn a*power(a,b-1)"
        ],
        "pseudo": "# Initialize the result variable to 1\n\n# If b is positive\n    # Iterate from 1 to b\n        # Multiply the result by a\n\n# If b is negative\n    # Iterate from 1 to abs(b)\n        # Divide the result by a\n\n# Return the result",
        "test": [
            "assert power(3,4) == 81",
            "assert power(2,3) == 8",
            "assert power(5,5) == 3125"
        ],
        "draft_plan": [
            "# Initialize the result variable to 1\n\n# If b is positive\n    # Iterate from 1 to b\n        # Multiply the result by a\n\n# If b is negative\n    # Iterate from 1 to abs(b)\n        # Divide the result by a\n\n# Return the result"
        ],
        "final_plan": [
            "#include <assert.h>\n\ndouble power(double a, int b) {\n    double result = 1;\n\n    if (b > 0) {\n        for (int i = 1; i <= b; i++) {\n            result *= a;\n        }\n    } else if (b < 0) {\n        for (int i = 1; i <= abs(b); i++) {\n            result /= a;\n        }\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "94",
        "prompt": "Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value.",
        "solution": "from operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res) ",
        "code": [
            "from operator import itemgetter \ndef index_minimum(test_list):\n  res = min(test_list, key = itemgetter(1))[0]\n  return (res) "
        ],
        "pseudo": "# Initialize the minimum second value as positive infinity\n# Initialize the first value of the tuple with minimum second value as None\n\n# Iterate through each tuple in the list\n    # Check if the second value of the current tuple is smaller than the current minimum second value\n        # If yes, update the minimum second value and the first value of the tuple\n\n# Return the first value of the tuple with the smallest second value",
        "test": [
            "assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'",
            "assert index_minimum([('Yash', 185), ('Dawood', 125), ('Sanya', 175)]) == 'Dawood'",
            "assert index_minimum([('Sai', 345), ('Salman', 145), ('Ayesha', 96)]) == 'Ayesha'"
        ],
        "draft_plan": [
            "# Initialize the minimum second value as positive infinity\n# Initialize the first value of the tuple with minimum second value as None\n\n# Iterate through each tuple in the list\n    # Check if the second value of the current tuple is smaller than the current minimum second value\n        # If yes, update the minimum second value and the first value of the tuple\n\n# Return the first value of the tuple with the smallest second value"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint get_smallest_first_value(std::vector<std::tuple<int, int>> tuple_list) {\n    int min_second_value = INT_MAX;\n    int smallest_first_value = -1;\n\n    for (const auto& tup : tuple_list) {\n        int first_value = std::get<0>(tup);\n        int second_value = std::get<1>(tup);\n\n        if (second_value < min_second_value) {\n            min_second_value = second_value;\n            smallest_first_value = first_value;\n        }\n    }\n\n    return smallest_first_value;\n}"
        ]
    },
    {
        "id": "95",
        "prompt": "Write a python function to find the length of the smallest list in a list of lists.",
        "solution": "def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength ",
        "code": [
            "def Find_Min_Length(lst):  \n    minLength = min(len(x) for x in lst )\n    return minLength "
        ],
        "pseudo": "# Initialize the minimum length to a large number\n\n# Iterate through each list in the input list\n    # Check the length of the current list\n        # If the length is smaller than the current minimum length, update the minimum length\n\n# Return the minimum length",
        "test": [
            "assert Find_Min_Length([[1],[1,2]]) == 1",
            "assert Find_Min_Length([[1,2],[1,2,3],[1,2,3,4]]) == 2",
            "assert Find_Min_Length([[3,3,3],[4,4,4,4]]) == 3"
        ],
        "draft_plan": [
            "# Initialize the minimum length to a large number\n\n# Iterate through each list in the input list\n    # Check the length of the current list\n        # If the length is smaller than the current minimum length, update the minimum length\n\n# Return the minimum length"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\nint find_smallest_list_length(std::vector<std::vector<int>> lists) {\n    int min_length = INT_MAX;\n\n    for (const auto& list : lists) {\n        int length = list.size();\n        if (length < min_length) {\n            min_length = length;\n        }\n    }\n\n    return min_length;\n}"
        ]
    },
    {
        "id": "96",
        "prompt": "Write a python function to find the number of divisors of a given integer.",
        "solution": "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x",
        "code": [
            "def divisor(n):\n  for i in range(n):\n    x = len([i for i in range(1,n+1) if not n % i])\n  return x"
        ],
        "pseudo": "# Initialize a count variable to 0\n\n# Iterate through each number from 1 to the given integer\n    # Check if the current number is a divisor of the given integer\n        # If yes, increment the count variable\n\n# Return the count variable",
        "test": [
            "assert divisor(15) == 4",
            "assert divisor(12) == 6",
            "assert divisor(9) == 3"
        ],
        "draft_plan": [
            "# Initialize a count variable to 0\n\n# Iterate through each number from 1 to the given integer\n    # Check if the current number is a divisor of the given integer\n        # If yes, increment the count variable\n\n# Return the count variable"
        ],
        "final_plan": [
            "int count_divisors(int num) {\n    int count = 0;\n    \n    for (int i = 1; i <= num; i++) {\n        if (num % i == 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}"
        ]
    },
    {
        "id": "97",
        "prompt": "Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.",
        "solution": "def frequency_lists(list1):\n    list1 = [item for sublist in list1 for item in sublist]\n    dic_data = {}\n    for num in list1:\n        if num in dic_data.keys():\n            dic_data[num] += 1\n        else:\n            key = num\n            value = 1\n            dic_data[key] = value\n    return dic_data\n",
        "code": [
            "def frequency_lists(list1):\n    list1 = [item for sublist in list1 for item in sublist]\n    dic_data = {}\n    for num in list1:\n        if num in dic_data.keys():\n            dic_data[num] += 1\n        else:\n            key = num\n            value = 1\n            dic_data[key] = value\n    return dic_data\n"
        ],
        "pseudo": "# Create an empty dictionary to store the frequency of elements\n\n# Iterate through each sublist in the flattened list\n    # Iterate through each element in the sublist\n        # Check if the element is already in the dictionary\n            # If it is, increment its count by 1\n            # If it is not, add it to the dictionary with a count of 1\n\n# Return the dictionary containing the frequency of each element",
        "test": [
            "assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}",
            "assert frequency_lists([[1,2,3,4],[5,6,7,8],[9,10,11,12]])=={1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1,10:1,11:1,12:1}",
            "assert frequency_lists([[20,30,40,17],[18,16,14,13],[10,20,30,40]])=={20:2,30:2,40:2,17: 1,18:1, 16: 1,14: 1,13: 1, 10: 1}"
        ],
        "draft_plan": [
            "# Create an empty dictionary to store the frequency of elements\n\n# Iterate through each sublist in the flattened list\n    # Iterate through each element in the sublist\n        # Check if the element is already in the dictionary\n            # If it is, increment its count by 1\n            # If it is not, add it to the dictionary with a count of 1\n\n# Return the dictionary containing the frequency of each element"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nstd::unordered_map<int, int> count_frequency(std::vector<std::vector<int>> flattened_list) {\n    std::unordered_map<int, int> frequency_dict;\n\n    for (const auto& sublist : flattened_list) {\n        for (const auto& element : sublist) {\n            if (frequency_dict.find(element) != frequency_dict.end()) {\n                frequency_dict[element]++;\n            } else {\n                frequency_dict[element] = 1;\n            }\n        }\n    }\n\n    return frequency_dict;\n}\n\nint main() {\n    std::vector<std::vector<int>> flattened_list = {{1, 2, 3}, {2, 3, 4}, {3, 4, 5}};\n    std::unordered_map<int, int> frequency_dict = count_frequency(flattened_list);\n\n    for (const auto& pair : frequency_dict) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n    }\n\n    return 0;\n}"
        ]
    },
    {
        "id": "98",
        "prompt": "Write a function to multiply all the numbers in a list and divide with the length of the list.",
        "solution": "def multiply_num(numbers):  \n    total = 1\n    for x in numbers:\n        total *= x  \n    return total/len(numbers) ",
        "code": [
            "def multiply_num(numbers):  \n    total = 1\n    for x in numbers:\n        total *= x  \n    return total/len(numbers) "
        ],
        "pseudo": "# Initialize the product variable to 1\n\n# Iterate through each number in the list\n    # Multiply the product by the current number\n\n# Divide the product by the length of the list\n\n# Return the result",
        "test": [
            "assert math.isclose(multiply_num((8, 2, 3, -1, 7)), -67.2, rel_tol=0.001)",
            "assert math.isclose(multiply_num((-10,-20,-30)), -2000.0, rel_tol=0.001)",
            "assert math.isclose(multiply_num((19,15,18)), 1710.0, rel_tol=0.001)"
        ],
        "draft_plan": [
            "# Initialize the product variable to 1\n\n# Iterate through each number in the list\n    # Multiply the product by the current number\n\n# Divide the product by the length of the list\n\n# Return the result"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <vector>\n\ndouble multiply_and_divide(std::vector<double> numbers) {\n    double product = 1.0;\n    \n    for (double num : numbers) {\n        product *= num;\n    }\n    \n    double result = product / numbers.size();\n    \n    return result;\n}"
        ]
    },
    {
        "id": "99",
        "prompt": "Write a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.",
        "solution": "def decimal_to_binary(n): \n    return bin(n).replace(\"0b\",\"\") ",
        "code": [
            "def decimal_to_binary(n): \n    return bin(n).replace(\"0b\",\"\") "
        ],
        "pseudo": "# Initialize an empty string to store the binary representation\n# Check if the input number is 0, if so return '0' as the binary representation\n# Iterate until the input number becomes 0\n    # Append the remainder of the input number divided by 2 to the binary representation string\n    # Update the input number by dividing it by 2, discarding the remainder\n\n# Reverse the binary representation string\n\n# Return the binary representation string",
        "test": [
            "assert decimal_to_binary(8) == '1000'",
            "assert decimal_to_binary(18) == '10010'",
            "assert decimal_to_binary(7) == '111'"
        ],
        "draft_plan": [
            "# Initialize an empty string to store the binary representation\n# Check if the input number is 0, if so return '0' as the binary representation\n# Iterate until the input number becomes 0\n    # Append the remainder of the input number divided by 2 to the binary representation string\n    # Update the input number by dividing it by 2, discarding the remainder\n\n# Reverse the binary representation string\n\n# Return the binary representation string"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n\nstd::string decimal_to_binary(int number) {\n    if (number == 0) {\n        return \"0\";\n    }\n\n    std::string binary = \"\";\n\n    while (number > 0) {\n        binary += std::to_string(number % 2);\n        number /= 2;\n    }\n\n    std::reverse(binary.begin(), binary.end());\n\n    return binary;\n}"
        ]
    },
    {
        "id": "100",
        "prompt": "Write a function to find the next smallest palindrome of a specified integer, returned as an integer.",
        "solution": "import sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i",
        "code": [
            "import sys\ndef next_smallest_palindrome(num):\n    numstr = str(num)\n    for i in range(num+1,sys.maxsize):\n        if str(i) == str(i)[::-1]:\n            return i"
        ],
        "pseudo": "# Define a helper function to check if a number is palindrome\n    # Convert the number to a string\n    # Check if the string is equal to its reversed string representation\n\n# Start a loop from the next number after the specified integer\n    # Check if the current number is a palindrome\n        # If yes, return the current number\n\n# If no palindrome is found in the loop, return None",
        "test": [
            "assert next_smallest_palindrome(99)==101",
            "assert next_smallest_palindrome(1221)==1331",
            "assert next_smallest_palindrome(120)==121"
        ],
        "draft_plan": [
            "# Define a helper function to check if a number is palindrome\n    # Convert the number to a string\n    # Check if the string is equal to its reversed string representation\n\n# Start a loop from the next number after the specified integer\n    # Check if the current number is a palindrome\n        # If yes, return the current number\n\n# If no palindrome is found in the loop, return None"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <string>\n\nbool is_palindrome(int n) {\n    std::string str = std::to_string(n);\n    int i = 0, j = str.length() - 1;\n    while (i < j) {\n        if (str[i] != str[j])\n            return false;\n        i++;\n        j--;\n    }\n    return true;\n}\n\nint next_smallest_palindrome(int n) {\n    n++;\n    while (!is_palindrome(n)) {\n        n++;\n    }\n    return n;\n}"
        ]
    },
    {
        "id": "101",
        "prompt": "Write a function to find the kth element in the given array using 1-based indexing.",
        "solution": "def kth_element(arr, k):\n  n = len(arr)\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] > arr[j+1]:\n        arr[j], arr[j+1] == arr[j+1], arr[j]\n  return arr[k-1]",
        "code": [
            "def kth_element(arr, k):\n  n = len(arr)\n  for i in range(n):\n    for j in range(0, n-i-1):\n      if arr[j] > arr[j+1]:\n        arr[j], arr[j+1] == arr[j+1], arr[j]\n  return arr[k-1]"
        ],
        "pseudo": "# Sort the array in ascending order\n\n# Check if the kth element is within the range of the array indices\n    # If it is, return the element at index k-1\n\n# If k is out of range, return None",
        "test": [
            "assert kth_element([12,3,5,7,19], 2) == 3",
            "assert kth_element([17,24,8,23], 3) == 8",
            "assert kth_element([16,21,25,36,4], 4) == 36"
        ],
        "draft_plan": [
            "# Sort the array in ascending order\n\n# Check if the kth element is within the range of the array indices\n    # If it is, return the element at index k-1\n\n# If k is out of range, return None"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint find_kth_element(std::vector<int> arr, int k) {\n    std::sort(arr.begin(), arr.end());\n\n    if (k >= 1 && k <= arr.size()) {\n        return arr[k-1];\n    }\n\n    return -1; // Return -1 if k is out of range\n}"
        ]
    },
    {
        "id": "102",
        "prompt": "Write a function to convert a snake case string to camel case string.",
        "solution": "def snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))",
        "code": [
            "def snake_to_camel(word):\n        import re\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))"
        ],
        "pseudo": "# Split the snake case string by underscore to get individual words\n# Capitalize the first letter of each word except the first word\n# Join the words together to form the camel case string\n# Return the camel case string",
        "test": [
            "assert snake_to_camel('python_program')=='PythonProgram'",
            "assert snake_to_camel('python_language')==('PythonLanguage')",
            "assert snake_to_camel('programming_language')==('ProgrammingLanguage')"
        ],
        "draft_plan": [
            "# Split the snake case string by underscore to get individual words\n# Capitalize the first letter of each word except the first word\n# Join the words together to form the camel case string\n# Return the camel case string"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::string snake_to_camel(std::string snake_case) {\n    std::stringstream ss(snake_case);\n    std::string word;\n    std::string camel_case;\n\n    while (std::getline(ss, word, '_')) {\n        if (camel_case.empty()) {\n            camel_case += word;\n        } else {\n            camel_case += std::toupper(word[0]) + word.substr(1);\n        }\n    }\n\n    return camel_case;\n}"
        ]
    },
    {
        "id": "103",
        "prompt": "Write a function to find the Eulerian number a(n, m).",
        "solution": "def eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))",
        "code": [
            "def eulerian_num(n, m): \n\tif (m >= n or n == 0): \n\t\treturn 0 \n\tif (m == 0): \n\t\treturn 1 \n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))"
        ],
        "pseudo": "To find the Eulerian number a(n, m), you can use the following code logic:\n\n1. Define a function called eulerian_number with two parameters n and m.\n2. Create a nested list called dp with n+1 rows and m+1 columns, and initialize all values to 0.\n3. Iterate through each row i from 0 to n and each column j from 0 to m.\n4. Inside the loop, check if i is equal to 0 or j is equal to 0. If true, set dp[i][j] to 1.\n5. Otherwise, set dp[i][j] to (j+1) * dp[i-1][j] + (i-j) * dp[i-1][j-1].\n6. Finally, return dp[n][m].\n\nHere is the code implementation of the above logic:\n\n```python\ndef eulerian_number(n, m):\n    dp = [[0] * (m+1) for _ in range(n+1)]\n\n    for i in range(n+1):\n        for j in range(m+1):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (j+1) * dp[i-1][j] + (i-j) * dp[i-1][j-1]\n    \n    return dp[n][m]\n```\n\nYou can call the function eulerian_number(n, m) and pass the values of n and m to find the corresponding Eulerian number a(n, m).",
        "test": [
            "assert eulerian_num(3, 1) == 4",
            "assert eulerian_num(4, 1) == 11",
            "assert eulerian_num(5, 3) == 26"
        ],
        "draft_plan": [
            "To find the Eulerian number a(n, m), you can use the following code logic:\n\n1. Define a function called eulerian_number with two parameters n and m.\n2. Create a nested list called dp with n+1 rows and m+1 columns, and initialize all values to 0.\n3. Iterate through each row i from 0 to n and each column j from 0 to m.\n4. Inside the loop, check if i is equal to 0 or j is equal to 0. If true, set dp[i][j] to 1.\n5. Otherwise, set dp[i][j] to (j+1) * dp[i-1][j] + (i-j) * dp[i-1][j-1].\n6. Finally, return dp[n][m].\n\nHere is the code implementation of the above logic:\n\n```python\ndef eulerian_number(n, m):\n    dp = [[0] * (m+1) for _ in range(n+1)]\n\n    for i in range(n+1):\n        for j in range(m+1):\n            if i == 0 or j == 0:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (j+1) * dp[i-1][j] + (i-j) * dp[i-1][j-1]\n    \n    return dp[n][m]\n```\n\nYou can call the function eulerian_number(n, m) and pass the values of n and m to find the corresponding Eulerian number a(n, m)."
        ],
        "final_plan": [
            "Certainly! Here's the C++ code implementation for finding the Eulerian number a(n, m) using dynamic programming:\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint eulerian_number(int n, int m) {\n    std::vector<std::vector<int>> dp(n+1, std::vector<int>(m+1, 0));\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= m; j++) {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = (j+1) * dp[i-1][j] + (i-j) * dp[i-1][j-1];\n            }\n        }\n    }\n\n    return dp[n][m];\n}\n\nint main() {\n    int n, m;\n    std::cout << \"Enter the values of n and m: \";\n    std::cin >> n >> m;\n    \n    int result = eulerian_number(n, m);\n    std::cout << \"The Eulerian number a(\" << n << \", \" << m << \") is: \" << result << std::endl;\n\n    return 0;\n}\n```\n\nYou can run the code by entering the values of n and m, and it will display the corresponding Eulerian number a(n, m)."
        ]
    },
    {
        "id": "104",
        "prompt": "Write a function to sort each sublist of strings in a given list of lists.",
        "solution": "def sort_sublists(input_list):\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \n    return result\n",
        "code": [
            "def sort_sublists(input_list):\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \n    return result\n"
        ],
        "pseudo": "# Iterate through each sublist in the given list\n    # Sort the sublist using the sorted() function and assign the sorted sublist back to the original sublist\n\n# Return the modified list with sorted sublists",
        "test": [
            "assert sort_sublists(([\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]))==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]",
            "assert sort_sublists(([\" red \",\"green\" ],[\"blue \",\" black\"],[\" orange\",\"brown\"]))==[[' red ', 'green'], [' black', 'blue '], [' orange', 'brown']]",
            "assert sort_sublists(([\"zilver\",\"gold\"], [\"magnesium\",\"aluminium\"], [\"steel\", \"bronze\"]))==[['gold', 'zilver'],['aluminium', 'magnesium'], ['bronze', 'steel']]"
        ],
        "draft_plan": [
            "# Iterate through each sublist in the given list\n    # Sort the sublist using the sorted() function and assign the sorted sublist back to the original sublist\n\n# Return the modified list with sorted sublists"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<std::string>> sort_sublists(std::vector<std::vector<std::string>> input_list) {\n    for (auto& sublist : input_list) {\n        std::sort(sublist.begin(), sublist.end());\n    }\n    return input_list;\n}"
        ]
    },
    {
        "id": "105",
        "prompt": "Write a python function to count true booleans in the given list.",
        "solution": "def count(lst):   \n    return sum(lst) ",
        "code": [
            "def count(lst):   \n    return sum(lst) "
        ],
        "pseudo": "# Initialize a count variable to 0\n\n# Iterate through each element in the list\n    # Check if the current element is True\n        # If it is, increment the count variable\n\n# Return the count variable",
        "test": [
            "assert count([True,False,True]) == 2",
            "assert count([False,False]) == 0",
            "assert count([True,True,True]) == 3"
        ],
        "draft_plan": [
            "# Initialize a count variable to 0\n\n# Iterate through each element in the list\n    # Check if the current element is True\n        # If it is, increment the count variable\n\n# Return the count variable"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n\nint count_true_booleans(std::vector<bool> bool_list) {\n    int count = 0;\n    \n    for (bool element : bool_list) {\n        if (element == true) {\n            count++;\n        }\n    }\n    \n    return count;\n}"
        ]
    },
    {
        "id": "106",
        "prompt": "Write a function to append the given list to the given tuples.",
        "solution": "def add_lists(test_list, test_tup):\n  res = tuple(list(test_tup) + test_list)\n  return (res) ",
        "code": [
            "def add_lists(test_list, test_tup):\n  res = tuple(list(test_tup) + test_list)\n  return (res) "
        ],
        "pseudo": "# Create an empty list to store the modified tuples\n\n# Iterate through each tuple in the given list\n    # Convert the tuple to a list\n    # Append the given list to the current tuple\n    # Convert the modified tuple back to a tuple\n    # Append the modified tuple to the list of modified tuples\n\n# Return the list of modified tuples",
        "test": [
            "assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)",
            "assert add_lists([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)",
            "assert add_lists([7, 8, 9], (11, 12)) == (11, 12, 7, 8, 9)"
        ],
        "draft_plan": [
            "# Create an empty list to store the modified tuples\n\n# Iterate through each tuple in the given list\n    # Convert the tuple to a list\n    # Append the given list to the current tuple\n    # Convert the modified tuple back to a tuple\n    # Append the modified tuple to the list of modified tuples\n\n# Return the list of modified tuples"
        ],
        "final_plan": [
            "#include<assert.h>\n#include<bits/stdc++.h>\n\nstd::vector<std::tuple<int, int, std::vector<int>>> append_list_to_tuples(std::vector<std::tuple<int, int>> tuples, std::vector<int> lst) {\n    std::vector<std::tuple<int, int, std::vector<int>>> modified_tuples;\n\n    for (const auto& tup : tuples) {\n        std::tuple<int, int> current_tuple = tup;\n        std::vector<int> modified_list = std::get<2>(current_tuple);\n        modified_list.insert(modified_list.end(), lst.begin(), lst.end());\n        std::tuple<int, int, std::vector<int>> modified_tuple = std::make_tuple(std::get<0>(current_tuple), std::get<1>(current_tuple), modified_list);\n        modified_tuples.push_back(modified_tuple);\n    }\n\n    return modified_tuples;\n}"
        ]
    },
    {
        "id": "108",
        "prompt": "Write a function to merge three lists into a single sorted list.",
        "solution": "import heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)",
        "code": [
            "import heapq\ndef merge_sorted_list(num1,num2,num3):\n  num1=sorted(num1)\n  num2=sorted(num2)\n  num3=sorted(num3)\n  result = heapq.merge(num1,num2,num3)\n  return list(result)"
        ],
        "pseudo": "# Concatenate all three lists into a single list\n# Sort the merged list using the sorted() function\n# Return the sorted merged list",
        "test": [
            "assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]",
            "assert merge_sorted_list([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12])==[1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]",
            "assert merge_sorted_list([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1],[25, 35, 22, 85, 14, 65, 75, 25, 58],[12, 74, 9, 50, 61, 41])==[1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]"
        ],
        "draft_plan": [
            "# Concatenate all three lists into a single list\n# Sort the merged list using the sorted() function\n# Return the sorted merged list"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<int> merge_lists(std::vector<int> list1, std::vector<int> list2, std::vector<int> list3) {\n    std::vector<int> merged_list;\n    merged_list.insert(merged_list.end(), list1.begin(), list1.end());\n    merged_list.insert(merged_list.end(), list2.begin(), list2.end());\n    merged_list.insert(merged_list.end(), list3.begin(), list3.end());\n\n    std::sort(merged_list.begin(), merged_list.end());\n\n    return merged_list;\n}"
        ]
    },
    {
        "id": "109",
        "prompt": "Write a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.",
        "solution": "def odd_Equivalent(s,n): \n    count=0\n    for i in range(0,n): \n        if (s[i] == '1'): \n            count = count + 1\n    return count ",
        "code": [
            "def odd_Equivalent(s,n): \n    count=0\n    for i in range(0,n): \n        if (s[i] == '1'): \n            count = count + 1\n    return count "
        ],
        "pseudo": "# Convert the binary string to a list of characters\n# Initialize a counter variable to keep track of the number of odd numbers\n\n# Rotate the binary string the given number of times\n    # Remove the last character from the binary string and prepend it to the front\n\n# Convert the rotated binary string back to a string\n# Iterate through each character in the rotated binary string\n    # Convert the character to an integer\n    # Check if the integer value is odd\n        # If so, increment the counter\n\n# Return the counter value",
        "test": [
            "assert odd_Equivalent(\"011001\",6) == 3",
            "assert odd_Equivalent(\"11011\",5) == 4",
            "assert odd_Equivalent(\"1010\",4) == 2"
        ],
        "draft_plan": [
            "# Convert the binary string to a list of characters\n# Initialize a counter variable to keep track of the number of odd numbers\n\n# Rotate the binary string the given number of times\n    # Remove the last character from the binary string and prepend it to the front\n\n# Convert the rotated binary string back to a string\n# Iterate through each character in the rotated binary string\n    # Convert the character to an integer\n    # Check if the integer value is odd\n        # If so, increment the counter\n\n# Return the counter value"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint count_odd_rotations(std::string binary_string, int num_rotations) {\n    std::vector<char> binary_list(binary_string.begin(), binary_string.end());\n    int odd_count = 0;\n\n    for (int i = 0; i < num_rotations; i++) {\n        char last_char = binary_list.back();\n        binary_list.pop_back();\n        binary_list.insert(binary_list.begin(), last_char);\n    }\n\n    std::string rotated_string(binary_list.begin(), binary_list.end());\n\n    for (char c : rotated_string) {\n        int num = c - '0';\n        if (num % 2 == 1) {\n            odd_count++;\n        }\n    }\n\n    return odd_count;\n}"
        ]
    },
    {
        "id": "111",
        "prompt": "Write a function to find the common elements in given nested lists.",
        "solution": "def common_in_nested_lists(nestedlist):\n    result = list(set.intersection(*map(set, nestedlist)))\n    return result",
        "code": [
            "def common_in_nested_lists(nestedlist):\n    result = list(set.intersection(*map(set, nestedlist)))\n    return result"
        ],
        "pseudo": "# Initialize a set to store the common elements\n\n# Iterate through each sublist in the nested list\n    # If it's the first sublist, add all elements to the set\n    # For subsequent sublists, update the set with the intersection of the current set and the sublist\n    \n# Return the set containing the common elements",
        "test": [
            "assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]))==set([18, 12])",
            "assert set(common_in_nested_lists([[12, 5, 23, 25, 45], [7, 11, 5, 23, 28], [1, 5, 8, 18, 23, 16]]))==set([5,23])",
            "assert set(common_in_nested_lists([[2, 3,4, 1], [4, 5], [6,4, 8],[4, 5], [6, 8,4]]))==set([4])"
        ],
        "draft_plan": [
            "# Initialize a set to store the common elements\n\n# Iterate through each sublist in the nested list\n    # If it's the first sublist, add all elements to the set\n    # For subsequent sublists, update the set with the intersection of the current set and the sublist\n    \n# Return the set containing the common elements"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <unordered_set>\n#include <vector>\n\nstd::unordered_set<int> find_common_elements(const std::vector<std::vector<int>>& nested_lists) {\n    std::unordered_set<int> common_elements;\n    bool first_list = true;\n\n    for (const auto& sublist : nested_lists) {\n        if (first_list) {\n            common_elements.insert(sublist.begin(), sublist.end());\n            first_list = false;\n        } else {\n            std::unordered_set<int> sublist_set(sublist.begin(), sublist.end());\n\n            std::unordered_set<int> intersection;\n            for (const auto& element : sublist_set) {\n                if (common_elements.count(element) > 0) {\n                    intersection.insert(element);\n                }\n            }\n\n            common_elements = intersection;\n        }\n    }\n\n    return common_elements;\n}"
        ]
    },
    {
        "id": "113",
        "prompt": "Write a function to check if a string represents an integer or not.",
        "solution": "def check_integer(text):\n text = text.strip()\n if len(text) < 1:\n    return None\n else:\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\n          return True\n     elif (text[0] in \"+-\") and \\\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\n         return True\n     else:\n        return False",
        "code": [
            "def check_integer(text):\n text = text.strip()\n if len(text) < 1:\n    return None\n else:\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\n          return True\n     elif (text[0] in \"+-\") and \\\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\n         return True\n     else:\n        return False"
        ],
        "pseudo": "# Check if the string is empty or None\n    # If so, return False\n\n# Check if the string starts with a '+' or '-'\n    # If so, remove the sign from the string\n\n# Check if the string consists only of digits\n    # If so, return True\n\n# If the string is non-empty and does not start with a sign, it is not a valid integer representation\n    # Return False",
        "test": [
            "assert check_integer(\"python\")==False",
            "assert check_integer(\"1\")==True",
            "assert check_integer(\"12345\")==True"
        ],
        "draft_plan": [
            "# Check if the string is empty or None\n    # If so, return False\n\n# Check if the string starts with a '+' or '-'\n    # If so, remove the sign from the string\n\n# Check if the string consists only of digits\n    # If so, return True\n\n# If the string is non-empty and does not start with a sign, it is not a valid integer representation\n    # Return False"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n\nbool is_integer(std::string str) {\n    // Check if the string is empty or None\n    if (str.empty()) {\n        return false;\n    }\n\n    // Check if the string starts with a '+' or '-'\n    if (str[0] == '+' || str[0] == '-') {\n        str = str.substr(1); // remove the sign from the string\n    }\n\n    // Check if the string consists only of digits\n    for (char c : str) {\n        if (!std::isdigit(c)) {\n            return false;\n        }\n    }\n\n    // If the string is non-empty and does not start with a sign, it is not a valid integer representation\n    return !str.empty();\n}"
        ]
    },
    {
        "id": "115",
        "prompt": "Write a function to check whether all dictionaries in a list are empty or not.",
        "solution": "def empty_dit(list1):\n empty_dit=all(not d for d in list1)\n return empty_dit",
        "code": [
            "def empty_dit(list1):\n empty_dit=all(not d for d in list1)\n return empty_dit"
        ],
        "pseudo": "# Iterate through each dictionary in the list\n    # Check if the current dictionary is empty\n        # If any dictionary is not empty, return False\n\n# If all dictionaries are empty, return True",
        "test": [
            "assert empty_dit([{},{},{}])==True",
            "assert empty_dit([{1,2},{},{}])==False",
            "assert empty_dit({})==True"
        ],
        "draft_plan": [
            "# Iterate through each dictionary in the list\n    # Check if the current dictionary is empty\n        # If any dictionary is not empty, return False\n\n# If all dictionaries are empty, return True"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n#include <map>\n\nbool all_dictionaries_empty(const std::vector<std::map<int, int>>& dictionaries) {\n    for (const auto& dictionary : dictionaries) {\n        if (!dictionary.empty()) {\n            return false;\n        }\n    }\n    return true;\n}"
        ]
    },
    {
        "id": "116",
        "prompt": "Write a function to convert a given tuple of positive integers into a single integer.",
        "solution": "def tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result",
        "code": [
            "def tuple_to_int(nums):\n    result = int(''.join(map(str,nums)))\n    return result"
        ],
        "pseudo": "# Initialize an empty string to store the converted integer\n\n# Iterate through each element in the tuple\n    # Convert each element to a string and concatenate it to the existing string\n\n# Convert the string to an integer and return it",
        "test": [
            "assert tuple_to_int((1,2,3))==123",
            "assert tuple_to_int((4,5,6))==456",
            "assert tuple_to_int((5,6,7))==567"
        ],
        "draft_plan": [
            "# Initialize an empty string to store the converted integer\n\n# Iterate through each element in the tuple\n    # Convert each element to a string and concatenate it to the existing string\n\n# Convert the string to an integer and return it"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <tuple>\n#include <string>\n\nint convert_tuple_to_integer(std::tuple<int, int, int> input_tuple) {\n    std::string result = \"\";\n\n    result += std::to_string(std::get<0>(input_tuple));\n    result += std::to_string(std::get<1>(input_tuple));\n    result += std::to_string(std::get<2>(input_tuple));\n\n    return std::stoi(result);\n}"
        ]
    },
    {
        "id": "117",
        "prompt": "Write a function to convert all possible convertible elements in a list of lists to floats.",
        "solution": "def list_to_float(test_list):\n  res = []\n  for tup in test_list:\n    temp = []\n    for ele in tup:\n      if ele.isalpha():\n        temp.append(ele)\n      else:\n        temp.append(float(ele))\n    res.append((temp[0],temp[1])) \n  return res",
        "code": [
            "def list_to_float(test_list):\n  res = []\n  for tup in test_list:\n    temp = []\n    for ele in tup:\n      if ele.isalpha():\n        temp.append(ele)\n      else:\n        temp.append(float(ele))\n    res.append((temp[0],temp[1])) \n  return res"
        ],
        "pseudo": "# Iterate through each sublist in the input list\n    # Iterate through each element in the sublist\n        # Try to convert the element to a float\n        # If successful, replace the element with the float value\n\n# Return the modified input list",
        "test": [
            "assert list_to_float( [(\"3\", \"4\"), (\"1\", \"26.45\"), (\"7.32\", \"8\"), (\"4\", \"8\")] ) == [(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]",
            "assert list_to_float( [(\"4\", \"4\"), (\"2\", \"27\"), (\"4.12\", \"9\"), (\"7\", \"11\")] ) == [(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)]",
            "assert list_to_float( [(\"6\", \"78\"), (\"5\", \"26.45\"), (\"1.33\", \"4\"), (\"82\", \"13\")] ) == [(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]"
        ],
        "draft_plan": [
            "# Iterate through each sublist in the input list\n    # Iterate through each element in the sublist\n        # Try to convert the element to a float\n        # If successful, replace the element with the float value\n\n# Return the modified input list"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n#include <typeinfo>\n#include <stdexcept>\n\nvoid convert_to_float(std::vector<std::vector<std::string>>& list_of_lists) {\n    for (auto& sublist : list_of_lists) {\n        for (auto& element : sublist) {\n            try {\n                float converted_element = std::stof(element);\n                element = std::to_string(converted_element);\n            } catch (const std::invalid_argument& e) {\n                // Element cannot be converted to float, do nothing\n            }\n        }\n    }\n}"
        ]
    },
    {
        "id": "118",
        "prompt": "Write a function to convert a string to a list of strings split on the space character.",
        "solution": "def string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst",
        "code": [
            "def string_to_list(string): \n    lst = list(string.split(\" \")) \n    return lst"
        ],
        "pseudo": "# Initialize an empty list to store the split strings\n\n# Split the input string on the space character and store the result in a variable\n\n# Iterate through each element in the split result\n    # Append the element to the list\n\n# Return the list of split strings",
        "test": [
            "assert string_to_list(\"python programming\")==['python','programming']",
            "assert string_to_list(\"lists tuples strings\")==['lists','tuples','strings']",
            "assert string_to_list(\"write a program\")==['write','a','program']"
        ],
        "draft_plan": [
            "# Initialize an empty list to store the split strings\n\n# Split the input string on the space character and store the result in a variable\n\n# Iterate through each element in the split result\n    # Append the element to the list\n\n# Return the list of split strings"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<std::string> split_string(std::string input_string) {\n    std::vector<std::string> split_strings;\n    std::istringstream iss(input_string);\n    std::string token;\n\n    while (std::getline(iss, token, ' ')) {\n        split_strings.push_back(token);\n    }\n\n    return split_strings;\n}"
        ]
    },
    {
        "id": "119",
        "prompt": "Write a python function to find the element that appears only once in a sorted array.",
        "solution": "def search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)",
        "code": [
            "def search(arr):\n    n = len(arr)\n    XOR = 0\n    for i in range(n) :\n        XOR = XOR ^ arr[i]\n    return (XOR)"
        ],
        "pseudo": "# Initialize a variable to keep track of the unique element\n# Iterate through the sorted array\n    # Check if the current element is equal to the next element and the previous element\n        # If not, assign the current element to the unique variable\n\n# Return the unique element",
        "test": [
            "assert search([1,1,2,2,3]) == 3",
            "assert search([1,1,3,3,4,4,5,5,7,7,8]) == 8",
            "assert search([1,2,2,3,3,4,4]) == 1"
        ],
        "draft_plan": [
            "# Initialize a variable to keep track of the unique element\n# Iterate through the sorted array\n    # Check if the current element is equal to the next element and the previous element\n        # If not, assign the current element to the unique variable\n\n# Return the unique element"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint find_unique_element(std::vector<int> sorted_array) {\n    int unique_element = sorted_array[0];\n  \n    for (int i = 1; i < sorted_array.size(); i++) {\n        if (sorted_array[i] != sorted_array[i-1] && sorted_array[i] != sorted_array[i+1]) {\n            unique_element = sorted_array[i];\n            break;\n        }\n    }\n  \n    return unique_element;\n}"
        ]
    },
    {
        "id": "120",
        "prompt": "Write a function to find the maximum absolute product between numbers in pairs of tuples within a given list.",
        "solution": "def max_product_tuple(list1):\n    result_max = max([abs(x * y) for x, y in list1] )\n    return result_max",
        "code": [
            "def max_product_tuple(list1):\n    result_max = max([abs(x * y) for x, y in list1] )\n    return result_max"
        ],
        "pseudo": "# Initialize the maximum product to 0\n\n# Iterate through each pair of tuples in the given list\n    # Calculate the product of the absolute values of the numbers in the current pair\n    # If the calculated product is greater than the maximum product, update the maximum product\n\n# Return the maximum product",
        "test": [
            "assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36",
            "assert max_product_tuple([(10,20), (15,2), (5,10)] )==200",
            "assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484"
        ],
        "draft_plan": [
            "# Initialize the maximum product to 0\n\n# Iterate through each pair of tuples in the given list\n    # Calculate the product of the absolute values of the numbers in the current pair\n    # If the calculated product is greater than the maximum product, update the maximum product\n\n# Return the maximum product"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n#include <assert.h>\n\nint max_absolute_product(std::vector<std::pair<int, int>> pairs) {\n    int max_product = 0;\n  \n    for (const auto& pair : pairs) {\n        int product = abs(pair.first) * abs(pair.second);\n        if (product > max_product) {\n            max_product = product;\n        }\n    }\n  \n    return max_product;\n}"
        ]
    },
    {
        "id": "123",
        "prompt": "Write a function to sum all amicable numbers from 1 to a specified number.",
        "solution": "def amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)",
        "code": [
            "def amicable_numbers_sum(limit):\n    if not isinstance(limit, int):\n        return \"Input is not an integer!\"\n    if limit < 1:\n        return \"Input must be bigger than 0!\"\n    amicables = set()\n    for num in range(2, limit+1):\n        if num in amicables:\n            continue\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\n        if num == sum_fact2 and num != sum_fact:\n            amicables.add(num)\n            amicables.add(sum_fact2)\n    return sum(amicables)"
        ],
        "pseudo": "# Define a helper function to calculate the sum of proper divisors for a given number\n    # Initialize the sum to 0\n    # Iterate from 1 to the given number (excluding the number itself)\n        # Check if the current number is a proper divisor of the given number\n            # If it is, add it to the sum\n\n# Define the main function to find and sum all amicable numbers up to a specified number\n    # Initialize the sum of amicable numbers to 0\n    # Iterate from 1 to the specified number\n        # Calculate the sum of proper divisors for the current number\n        # Check if the sum of proper divisors is different from the current number\n            # If it is, calculate the sum of proper divisors for the sum of proper divisors\n            # Check if the second sum of proper divisors is equal to the current number\n                # If it is, add the current number to the sum of amicable numbers\n\n# Return the sum of amicable numbers",
        "test": [
            "assert amicable_numbers_sum(999)==504",
            "assert amicable_numbers_sum(9999)==31626",
            "assert amicable_numbers_sum(99)==0"
        ],
        "draft_plan": [
            "# Define a helper function to calculate the sum of proper divisors for a given number\n    # Initialize the sum to 0\n    # Iterate from 1 to the given number (excluding the number itself)\n        # Check if the current number is a proper divisor of the given number\n            # If it is, add it to the sum\n\n# Define the main function to find and sum all amicable numbers up to a specified number\n    # Initialize the sum of amicable numbers to 0\n    # Iterate from 1 to the specified number\n        # Calculate the sum of proper divisors for the current number\n        # Check if the sum of proper divisors is different from the current number\n            # If it is, calculate the sum of proper divisors for the sum of proper divisors\n            # Check if the second sum of proper divisors is equal to the current number\n                # If it is, add the current number to the sum of amicable numbers\n\n# Return the sum of amicable numbers"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint sum_proper_divisors(int num) {\n    int sum = 0;\n    for (int i = 1; i <= num/2; i++) {\n        if (num % i == 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nint sum_amicable_numbers(int n) {\n    int sum = 0;\n    for (int i = 1; i <= n; i++) {\n        int divisor_sum = sum_proper_divisors(i);\n        if (divisor_sum != i && sum_proper_divisors(divisor_sum) == i) {\n            sum += i;\n        }\n    }\n    return sum;\n}"
        ]
    },
    {
        "id": "124",
        "prompt": "Write a function to get the angle of a complex number.",
        "solution": "import cmath\ndef angle_complex(a,b):\n  cn=complex(a,b)\n  angle=cmath.phase(a+b)\n  return angle",
        "code": [
            "import cmath\ndef angle_complex(a,b):\n  cn=complex(a,b)\n  angle=cmath.phase(a+b)\n  return angle"
        ],
        "pseudo": "import math\n\ndef get_angle(complex_num):\n    # Calculate the angle using the arctan2 function from the math module\n    angle = math.atan2(complex_num.imag, complex_num.real)\n    \n    # Convert the angle from radians to degrees\n    angle_degrees = math.degrees(angle)\n    \n    # Return the angle in degrees\n    return angle_degrees",
        "test": [
            "assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)",
            "assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)",
            "assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)"
        ],
        "draft_plan": [
            "import math\n\ndef get_angle(complex_num):\n    # Calculate the angle using the arctan2 function from the math module\n    angle = math.atan2(complex_num.imag, complex_num.real)\n    \n    # Convert the angle from radians to degrees\n    angle_degrees = math.degrees(angle)\n    \n    # Return the angle in degrees\n    return angle_degrees"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <cmath>\n\ndouble get_angle(std::complex<double> complex_num) {\n    // Calculate the angle using the argument function from the cmath library\n    double angle = std::arg(complex_num);\n    \n    // Convert the angle from radians to degrees\n    double angle_degrees = std::fmod(std::fmod(angle, 2 * M_PI) + 2 * M_PI, 2 * M_PI);\n    if (angle_degrees > M_PI) {\n        angle_degrees -= 2 * M_PI;\n    }\n    \n    // Return the angle in degrees\n    return std::fmod(angle_degrees, 360.0);\n}"
        ]
    },
    {
        "id": "125",
        "prompt": "Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.",
        "solution": "def find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0",
        "code": [
            "def find_length(string): \n\tn = len(string)\n\tcurrent_sum = 0\n\tmax_sum = 0\n\tfor i in range(n): \n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \n\t\tif current_sum < 0: \n\t\t\tcurrent_sum = 0\n\t\tmax_sum = max(current_sum, max_sum) \n\treturn max_sum if max_sum else 0"
        ],
        "pseudo": "# Initialize the maximum difference as 0\n\n# Iterate through each character in the binary string\n    # If the current character is '0', increment a count variable by 1\n    # If the current character is '1', decrement the count variable by 1\n\n    # Check if the count variable is greater than the maximum difference\n        # If so, update the maximum difference to the count variable\n\n# Return the maximum difference as the result",
        "test": [
            "assert find_length(\"11000010001\") == 6",
            "assert find_length(\"10111\") == 1",
            "assert find_length(\"11011101100101\") == 2"
        ],
        "draft_plan": [
            "# Initialize the maximum difference as 0\n\n# Iterate through each character in the binary string\n    # If the current character is '0', increment a count variable by 1\n    # If the current character is '1', decrement the count variable by 1\n\n    # Check if the count variable is greater than the maximum difference\n        # If so, update the maximum difference to the count variable\n\n# Return the maximum difference as the result"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n#include <cassert>\n\nint max_difference(std::string binary_string) {\n    int max_diff = 0;\n    int count = 0;\n\n    for (char c : binary_string) {\n        if (c == '0') {\n            count++;\n        } else if (c == '1') {\n            count--;\n        }\n\n        if (count > max_diff) {\n            max_diff = count;\n        }\n    }\n\n    return max_diff;\n}"
        ]
    },
    {
        "id": "126",
        "prompt": "Write a python function to find the sum of common divisors of two given numbers.",
        "solution": "def sum(a,b): \n    sum = 0\n    for i in range (1,min(a,b)): \n        if (a % i == 0 and b % i == 0): \n            sum += i \n    return sum",
        "code": [
            "def sum(a,b): \n    sum = 0\n    for i in range (1,min(a,b)): \n        if (a % i == 0 and b % i == 0): \n            sum += i \n    return sum"
        ],
        "pseudo": "# Find the common divisors of the two given numbers\n    # Find the smaller number among the two\n    # Initialize an empty list to store the common divisors\n    # Iterate from 1 to the smaller number\n        # Check if the current number is a divisor of both given numbers\n            # If yes, add it to the list of common divisors\n\n# Find the sum of the common divisors\n    # Initialize a variable to store the sum\n    # Iterate through the list of common divisors\n        # Add each divisor to the sum\n\n# Return the sum of the common divisors",
        "test": [
            "assert sum(10,15) == 6",
            "assert sum(100,150) == 93",
            "assert sum(4,6) == 3"
        ],
        "draft_plan": [
            "# Find the common divisors of the two given numbers\n    # Find the smaller number among the two\n    # Initialize an empty list to store the common divisors\n    # Iterate from 1 to the smaller number\n        # Check if the current number is a divisor of both given numbers\n            # If yes, add it to the list of common divisors\n\n# Find the sum of the common divisors\n    # Initialize a variable to store the sum\n    # Iterate through the list of common divisors\n        # Add each divisor to the sum\n\n# Return the sum of the common divisors"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\nint sum_of_common_divisors(int num1, int num2) {\n    int smaller = (num1 < num2) ? num1 : num2;\n    std::vector<int> common_divisors;\n\n    for (int i = 1; i <= smaller; i++) {\n        if (num1 % i == 0 && num2 % i == 0) {\n            common_divisors.push_back(i);\n        }\n    }\n\n    int sum = 0;\n    for (int divisor : common_divisors) {\n        sum += divisor;\n    }\n\n    return sum;\n}"
        ]
    },
    {
        "id": "127",
        "prompt": "Write a function to multiply two integers.",
        "solution": "def multiply_int(x, y):\n    if y < 0:\n        return -multiply_int(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)",
        "code": [
            "def multiply_int(x, y):\n    if y < 0:\n        return -multiply_int(x, -y)\n    elif y == 0:\n        return 0\n    elif y == 1:\n        return x\n    else:\n        return x + multiply_int(x, y - 1)"
        ],
        "pseudo": "# Initialize the result to 0\n\n# If either of the integers is 0, return 0\n\n# If both integers are negative, convert them to positive\n    # Multiply the positive integers and change the sign of the result to negative\n\n# If only one integer is negative, convert it to positive\n    # Multiply the positive integers and change the sign of the result to negative\n\n# If both integers are positive, multiply them normally\n\n# Return the result",
        "test": [
            "assert multiply_int(10,20)==200",
            "assert multiply_int(5,10)==50",
            "assert multiply_int(4,8)==32"
        ],
        "draft_plan": [
            "# Initialize the result to 0\n\n# If either of the integers is 0, return 0\n\n# If both integers are negative, convert them to positive\n    # Multiply the positive integers and change the sign of the result to negative\n\n# If only one integer is negative, convert it to positive\n    # Multiply the positive integers and change the sign of the result to negative\n\n# If both integers are positive, multiply them normally\n\n# Return the result"
        ],
        "final_plan": [
            "#include <assert.h>\n\nint multiply(int a, int b) {\n    int result = 0;\n\n    if (a == 0 || b == 0) {\n        return 0;\n    }\n\n    if (a < 0 && b < 0) {\n        a = -a;\n        b = -b;\n    } else if (a < 0) {\n        a = -a;\n        result = -result;\n    } else if (b < 0) {\n        b = -b;\n        result = -result;\n    }\n\n    while (b > 0) {\n        if (b % 2 == 1) {\n            result += a;\n        }\n        a <<= 1;\n        b >>= 1;\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "128",
        "prompt": "Write a function to find words that are longer than n characters from a given list of words.",
        "solution": "def long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len\t",
        "code": [
            "def long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len\t"
        ],
        "pseudo": "# Create an empty list to store the result\n\n# Iterate through each word in the given list\n    # Check if the length of the current word is greater than n\n        # If the condition is satisfied, append the word to the result list\n\n# Return the result list",
        "test": [
            "assert long_words(3,\"python is a programming language\")==['python','programming','language']",
            "assert long_words(2,\"writing a program\")==['writing','program']",
            "assert long_words(5,\"sorting list\")==['sorting']"
        ],
        "draft_plan": [
            "# Create an empty list to store the result\n\n# Iterate through each word in the given list\n    # Check if the length of the current word is greater than n\n        # If the condition is satisfied, append the word to the result list\n\n# Return the result list"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<std::string> find_long_words(std::vector<std::string> word_list, int n) {\n    std::vector<std::string> result;\n\n    for (const auto& word : word_list) {\n        if (word.length() > n) {\n            result.push_back(word);\n        }\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "129",
        "prompt": "Write a function to calculate whether the matrix is a magic square.",
        "solution": "def magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True",
        "code": [
            "def magic_square_test(my_matrix):\n    iSize = len(my_matrix[0])\n    sum_list = []\n    sum_list.extend([sum (lines) for lines in my_matrix])   \n    for col in range(iSize):\n        sum_list.append(sum(row[col] for row in my_matrix))\n    result1 = 0\n    for i in range(0,iSize):\n        result1 +=my_matrix[i][i]\n    sum_list.append(result1)      \n    result2 = 0\n    for i in range(iSize-1,-1,-1):\n        result2 +=my_matrix[i][i]\n    sum_list.append(result2)\n    if len(set(sum_list))>1:\n        return False\n    return True"
        ],
        "pseudo": "# Calculate the sum of each row, column, and diagonal of the matrix\n    # Iterate through each row of the matrix\n        # Calculate the sum of the current row\n    # Iterate through each column of the matrix\n        # Calculate the sum of the current column\n    # Calculate the sum of the main diagonal\n    # Calculate the sum of the anti-diagonal\n\n# Check if the sums of all rows, columns, and diagonals are equal and equal to the magic sum\n    # If all sums are equal to the magic sum, return True\n    # If any sum is not equal to the magic sum, return False",
        "test": [
            "assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True",
            "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]])==True",
            "assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 7]])==False"
        ],
        "draft_plan": [
            "# Calculate the sum of each row, column, and diagonal of the matrix\n    # Iterate through each row of the matrix\n        # Calculate the sum of the current row\n    # Iterate through each column of the matrix\n        # Calculate the sum of the current column\n    # Calculate the sum of the main diagonal\n    # Calculate the sum of the anti-diagonal\n\n# Check if the sums of all rows, columns, and diagonals are equal and equal to the magic sum\n    # If all sums are equal to the magic sum, return True\n    # If any sum is not equal to the magic sum, return False"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nbool is_magic_square(std::vector<std::vector<int>>& matrix) {\n    int size = matrix.size();\n    int magic_sum = 0;\n\n    // Calculate the magic sum\n    for (int i = 0; i < size; i++) {\n        magic_sum += matrix[0][i];\n    }\n\n    // Calculate the sum of each row\n    for (int i = 0; i < size; i++) {\n        int row_sum = 0;\n        for (int j = 0; j < size; j++) {\n            row_sum += matrix[i][j];\n        }\n        if (row_sum != magic_sum) {\n            return false;\n        }\n    }\n\n    // Calculate the sum of each column\n    for (int i = 0; i < size; i++) {\n        int col_sum = 0;\n        for (int j = 0; j < size; j++) {\n            col_sum += matrix[j][i];\n        }\n        if (col_sum != magic_sum) {\n            return false;\n        }\n    }\n\n    // Calculate the sum of the main diagonal\n    int diagonal_sum = 0;\n    for (int i = 0; i < size; i++) {\n        diagonal_sum += matrix[i][i];\n    }\n    if (diagonal_sum != magic_sum) {\n        return false;\n    }\n\n    // Calculate the sum of the anti-diagonal\n    int anti_diagonal_sum = 0;\n    for (int i = 0; i < size; i++) {\n        anti_diagonal_sum += matrix[i][size - 1 - i];\n    }\n    if (anti_diagonal_sum != magic_sum) {\n        return false;\n    }\n\n    // If all sums are equal to the magic sum, return true\n    return true;\n}"
        ]
    },
    {
        "id": "130",
        "prompt": "Write a function to find the item with maximum frequency in a given list.",
        "solution": "from collections import defaultdict\ndef max_occurrences(nums):\n    dict = defaultdict(int)\n    for i in nums:\n        dict[i] += 1\n    result = max(dict.items(), key=lambda x: x[1]) \n    return result[0]",
        "code": [
            "from collections import defaultdict\ndef max_occurrences(nums):\n    dict = defaultdict(int)\n    for i in nums:\n        dict[i] += 1\n    result = max(dict.items(), key=lambda x: x[1]) \n    return result[0]"
        ],
        "pseudo": "# Create an empty dictionary to store the frequency count of each item\n# Iterate through each item in the given list\n    # If the item is already in the dictionary, increment its count by 1\n    # If the item is not in the dictionary, add it with count 1\n# Find the item with the maximum frequency by finding the key with the maximum value in the dictionary\n# Return the item with the maximum frequency",
        "test": [
            "assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2",
            "assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8",
            "assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20"
        ],
        "draft_plan": [
            "# Create an empty dictionary to store the frequency count of each item\n# Iterate through each item in the given list\n    # If the item is already in the dictionary, increment its count by 1\n    # If the item is not in the dictionary, add it with count 1\n# Find the item with the maximum frequency by finding the key with the maximum value in the dictionary\n# Return the item with the maximum frequency"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint find_max_frequency(std::vector<int> lst) {\n    std::unordered_map<int, int> frequency_count;\n\n    for (int item : lst) {\n        if (frequency_count.find(item) != frequency_count.end()) {\n            frequency_count[item]++;\n        } else {\n            frequency_count[item] = 1;\n        }\n    }\n\n    int max_frequency = 0;\n    int max_item = 0;\n\n    for (const auto& pair : frequency_count) {\n        if (pair.second > max_frequency) {\n            max_frequency = pair.second;\n            max_item = pair.first;\n        }\n    }\n\n    return max_item;\n}"
        ]
    },
    {
        "id": "131",
        "prompt": "Write a python function to reverse only the vowels of a given string (where y is not a vowel).",
        "solution": "def reverse_vowels(str1):\n\tvowels = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tvowels += char\n\tresult_string = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tresult_string += vowels[-1]\n\t\t\tvowels = vowels[:-1]\n\t\telse:\n\t\t\tresult_string += char\n\treturn result_string",
        "code": [
            "def reverse_vowels(str1):\n\tvowels = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tvowels += char\n\tresult_string = \"\"\n\tfor char in str1:\n\t\tif char in \"aeiouAEIOU\":\n\t\t\tresult_string += vowels[-1]\n\t\t\tvowels = vowels[:-1]\n\t\telse:\n\t\t\tresult_string += char\n\treturn result_string"
        ],
        "pseudo": "# Create a list of vowels (including both lowercase and uppercase)\n# Convert the input string into a list of characters\n\n# Initialize two pointers: one at the start of the string and one at the end\n# Iterate while the pointers don't overlap\n    # Check if the character at the start pointer is a vowel\n        # If it is, then check if the character at the end pointer is also a vowel\n            # If it is, swap the characters at the start and end pointers\n            # Move the start pointer to the next character\n            # Move the end pointer to the previous character\n        # If the character at the end pointer is not a vowel, move the end pointer to the previous character\n    \n# Convert the modified list of characters back into a string and return it",
        "test": [
            "assert reverse_vowels(\"Python\") == \"Python\"",
            "assert reverse_vowels(\"USA\") == \"ASU\"",
            "assert reverse_vowels(\"ab\") == \"ab\""
        ],
        "draft_plan": [
            "# Create a list of vowels (including both lowercase and uppercase)\n# Convert the input string into a list of characters\n\n# Initialize two pointers: one at the start of the string and one at the end\n# Iterate while the pointers don't overlap\n    # Check if the character at the start pointer is a vowel\n        # If it is, then check if the character at the end pointer is also a vowel\n            # If it is, swap the characters at the start and end pointers\n            # Move the start pointer to the next character\n            # Move the end pointer to the previous character\n        # If the character at the end pointer is not a vowel, move the end pointer to the previous character\n    \n# Convert the modified list of characters back into a string and return it"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <string>\n#include <unordered_set>\n\nstd::string reverse_vowels(std::string str) {\n    std::unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    int start = 0;\n    int end = str.size() - 1;\n\n    while (start < end) {\n        if (vowels.count(str[start]) && vowels.count(str[end])) {\n            std::swap(str[start], str[end]);\n            start++;\n            end--;\n        } else if (!vowels.count(str[start])) {\n            start++;\n        } else if (!vowels.count(str[end])) {\n            end--;\n        }\n    }\n\n    return str;\n}\n\nint main() {\n    // Test cases\n    assert(reverse_vowels(\"hello\") == \"holle\");\n    assert(reverse_vowels(\"leetcode\") == \"leotcede\");\n    assert(reverse_vowels(\"AEIOU\") == \"UOIEA\");\n    assert(reverse_vowels(\"xyz\") == \"xyz\");\n\n    std::cout << \"All test cases pass\";\n    return 0;\n}"
        ]
    },
    {
        "id": "132",
        "prompt": "Write a function to convert a tuple to a string.",
        "solution": "def tup_string(tup1):\n  str =  ''.join(tup1)\n  return str",
        "code": [
            "def tup_string(tup1):\n  str =  ''.join(tup1)\n  return str"
        ],
        "pseudo": "# Initialize an empty string\n\n# Iterate through each element in the tuple\n    # Convert the element to a string and append it to the result string\n    # Add a comma after each element except for the last element\n\n# Return the result string",
        "test": [
            "assert tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's'))==(\"exercises\")",
            "assert tup_string(('p','y','t','h','o','n'))==(\"python\")",
            "assert tup_string(('p','r','o','g','r','a','m'))==(\"program\")"
        ],
        "draft_plan": [
            "# Initialize an empty string\n\n# Iterate through each element in the tuple\n    # Convert the element to a string and append it to the result string\n    # Add a comma after each element except for the last element\n\n# Return the result string"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <sstream>\n#include <string>\n#include <tuple>\n\ntemplate <typename... Args>\nstd::string tuple_to_string(const std::tuple<Args...>& tuple) {\n    std::stringstream ss;\n    std::apply([&ss](const auto&... args) {\n        ((ss << args << \",\"), ...);\n    }, tuple);\n    std::string result = ss.str();\n    result = result.substr(0, result.size() - 1); // Remove trailing comma\n    return result;\n}"
        ]
    },
    {
        "id": "133",
        "prompt": "Write a function to calculate the sum of the negative numbers of a given list of numbers.",
        "solution": "def sum_negativenum(nums):\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\n  return sum(sum_negativenum)",
        "code": [
            "def sum_negativenum(nums):\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\n  return sum(sum_negativenum)"
        ],
        "pseudo": "# Initialize the sum of negative numbers to 0\n\n# Iterate through each number in the list\n    # Check if the number is negative\n        # If it is negative, add it to the sum\n\n# Return the sum of negative numbers",
        "test": [
            "assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])==-32",
            "assert sum_negativenum([10,15,-14,13,-18,12,-20])==-52",
            "assert sum_negativenum([19, -65, 57, 39, 152,-639, 121, 44, 90, -190])==-894"
        ],
        "draft_plan": [
            "# Initialize the sum of negative numbers to 0\n\n# Iterate through each number in the list\n    # Check if the number is negative\n        # If it is negative, add it to the sum\n\n# Return the sum of negative numbers"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n\nint sum_of_negative_numbers(const std::vector<int>& numbers) {\n    int sum = 0;\n    \n    for (int num : numbers) {\n        if (num < 0) {\n            sum += num;\n        }\n    }\n    \n    return sum;\n}"
        ]
    },
    {
        "id": "135",
        "prompt": "Write a function to find the nth hexagonal number.",
        "solution": "def hexagonal_num(n): \n\treturn n*(2*n - 1) ",
        "code": [
            "def hexagonal_num(n): \n\treturn n*(2*n - 1) "
        ],
        "pseudo": "# Calculate the nth hexagonal number using the formula: n * (2 * n - 1)\n\n# Return the calculated nth hexagonal number",
        "test": [
            "assert hexagonal_num(10) == 190",
            "assert hexagonal_num(5) == 45",
            "assert hexagonal_num(7) == 91"
        ],
        "draft_plan": [
            "# Calculate the nth hexagonal number using the formula: n * (2 * n - 1)\n\n# Return the calculated nth hexagonal number"
        ],
        "final_plan": [
            "#include <iostream>\n\nlong long find_nth_hexagonal_number(int n) {\n    long long hexagonal_number = n * (2 * n - 1);\n    return hexagonal_number;\n}\n\nint main() {\n    int n;\n    std::cout << \"Enter the value of n: \";\n    std::cin >> n;\n    \n    long long nth_hexagonal = find_nth_hexagonal_number(n);\n    std::cout << \"The nth hexagonal number is: \" << nth_hexagonal << std::endl;\n    \n    return 0;\n}"
        ]
    },
    {
        "id": "137",
        "prompt": "Write a function to find the ratio of zeroes to non-zeroes in an array of integers.",
        "solution": "from array import array\ndef zero_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x == 0:\n            n1 += 1\n        else:\n          None\n    return n1/(n-n1)",
        "code": [
            "from array import array\ndef zero_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x == 0:\n            n1 += 1\n        else:\n          None\n    return n1/(n-n1)"
        ],
        "pseudo": "# Initialize zero_count to 0\n# Initialize non_zero_count to 0\n\n# Iterate through each element in the array\n    # Check if the current element is zero\n        # If it is zero, increment zero_count\n        # If it is not zero, increment non_zero_count\n\n# Calculate the ratio of zeroes to non-zeroes\n# Return the ratio",
        "test": [
            "assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)",
            "assert math.isclose(zero_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.00, rel_tol=0.001)",
            "assert math.isclose(zero_count([2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.00, rel_tol=0.001)"
        ],
        "draft_plan": [
            "# Initialize zero_count to 0\n# Initialize non_zero_count to 0\n\n# Iterate through each element in the array\n    # Check if the current element is zero\n        # If it is zero, increment zero_count\n        # If it is not zero, increment non_zero_count\n\n# Calculate the ratio of zeroes to non-zeroes\n# Return the ratio"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\ndouble find_zero_to_non_zero_ratio(std::vector<int> arr) {\n    int zero_count = 0;\n    int non_zero_count = 0;\n\n    for (int num : arr) {\n        if (num == 0) {\n            zero_count++;\n        } else {\n            non_zero_count++;\n        }\n    }\n\n    if (non_zero_count == 0) {\n        return 0.0;\n    }\n\n    double ratio = static_cast<double>(zero_count) / static_cast<double>(non_zero_count);\n    return ratio;\n}"
        ]
    },
    {
        "id": "138",
        "prompt": "Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.",
        "solution": "def is_Sum_Of_Powers_Of_Two(n): \n    if (n % 2 == 1): \n        return False\n    else: \n        return True",
        "code": [
            "def is_Sum_Of_Powers_Of_Two(n): \n    if (n % 2 == 1): \n        return False\n    else: \n        return True"
        ],
        "pseudo": "# Initialize a variable 'n' with the given number\n\n# Iterate while 'n' is greater than 0\n    # Check if 'n' is divisible by 2\n        # If 'n' is divisible by 2, divide 'n' by 2\n        # Otherwise, subtract the largest power of 2 less than 'n' from 'n'\n\n# If 'n' becomes 0, return True\n# Otherwise, return False",
        "test": [
            "assert is_Sum_Of_Powers_Of_Two(10) == True",
            "assert is_Sum_Of_Powers_Of_Two(7) == False",
            "assert is_Sum_Of_Powers_Of_Two(14) == True"
        ],
        "draft_plan": [
            "# Initialize a variable 'n' with the given number\n\n# Iterate while 'n' is greater than 0\n    # Check if 'n' is divisible by 2\n        # If 'n' is divisible by 2, divide 'n' by 2\n        # Otherwise, subtract the largest power of 2 less than 'n' from 'n'\n\n# If 'n' becomes 0, return True\n# Otherwise, return False"
        ],
        "final_plan": [
            "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool represent_as_power_of_2(int n) {\n    while (n > 0) {\n        if (n % 2 == 0) {\n            n /= 2;\n        } else {\n            int largest_power_of_2 = pow(2, floor(log2(n)));\n            n -= largest_power_of_2;\n        }\n    }\n    return n == 0;\n}"
        ]
    },
    {
        "id": "139",
        "prompt": "Write a function to find the circumference of a circle.",
        "solution": "def circle_circumference(r):\n  perimeter=2*3.1415*r\n  return perimeter",
        "code": [
            "def circle_circumference(r):\n  perimeter=2*3.1415*r\n  return perimeter"
        ],
        "pseudo": "# Define a function that takes the radius of the circle as a parameter\n    # Calculate the circumference of the circle using the formula: circumference = 2 * pi * radius\n    # Return the calculated circumference\n\n# Call the function with the desired radius to find the circumference of the circle",
        "test": [
            "assert math.isclose(circle_circumference(10), 62.830000000000005, rel_tol=0.001)",
            "assert math.isclose(circle_circumference(5), 31.415000000000003, rel_tol=0.001)",
            "assert math.isclose(circle_circumference(4), 25.132, rel_tol=0.001)"
        ],
        "draft_plan": [
            "# Define a function that takes the radius of the circle as a parameter\n    # Calculate the circumference of the circle using the formula: circumference = 2 * pi * radius\n    # Return the calculated circumference\n\n# Call the function with the desired radius to find the circumference of the circle"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <cmath>\n\ndouble calculate_circumference(double radius) {\n    double pi = 3.14159;\n    double circumference = 2 * pi * radius;\n    return circumference;\n}"
        ]
    },
    {
        "id": "140",
        "prompt": "Write a function to flatten the list of lists into a single set of numbers.",
        "solution": "def extract_singly(test_list):\n  res = []\n  temp = set()\n  for inner in test_list:\n    for ele in inner:\n      if not ele in temp:\n        temp.add(ele)\n        res.append(ele)\n  return (res) ",
        "code": [
            "def extract_singly(test_list):\n  res = []\n  temp = set()\n  for inner in test_list:\n    for ele in inner:\n      if not ele in temp:\n        temp.add(ele)\n        res.append(ele)\n  return (res) "
        ],
        "pseudo": "# Create an empty set to store the flattened numbers\n\n# Iterate through each list in the input list of lists\n    # Iterate through each number in the current list\n        # Add the number to the set\n\n# Return the flattened set of numbers",
        "test": [
            "assert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])",
            "assert set(extract_singly([(1, 2, 3), (4, 2, 3), (7, 8)])) == set([1, 2, 3, 4, 7, 8])",
            "assert set(extract_singly([(7, 8, 9), (10, 11, 12), (10, 11)])) == set([7, 8, 9, 10, 11, 12])"
        ],
        "draft_plan": [
            "# Create an empty set to store the flattened numbers\n\n# Iterate through each list in the input list of lists\n    # Iterate through each number in the current list\n        # Add the number to the set\n\n# Return the flattened set of numbers"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::set<int> flatten_list(std::vector<std::vector<int>> input_list) {\n    std::set<int> flattened_set;\n\n    for (const auto& sublist : input_list) {\n        for (const auto& num : sublist) {\n            flattened_set.insert(num);\n        }\n    }\n\n    return flattened_set;\n}"
        ]
    },
    {
        "id": "141",
        "prompt": "Write a function to sort a list of elements.",
        "solution": "def pancake_sort(nums):\n    arr_len = len(nums)\n    while arr_len > 1:\n        mi = nums.index(max(nums[0:arr_len]))\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\n        arr_len -= 1\n    return nums",
        "code": [
            "def pancake_sort(nums):\n    arr_len = len(nums)\n    while arr_len > 1:\n        mi = nums.index(max(nums[0:arr_len]))\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\n        arr_len -= 1\n    return nums"
        ],
        "pseudo": "# Implement a sorting algorithm such as bubble sort, insertion sort, merge sort, quick sort, etc.\n\n# Define a function to take a list of elements as input\n    # Iterate through the list to compare each element with its adjacent element(s)\n        # Swap elements if they are in the wrong order\n    # Repeat the above steps until the list is sorted\n\n# Return the sorted list",
        "test": [
            "assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]",
            "assert pancake_sort([98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98]",
            "assert pancake_sort([41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42]"
        ],
        "draft_plan": [
            "# Implement a sorting algorithm such as bubble sort, insertion sort, merge sort, quick sort, etc.\n\n# Define a function to take a list of elements as input\n    # Iterate through the list to compare each element with its adjacent element(s)\n        # Swap elements if they are in the wrong order\n    # Repeat the above steps until the list is sorted\n\n# Return the sorted list"
        ],
        "final_plan": [
            "Sure! Here's an example implementation of the bubble sort algorithm in C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n\ntemplate<typename T>\nvoid bubbleSort(std::vector<T>& arr) {\n    int n = arr.size();\n    bool swapped;\n\n    for (int i = 0; i < n - 1; i++) {\n        swapped = false;\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                std::swap(arr[j], arr[j + 1]);\n                swapped = true;\n            }\n        }\n        // If no swapping occurred in the inner loop, the array is already sorted\n        if (!swapped) {\n            break;\n        }\n    }\n}\n\nint main() {\n    std::vector<int> arr = {5, 2, 7, 1, 9, 3};\n    bubbleSort(arr);\n\n    std::cout << \"Sorted array: \";\n    for (int num : arr) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```\n\nThis code uses the bubble sort algorithm to sort a vector of integers. It starts by comparing adjacent elements and swapping them if they are in the wrong order. The process is repeated until the entire array is sorted. The sorted array is then printed to the console."
        ]
    },
    {
        "id": "142",
        "prompt": "Write a function to count number items that are identical in the same position of three given lists.",
        "solution": "def count_samepair(list1,list2,list3):\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\n    return result",
        "code": [
            "def count_samepair(list1,list2,list3):\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\n    return result"
        ],
        "pseudo": "# Initialize a counter variable to keep track of the number of identical items\n# Iterate through each index from 0 to the length of any of the given lists\n    # Check if the elements at the current index in all three lists are identical\n        # If they are, increment the counter\n\n# Return the counter variable",
        "test": [
            "assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9])==3",
            "assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==4",
            "assert count_samepair([1,2,3,4,2,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==5"
        ],
        "draft_plan": [
            "# Initialize a counter variable to keep track of the number of identical items\n# Iterate through each index from 0 to the length of any of the given lists\n    # Check if the elements at the current index in all three lists are identical\n        # If they are, increment the counter\n\n# Return the counter variable"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n\nint count_identical_items(std::vector<int>& list1, std::vector<int>& list2, std::vector<int>& list3) {\n    int counter = 0;\n    int n = std::min({list1.size(), list2.size(), list3.size()});\n\n    for (int i = 0; i < n; i++) {\n        if (list1[i] == list2[i] && list2[i] == list3[i]) {\n            counter++;\n        }\n    }\n\n    return counter;\n}"
        ]
    },
    {
        "id": "143",
        "prompt": "Write a function to find number of lists present in the given tuple.",
        "solution": "def find_lists(Input): \n\tif isinstance(Input, list): \n\t\treturn 1\n\telse: \n\t\treturn len(Input) ",
        "code": [
            "def find_lists(Input): \n\tif isinstance(Input, list): \n\t\treturn 1\n\telse: \n\t\treturn len(Input) "
        ],
        "pseudo": "# Initialize a variable to keep track of the count of lists\n# Iterate through each element in the tuple\n    # Check if the current element is a list\n        # If it is a list, increment the count of lists by 1\n\n# Return the count of lists",
        "test": [
            "assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2",
            "assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3",
            "assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1"
        ],
        "draft_plan": [
            "# Initialize a variable to keep track of the count of lists\n# Iterate through each element in the tuple\n    # Check if the current element is a list\n        # If it is a list, increment the count of lists by 1\n\n# Return the count of lists"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint count_lists(std::tuple<> t) {\n    int list_count = 0;\n\n    // Empty tuple has no lists\n    return list_count;\n}\n\ntemplate<typename T, typename... Args>\nint count_lists(std::tuple<T, Args...> t) {\n    int list_count = 0;\n\n    // Check if the current element is a list\n    if (std::is_same<T, std::list<typename std::remove_reference<T>::type>>::value) {\n        list_count++;\n    }\n\n    // Recursively count lists in the remaining elements of the tuple\n    list_count += count_lists(std::tuple<Args...>());\n\n    return list_count;\n}"
        ]
    },
    {
        "id": "145",
        "prompt": "Write a python function to find the maximum difference between any two elements in a given array.",
        "solution": "def max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) ",
        "code": [
            "def max_Abs_Diff(arr): \n    n = len(arr)\n    minEle = arr[0] \n    maxEle = arr[0] \n    for i in range(1, n): \n        minEle = min(minEle,arr[i]) \n        maxEle = max(maxEle,arr[i]) \n    return (maxEle - minEle) "
        ],
        "pseudo": "# If the array is empty, return None\n# Initialize the maximum difference to zero\n\n# Iterate through each element in the array\n    # Iterate through each element after the current element\n        # Calculate the difference between the current element and the subsequent element\n        # Update the maximum difference if the calculated difference is greater than the current maximum difference\n\n# Return the maximum difference",
        "test": [
            "assert max_Abs_Diff((2,1,5,3)) == 4",
            "assert max_Abs_Diff((9,3,2,5,1)) == 8",
            "assert max_Abs_Diff((3,2,1)) == 2"
        ],
        "draft_plan": [
            "# If the array is empty, return None\n# Initialize the maximum difference to zero\n\n# Iterate through each element in the array\n    # Iterate through each element after the current element\n        # Calculate the difference between the current element and the subsequent element\n        # Update the maximum difference if the calculated difference is greater than the current maximum difference\n\n# Return the maximum difference"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\nint maximum_difference(std::vector<int> arr) {\n    if (arr.empty()) {\n        return -1; // If the array is empty, return -1\n    }\n\n    int max_diff = 0;\n\n    for (int i = 0; i < arr.size(); i++) {\n        for (int j = i + 1; j < arr.size(); j++) {\n            int diff = arr[j] - arr[i];\n            if (diff > max_diff) {\n                max_diff = diff;\n            }\n        }\n    }\n\n    return max_diff;\n}"
        ]
    },
    {
        "id": "160",
        "prompt": "Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.",
        "solution": "def find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None",
        "code": [
            "def find_solution(a, b, n):\n\ti = 0\n\twhile i * a <= n:\n\t\tif (n - (i * a)) % b == 0: \n\t\t\treturn (i, (n - (i * a)) // b)\n\t\ti = i + 1\n\treturn None"
        ],
        "pseudo": "# Iterate through all possible values of x from 0 to n\n    # Calculate the value of y using the equation y = (n - ax) / b\n    # Check if y is an integer\n        # If y is an integer, return the values of x and y as a tuple\n\n# If no solution is found, return None",
        "test": [
            "assert find_solution(2, 3, 7) == (2, 1)",
            "assert find_solution(4, 2, 7) == None",
            "assert find_solution(1, 13, 17) == (4, 1)"
        ],
        "draft_plan": [
            "# Iterate through all possible values of x from 0 to n\n    # Calculate the value of y using the equation y = (n - ax) / b\n    # Check if y is an integer\n        # If y is an integer, return the values of x and y as a tuple\n\n# If no solution is found, return None"
        ],
        "final_plan": [
            "#include <iostream>\n#include <tuple>\n\nstd::tuple<int, int> find_solution(int a, int b, int n) {\n    for (int x = 0; x <= n; x++) {\n        int y = (n - a * x) / b;\n        if ((a * x + b * y) == n) {\n            return std::make_tuple(x, y);\n        }\n    }\n    return std::make_tuple(-1, -1);  // Return (-1, -1) if no solution is found\n}\n\nint main() {\n    int a, b, n;\n    std::cout << \"Enter the values of a, b, and n: \";\n    std::cin >> a >> b >> n;\n    \n    std::tuple<int, int> solution = find_solution(a, b, n);\n    int x = std::get<0>(solution);\n    int y = std::get<1>(solution);\n\n    if (x == -1 && y == -1) {\n        std::cout << \"No solution exists.\";\n    } else {\n        std::cout << \"x = \" << x << \", y = \" << y;\n    }\n\n    return 0;\n}"
        ]
    },
    {
        "id": "161",
        "prompt": "Write a function to remove all elements from a given list present in another list.",
        "solution": "def remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result",
        "code": [
            "def remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result"
        ],
        "pseudo": "# Initialize an empty list to store the elements not present in the other list\n\n# Iterate through each element in the given list\n    # Check if the element is not present in the other list\n        # If not present, add it to the new list\n\n# Return the new list",
        "test": [
            "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]",
            "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 3, 5, 7]) == [2, 4, 6, 8, 9, 10]",
            "assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [5, 7]) == [1, 2, 3, 4, 6, 8, 9, 10]"
        ],
        "draft_plan": [
            "# Initialize an empty list to store the elements not present in the other list\n\n# Iterate through each element in the given list\n    # Check if the element is not present in the other list\n        # If not present, add it to the new list\n\n# Return the new list"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n\nstd::vector<int> remove_elements(std::vector<int> given_list, std::vector<int> other_list) {\n    std::vector<int> new_list;\n\n    for (int element : given_list) {\n        if (std::find(other_list.begin(), other_list.end(), element) == other_list.end()) {\n            new_list.push_back(element);\n        }\n    }\n\n    return new_list;\n}"
        ]
    },
    {
        "id": "162",
        "prompt": "Write a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).",
        "solution": "def sum_series(n):\n  if n < 1:\n    return 0\n  else:\n    return n + sum_series(n - 2)",
        "code": [
            "def sum_series(n):\n  if n < 1:\n    return 0\n  else:\n    return n + sum_series(n - 2)"
        ],
        "pseudo": "# Initialize the sum to 0\n\n# Iterate from i = 0 to n // 2 (inclusive)\n    # Calculate the term (n - 2*i)\n    # Add the term to the sum\n\n# Return the sum",
        "test": [
            "assert sum_series(6) == 12",
            "assert sum_series(10) == 30",
            "assert sum_series(9) == 25"
        ],
        "draft_plan": [
            "# Initialize the sum to 0\n\n# Iterate from i = 0 to n // 2 (inclusive)\n    # Calculate the term (n - 2*i)\n    # Add the term to the sum\n\n# Return the sum"
        ],
        "final_plan": [
            "#include <assert.h>\n\nint calculate_sum(int n) {\n    int sum = 0;\n\n    for (int i = 0; i <= n / 2; i++) {\n        int term = n - 2 * i;\n        sum += term;\n    }\n\n    return sum;\n}"
        ]
    },
    {
        "id": "163",
        "prompt": "Write a function to calculate the area of a regular polygon given the length and number of its sides.",
        "solution": "from math import tan, pi\ndef area_polygon(s, l):\n  area = s * (l ** 2) / (4 * tan(pi / s))\n  return area",
        "code": [
            "from math import tan, pi\ndef area_polygon(s, l):\n  area = s * (l ** 2) / (4 * tan(pi / s))\n  return area"
        ],
        "pseudo": "# Import the math module for trigonometric functions\nimport math\n\n# Define a function to calculate the area of a regular polygon\ndef calculate_area(length, sides):\n    # Calculate the apothem (distance from center to midpoint of a side)\n    apothem = length / (2 * math.tan(math.pi / sides))\n    \n    # Calculate the area using the formula: area = (1/2) * apothem * perimeter\n    perimeter = length * sides\n    area = (1 / 2) * apothem * perimeter\n    \n    return area",
        "test": [
            "assert math.isclose(area_polygon(4, 20), 400., rel_tol=0.001)",
            "assert math.isclose(area_polygon(10, 15), 1731.197, rel_tol=0.001)",
            "assert math.isclose(area_polygon(9, 7), 302.909, rel_tol=0.001)"
        ],
        "draft_plan": [
            "# Import the math module for trigonometric functions\nimport math\n\n# Define a function to calculate the area of a regular polygon\ndef calculate_area(length, sides):\n    # Calculate the apothem (distance from center to midpoint of a side)\n    apothem = length / (2 * math.tan(math.pi / sides))\n    \n    # Calculate the area using the formula: area = (1/2) * apothem * perimeter\n    perimeter = length * sides\n    area = (1 / 2) * apothem * perimeter\n    \n    return area"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <cmath>\n\ndouble calculate_area(double length, int sides) {\n    double apothem = length / (2 * std::tan(M_PI / sides));\n    double perimeter = length * sides;\n    double area = (1 / 2.0) * apothem * perimeter;\n    return area;\n}"
        ]
    },
    {
        "id": "164",
        "prompt": "Write a function to determine if the sum of the divisors of two integers are the same.",
        "solution": "import math \ndef div_sum(n): \n  total = 1\n  i = 2\n\n  while i * i <= n:\n    if (n % i == 0):\n      total = (total + i + math.floor(n / i))\n    i += 1\n\n  return total\n\ndef are_equivalent(num1, num2): \n    return div_sum(num1) == div_sum(num2); ",
        "code": [
            "import math \ndef div_sum(n): \n  total = 1\n  i = 2\n\n  while i * i <= n:\n    if (n % i == 0):\n      total = (total + i + math.floor(n / i))\n    i += 1\n\n  return total\n\ndef are_equivalent(num1, num2): \n    return div_sum(num1) == div_sum(num2); "
        ],
        "pseudo": "# Define a function to calculate the sum of divisors for a given number\n    # Initialize the sum to 0\n    # Iterate through each number from 1 to the given number\n        # Check if the current number is a divisor of the given number\n            # If it is, add it to the sum\n\n# Define a function to determine if the sum of divisors for two numbers are the same\n    # Calculate the sum of divisors for both numbers\n    # Check if the sums are equal\n        # If they are, return True\n        # Otherwise, return False",
        "test": [
            "assert are_equivalent(36, 57) == False",
            "assert are_equivalent(2, 4) == False",
            "assert are_equivalent(23, 47) == True"
        ],
        "draft_plan": [
            "# Define a function to calculate the sum of divisors for a given number\n    # Initialize the sum to 0\n    # Iterate through each number from 1 to the given number\n        # Check if the current number is a divisor of the given number\n            # If it is, add it to the sum\n\n# Define a function to determine if the sum of divisors for two numbers are the same\n    # Calculate the sum of divisors for both numbers\n    # Check if the sums are equal\n        # If they are, return True\n        # Otherwise, return False"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint sumOfDivisors(int num) {\n    int sum = 0;\n\n    for (int i = 1; i <= num; i++) {\n        if (num % i == 0) {\n            sum += i;\n        }\n    }\n\n    return sum;\n}\n\nbool sameSumOfDivisors(int num1, int num2) {\n    int sum1 = sumOfDivisors(num1);\n    int sum2 = sumOfDivisors(num2);\n\n    return sum1 == sum2;\n}"
        ]
    },
    {
        "id": "165",
        "prompt": "Write a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).",
        "solution": "def count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars ",
        "code": [
            "def count_char_position(str1): \n    count_chars = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or \n            (i == ord(str1[i]) - ord('a'))): \n            count_chars += 1\n    return count_chars "
        ],
        "pseudo": "# Initialize a variable to keep track of the count of characters at the same position in the English alphabet\n# Iterate through each character in the input string\n    # Convert the character to lowercase\n    # Check if the character is an alphabet character\n        # Get the position of the character in the English alphabet by subtracting the ASCII value of 'a' or 'A'\n        # Check if the position is equal to the index of the character in the string\n            # If the condition is true, increment the count\n\n# Return the count of characters at the same position in the English alphabet",
        "test": [
            "assert count_char_position(\"xbcefg\") == 2",
            "assert count_char_position(\"ABcED\") == 3",
            "assert count_char_position(\"AbgdeF\") == 5"
        ],
        "draft_plan": [
            "# Initialize a variable to keep track of the count of characters at the same position in the English alphabet\n# Iterate through each character in the input string\n    # Convert the character to lowercase\n    # Check if the character is an alphabet character\n        # Get the position of the character in the English alphabet by subtracting the ASCII value of 'a' or 'A'\n        # Check if the position is equal to the index of the character in the string\n            # If the condition is true, increment the count\n\n# Return the count of characters at the same position in the English alphabet"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <string>\n\nint count_same_position_characters(std::string str) {\n    int count = 0;\n\n    for (int i = 0; i < str.length(); i++) {\n        char c = std::tolower(str[i]);\n\n        if (std::isalpha(c)) {\n            int position = c - 'a';\n\n            if (position == i) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}"
        ]
    },
    {
        "id": "166",
        "prompt": "Write a function that counts the number of pairs of integers in a list that xor to an even number.",
        "solution": "def find_even_pair(A): \n  count = 0\n  for i in range(0, len(A)): \n    for j in range(i+1, len(A)): \n        if ((A[i] ^ A[j]) % 2 == 0): \n          count += 1\n\n  return count",
        "code": [
            "def find_even_pair(A): \n  count = 0\n  for i in range(0, len(A)): \n    for j in range(i+1, len(A)): \n        if ((A[i] ^ A[j]) % 2 == 0): \n          count += 1\n\n  return count"
        ],
        "pseudo": "# Initialize a variable to keep track of the count of pairs\n# Iterate through each element in the list\n    # Iterate through each element after the current element\n        # Check if the xor of the current pair is an even number\n            # If it is, increment the count of pairs\n\n# Return the count of pairs",
        "test": [
            "assert find_even_pair([5, 4, 7, 2, 1]) == 4",
            "assert find_even_pair([7, 2, 8, 1, 0, 5, 11]) == 9",
            "assert find_even_pair([1, 2, 3]) == 1"
        ],
        "draft_plan": [
            "# Initialize a variable to keep track of the count of pairs\n# Iterate through each element in the list\n    # Iterate through each element after the current element\n        # Check if the xor of the current pair is an even number\n            # If it is, increment the count of pairs\n\n# Return the count of pairs"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\nusing namespace std;\n\nint count_even_xor_pairs(vector<int> nums) {\n    int count = 0;\n    int n = nums.size();\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if ((nums[i] ^ nums[j]) % 2 == 0) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}"
        ]
    },
    {
        "id": "167",
        "prompt": "Write a python function to find the smallest power of 2 greater than or equal to n.",
        "solution": "def next_power_of_2(n): \n  if n and not n & (n - 1):\n    return n\n\n  count = 0\n  while n != 0: \n    n >>= 1\n    count += 1\n\n  return 1 << count; ",
        "code": [
            "def next_power_of_2(n): \n  if n and not n & (n - 1):\n    return n\n\n  count = 0\n  while n != 0: \n    n >>= 1\n    count += 1\n\n  return 1 << count; "
        ],
        "pseudo": "# Initialize a variable to store the smallest power of 2\n# Check if n is already a power of 2\n    # If it is, return n\n    \n# Iterate through powers of 2 starting from 2\n    # Check if the current power of 2 is greater than or equal to n\n        # If it is, return the current power of 2",
        "test": [
            "assert next_power_of_2(0) == 1",
            "assert next_power_of_2(5) == 8",
            "assert next_power_of_2(17) == 32"
        ],
        "draft_plan": [
            "# Initialize a variable to store the smallest power of 2\n# Check if n is already a power of 2\n    # If it is, return n\n    \n# Iterate through powers of 2 starting from 2\n    # Check if the current power of 2 is greater than or equal to n\n        # If it is, return the current power of 2"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <cmath>\n\nlong smallest_power_of_two(long n) {\n    if ((n & (n - 1)) == 0) {\n        return n;\n    }\n\n    long power = 2;\n    while (power < n) {\n        power *= 2;\n    }\n\n    return power;\n}"
        ]
    },
    {
        "id": "168",
        "prompt": "Write a function to count the number of occurrences of a number in a given list.",
        "solution": "def frequency(a,x): \n    count = 0  \n    for i in a: \n      if i == x: \n        count += 1\n\n    return count ",
        "code": [
            "def frequency(a,x): \n    count = 0  \n    for i in a: \n      if i == x: \n        count += 1\n\n    return count "
        ],
        "pseudo": "# Initialize a count variable to 0\n\n# Iterate through each element in the list\n    # Check if the current element is equal to the given number\n        # If it is, increment the count variable\n\n# Return the count variable",
        "test": [
            "assert frequency([1,2,3], 4) == 0",
            "assert frequency([1,2,2,3,3,3,4], 3) == 3",
            "assert frequency([0,1,2,3,1,2], 1) == 2"
        ],
        "draft_plan": [
            "# Initialize a count variable to 0\n\n# Iterate through each element in the list\n    # Check if the current element is equal to the given number\n        # If it is, increment the count variable\n\n# Return the count variable"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint count_occurrences(std::vector<int> nums, int num) {\n    int count = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] == num) {\n            count++;\n        }\n    }\n    return count;\n}"
        ]
    },
    {
        "id": "170",
        "prompt": "Write a function to find the sum of numbers in a list within a range specified by two indices.",
        "solution": "def sum_range_list(list1, m, n):                                                                                                                                                                                                \n    sum_range = 0                                                                                                                                                                                                         \n    for i in range(m, n+1, 1):                                                                                                                                                                                        \n        sum_range += list1[i]                                                                                                                                                                                                  \n    return sum_range   ",
        "code": [
            "def sum_range_list(list1, m, n):                                                                                                                                                                                                \n    sum_range = 0                                                                                                                                                                                                         \n    for i in range(m, n+1, 1):                                                                                                                                                                                        \n        sum_range += list1[i]                                                                                                                                                                                                  \n    return sum_range   "
        ],
        "pseudo": "# Initialize a variable to store the sum\n\n# Iterate through each number in the list within the given range\n    # Add the current number to the sum\n\n# Return the sum",
        "test": [
            "assert sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 8, 10) == 29",
            "assert sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 5, 7) == 16",
            "assert sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 7, 10) == 38"
        ],
        "draft_plan": [
            "# Initialize a variable to store the sum\n\n# Iterate through each number in the list within the given range\n    # Add the current number to the sum\n\n# Return the sum"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n\nint sum_within_range(std::vector<int>& nums, int start_index, int end_index) {\n    int sum = 0;\n    for (int i = start_index; i <= end_index; i++) {\n        sum += nums[i];\n    }\n    return sum;\n}"
        ]
    },
    {
        "id": "171",
        "prompt": "Write a function to find the perimeter of a regular pentagon from the length of its sides.",
        "solution": "import math\ndef perimeter_pentagon(a):\n  perimeter=(5*a)\n  return perimeter",
        "code": [
            "import math\ndef perimeter_pentagon(a):\n  perimeter=(5*a)\n  return perimeter"
        ],
        "pseudo": "# Calculate the perimeter of a regular pentagon using the formula:\n    # perimeter = 5 * side_length\n\n# Return the calculated perimeter",
        "test": [
            "assert perimeter_pentagon(5) == 25",
            "assert perimeter_pentagon(10) == 50",
            "assert perimeter_pentagon(15) == 75"
        ],
        "draft_plan": [
            "# Calculate the perimeter of a regular pentagon using the formula:\n    # perimeter = 5 * side_length\n\n# Return the calculated perimeter"
        ],
        "final_plan": [
            "#include <assert.h>\n\ndouble calculate_perimeter(double side_length) {\n    double perimeter = 5 * side_length;\n    return perimeter;\n}"
        ]
    },
    {
        "id": "172",
        "prompt": "Write a function to count the number of occurence of the string 'std' in a given string.",
        "solution": "def count_occurance(s):\n  count = 0\n  for i in range(len(s) - 2):\n    if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):\n      count = count + 1\n  return count",
        "code": [
            "def count_occurance(s):\n  count = 0\n  for i in range(len(s) - 2):\n    if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):\n      count = count + 1\n  return count"
        ],
        "pseudo": "# Initialize a count variable to 0\n\n# Iterate through each character and its index in the input string\n    # Check if the current character and the next two characters form the string 'std'\n        # If the condition is satisfied, increment the count variable\n\n# Return the count variable",
        "test": [
            "assert count_occurance(\"letstdlenstdporstd\") == 3",
            "assert count_occurance(\"truststdsolensporsd\") == 1",
            "assert count_occurance(\"makestdsostdworthit\") == 2",
            "assert count_occurance(\"stds\") == 1",
            "assert count_occurance(\"\") == 0"
        ],
        "draft_plan": [
            "# Initialize a count variable to 0\n\n# Iterate through each character and its index in the input string\n    # Check if the current character and the next two characters form the string 'std'\n        # If the condition is satisfied, increment the count variable\n\n# Return the count variable"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint count_occurrences(std::string text) {\n    int count = 0;\n    int n = text.length();\n\n    for (int i = 0; i < n - 2; i++) {\n        if (text[i] == 's' && text[i + 1] == 't' && text[i + 2] == 'd') {\n            count++;\n        }\n    }\n\n    return count;\n}"
        ]
    },
    {
        "id": "222",
        "prompt": "Write a function to check if all the elements in tuple have same data type or not.",
        "solution": "def check_type(test_tuple):\n  res = True\n  for ele in test_tuple:\n    if not isinstance(ele, type(test_tuple[0])):\n      res = False\n      break\n  return (res) ",
        "code": [
            "def check_type(test_tuple):\n  res = True\n  for ele in test_tuple:\n    if not isinstance(ele, type(test_tuple[0])):\n      res = False\n      break\n  return (res) "
        ],
        "pseudo": "# Get the data type of the first element in the tuple\n# Iterate through each element in the tuple starting from the second element\n    # Check if the data type of the current element matches the data type of the first element\n        # If the data types don't match, return False\n\n# If all elements have the same data type, return True\n# Otherwise, return False",
        "test": [
            "assert check_type((5, 6, 7, 3, 5, 6) ) == True",
            "assert check_type((1, 2, \"4\") ) == False",
            "assert check_type((3, 2, 1, 4, 5) ) == True"
        ],
        "draft_plan": [
            "# Get the data type of the first element in the tuple\n# Iterate through each element in the tuple starting from the second element\n    # Check if the data type of the current element matches the data type of the first element\n        # If the data types don't match, return False\n\n# If all elements have the same data type, return True\n# Otherwise, return False"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\ntemplate<typename T, typename... Args>\nbool all_same_type(const std::tuple<T, Args...>&) {\n    return (std::is_same<T, Args>::value && ...);\n}"
        ]
    },
    {
        "id": "223",
        "prompt": "Write a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)",
        "solution": "def is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1",
        "code": [
            "def is_majority(arr, n, x):\n\ti = binary_search(arr, 0, n-1, x)\n\tif i == -1:\n\t\treturn False\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\n\t\treturn True\n\telse:\n\t\treturn False\ndef binary_search(arr, low, high, x):\n\tif high >= low:\n\t\tmid = (low + high)//2 \n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\n\t\t\treturn mid\n\t\telif x > arr[mid]:\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\n\t\telse:\n\t\t\treturn binary_search(arr, low, (mid -1), x)\n\treturn -1"
        ],
        "pseudo": "# Find the index of the middle element in the array\n# If the middle element is equal to the given element and its index plus n/2 is less than or equal to the length of the array\n    # Check if the element at index (middle index + n/2) is also equal to the given element\n        # If both conditions are true, return True\n# Otherwise, return False",
        "test": [
            "assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True",
            "assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False",
            "assert is_majority([1, 1, 1, 2, 2], 5, 1) == True",
            "assert is_majority([1, 1, 2, 2], 5, 1) == False"
        ],
        "draft_plan": [
            "# Find the index of the middle element in the array\n# If the middle element is equal to the given element and its index plus n/2 is less than or equal to the length of the array\n    # Check if the element at index (middle index + n/2) is also equal to the given element\n        # If both conditions are true, return True\n# Otherwise, return False"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nbool is_majority_element(int arr[], int n, int element) {\n    int middle = n / 2;\n\n    if (arr[middle] == element && middle + n / 2 < n) {\n        if (arr[middle + n / 2] == element) {\n            return true;\n        }\n    }\n\n    return false;\n}"
        ]
    },
    {
        "id": "224",
        "prompt": "Write a python function to count the number of set bits (binary digits with value 1) in a given number.",
        "solution": "def count_Set_Bits(n): \n    count = 0\n    while (n): \n        count += n & 1\n        n >>= 1\n    return count ",
        "code": [
            "def count_Set_Bits(n): \n    count = 0\n    while (n): \n        count += n & 1\n        n >>= 1\n    return count "
        ],
        "pseudo": "# Initialize a counter variable to 0\n\n# Iterate through each bit in the binary representation of the number\n    # Check if the current bit is set (equal to 1)\n        # If yes, increment the counter variable\n\n# Return the counter variable, which represents the number of set bits",
        "test": [
            "assert count_Set_Bits(2) == 1",
            "assert count_Set_Bits(4) == 1",
            "assert count_Set_Bits(6) == 2"
        ],
        "draft_plan": [
            "# Initialize a counter variable to 0\n\n# Iterate through each bit in the binary representation of the number\n    # Check if the current bit is set (equal to 1)\n        # If yes, increment the counter variable\n\n# Return the counter variable, which represents the number of set bits"
        ],
        "final_plan": [
            "#include <assert.h>\n\nint count_set_bits(int num) {\n    int count = 0;\n\n    while (num > 0) {\n        if (num & 1) {\n            count++;\n        }\n        num >>= 1;\n    }\n\n    return count;\n}"
        ]
    },
    {
        "id": "226",
        "prompt": "Write a python function to remove the characters which have odd index values of a given string.",
        "solution": "def odd_values_string(str):\n  result = \"\" \n  for i in range(len(str)):\n    if i % 2 == 0:\n      result = result + str[i]\n  return result",
        "code": [
            "def odd_values_string(str):\n  result = \"\" \n  for i in range(len(str)):\n    if i % 2 == 0:\n      result = result + str[i]\n  return result"
        ],
        "pseudo": "# Initialize an empty string to store the result\n\n# Iterate through each character and its index in the input string\n    # Check if the index of the current character is even\n        # If it is even, append the character to the result string\n\n# Return the result string",
        "test": [
            "assert odd_values_string('abcdef') == 'ace'",
            "assert odd_values_string('python') == 'pto'",
            "assert odd_values_string('data') == 'dt'",
            "assert odd_values_string('lambs') == 'lms'"
        ],
        "draft_plan": [
            "# Initialize an empty string to store the result\n\n# Iterate through each character and its index in the input string\n    # Check if the index of the current character is even\n        # If it is even, append the character to the result string\n\n# Return the result string"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::string remove_odd_index_chars(const std::string& input_string) {\n    std::string result;\n    \n    for (int i = 0; i < input_string.length(); i++) {\n        if (i % 2 == 0) {\n            result += input_string[i];\n        }\n    }\n    \n    return result;\n}"
        ]
    },
    {
        "id": "227",
        "prompt": "Write a function to find minimum of three numbers.",
        "solution": "def min_of_three(a,b,c): \n      if (a <= b) and (a <= c): \n        smallest = a \n      elif (b <= a) and (b <= c): \n        smallest = b \n      else: \n        smallest = c \n      return smallest ",
        "code": [
            "def min_of_three(a,b,c): \n      if (a <= b) and (a <= c): \n        smallest = a \n      elif (b <= a) and (b <= c): \n        smallest = b \n      else: \n        smallest = c \n      return smallest "
        ],
        "pseudo": "# Compare the first two numbers and assign the minimum to a variable min_num\n\n# Compare the minimum of the first two numbers with the third number\n    # If the third number is smaller, assign it to min_num\n\n# Return min_num",
        "test": [
            "assert min_of_three(10,20,0)==0",
            "assert min_of_three(19,15,18)==15",
            "assert min_of_three(-10,-20,-30)==-30"
        ],
        "draft_plan": [
            "# Compare the first two numbers and assign the minimum to a variable min_num\n\n# Compare the minimum of the first two numbers with the third number\n    # If the third number is smaller, assign it to min_num\n\n# Return min_num"
        ],
        "final_plan": [
            "#include <assert.h>\n\nint find_minimum(int num1, int num2, int num3) {\n    int min_num = num1;\n  \n    if (num2 < min_num) {\n        min_num = num2;\n    }\n  \n    if (num3 < min_num) {\n        min_num = num3;\n    }\n  \n    return min_num;\n}"
        ]
    },
    {
        "id": "228",
        "prompt": "Write a python function to check whether all the bits are unset in the given range or not.",
        "solution": "def all_Bits_Set_In_The_Given_Range(n,l,r):  \n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \n    new_num = n & num\n    if (new_num == 0): \n        return True\n    return False",
        "code": [
            "def all_Bits_Set_In_The_Given_Range(n,l,r):  \n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \n    new_num = n & num\n    if (new_num == 0): \n        return True\n    return False"
        ],
        "pseudo": "# Convert the range into binary representation\n# Iterate through each bit in the binary representation\n    # Check if any bit is set (1)\n        # If any bit is set, return False\n\n# If all bits are unset (0), return True",
        "test": [
            "assert all_Bits_Set_In_The_Given_Range(4,1,2) == True",
            "assert all_Bits_Set_In_The_Given_Range(17,2,4) == True",
            "assert all_Bits_Set_In_The_Given_Range(39,4,6) == False"
        ],
        "draft_plan": [
            "# Convert the range into binary representation\n# Iterate through each bit in the binary representation\n    # Check if any bit is set (1)\n        # If any bit is set, return False\n\n# If all bits are unset (0), return True"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bitset>\n\nbool all_bits_unset(int start, int end) {\n    std::bitset<32> range(start ^ end);\n    return range.none();\n}"
        ]
    },
    {
        "id": "229",
        "prompt": "Write a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.",
        "solution": "def re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr",
        "code": [
            "def re_arrange_array(arr, n):\n  j=0\n  for i in range(0, n):\n    if (arr[i] < 0):\n      temp = arr[i]\n      arr[i] = arr[j]\n      arr[j] = temp\n      j = j + 1\n  return arr"
        ],
        "pseudo": "# Create two empty lists, one for negative elements and one for positive elements\n\n# Iterate through the first n elements of the array\n    # Check if the element is negative\n        # If it is, append it to the negative elements list\n    # Otherwise, append it to the positive elements list\n\n# Concatenate the negative elements list with the positive elements list\n# Return the resulting list",
        "test": [
            "assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]",
            "assert re_arrange_array([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]",
            "assert re_arrange_array([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]"
        ],
        "draft_plan": [
            "# Create two empty lists, one for negative elements and one for positive elements\n\n# Iterate through the first n elements of the array\n    # Check if the element is negative\n        # If it is, append it to the negative elements list\n    # Otherwise, append it to the positive elements list\n\n# Concatenate the negative elements list with the positive elements list\n# Return the resulting list"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\nstd::vector<int> rearrange_array(std::vector<int> arr, int n) {\n    std::vector<int> negative_elements;\n    std::vector<int> positive_elements;\n\n    for (int i = 0; i < n; i++) {\n        if (arr[i] < 0) {\n            negative_elements.push_back(arr[i]);\n        } else {\n            positive_elements.push_back(arr[i]);\n        }\n    }\n\n    negative_elements.insert(negative_elements.end(), positive_elements.begin(), positive_elements.end());\n    return negative_elements;\n}"
        ]
    },
    {
        "id": "230",
        "prompt": "Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.",
        "solution": "def replace_blank(str1,char):\n str2 = str1.replace(' ', char)\n return str2",
        "code": [
            "def replace_blank(str1,char):\n str2 = str1.replace(' ', char)\n return str2"
        ],
        "pseudo": "# Define a function that takes in a string and a character as arguments\n    # Convert the string into a list of characters\n    # Iterate through each character in the list\n        # Check if the character is a blank space\n            # If it is, replace it with the given character\n    # Join the list of characters back into a string\n    # Return the modified string\n\n# Example usage:\n# string = \"Hello World\"\n# character = \"-\"\n# modified_string = replace_spaces(string, character)\n# print(modified_string) --> \"Hello-World\"",
        "test": [
            "assert replace_blank(\"hello people\",'@')==(\"hello@people\")",
            "assert replace_blank(\"python program language\",'$')==(\"python$program$language\")",
            "assert replace_blank(\"blank space\",\"-\")==(\"blank-space\")"
        ],
        "draft_plan": [
            "# Define a function that takes in a string and a character as arguments\n    # Convert the string into a list of characters\n    # Iterate through each character in the list\n        # Check if the character is a blank space\n            # If it is, replace it with the given character\n    # Join the list of characters back into a string\n    # Return the modified string\n\n# Example usage:\n# string = \"Hello World\"\n# character = \"-\"\n# modified_string = replace_spaces(string, character)\n# print(modified_string) --> \"Hello-World\""
        ],
        "final_plan": [
            "#include <iostream>\n#include <string>\n\nstd::string replace_spaces(const std::string& input_string, char replace_char) {\n    std::string modified_string = input_string;\n\n    for (char& character : modified_string) {\n        if (character == ' ') {\n            character = replace_char;\n        }\n    }\n\n    return modified_string;\n}"
        ]
    },
    {
        "id": "232",
        "prompt": "Write a function that takes in a list and an integer n and returns a list containing the n largest items from the list.",
        "solution": "import heapq\ndef larg_nnum(list1,n):\n largest=heapq.nlargest(n,list1)\n return largest",
        "code": [
            "import heapq\ndef larg_nnum(list1,n):\n largest=heapq.nlargest(n,list1)\n return largest"
        ],
        "pseudo": "# Sort the list in descending order\n# Return the first n items from the sorted list",
        "test": [
            "assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2))==set([100,90])",
            "assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],5))==set([100,90,80,70,60])",
            "assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],3))==set([100,90,80])"
        ],
        "draft_plan": [
            "# Sort the list in descending order\n# Return the first n items from the sorted list"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<int> find_n_largest(std::vector<int> lst, int n) {\n    std::sort(lst.begin(), lst.end(), std::greater<int>());\n    return std::vector<int>(lst.begin(), lst.begin() + n);\n}"
        ]
    },
    {
        "id": "233",
        "prompt": "Write a function to find the lateral surface area of a cylinder.",
        "solution": "def lateralsuface_cylinder(r,h):\n  lateralsurface= 2*3.1415*r*h\n  return lateralsurface",
        "code": [
            "def lateralsuface_cylinder(r,h):\n  lateralsurface= 2*3.1415*r*h\n  return lateralsurface"
        ],
        "pseudo": "# Define a function to calculate the lateral surface area of a cylinder\n    # Accept the radius and height of the cylinder as arguments\n\n    # Calculate the lateral surface area using the formula: 2 * \u03c0 * radius * height\n\n    # Return the calculated lateral surface area\n\n# Call the function with the desired radius and height values and print the result",
        "test": [
            "assert math.isclose(lateralsuface_cylinder(10,5), 314.15000000000003, rel_tol=0.001)",
            "assert math.isclose(lateralsuface_cylinder(4,5), 125.66000000000001, rel_tol=0.001)",
            "assert math.isclose(lateralsuface_cylinder(4,10), 251.32000000000002, rel_tol=0.001)"
        ],
        "draft_plan": [
            "# Define a function to calculate the lateral surface area of a cylinder\n    # Accept the radius and height of the cylinder as arguments\n\n    # Calculate the lateral surface area using the formula: 2 * \u03c0 * radius * height\n\n    # Return the calculated lateral surface area\n\n# Call the function with the desired radius and height values and print the result"
        ],
        "final_plan": [
            "#include <iostream>\n\ndouble calculate_lateral_surface_area(double radius, double height) {\n    double pi = 3.14159;\n    double lateral_surface_area = 2 * pi * radius * height;\n    return lateral_surface_area;\n}\n\nint main() {\n    double radius = 5.0;\n    double height = 10.0;\n    \n    double surface_area = calculate_lateral_surface_area(radius, height);\n    \n    std::cout << \"Lateral Surface Area of the Cylinder: \" << surface_area << std::endl;\n    \n    return 0;\n}"
        ]
    },
    {
        "id": "234",
        "prompt": "Write a function to find the volume of a cube given its side length.",
        "solution": "def volume_cube(l):\n  volume = l * l * l\n  return volume",
        "code": [
            "def volume_cube(l):\n  volume = l * l * l\n  return volume"
        ],
        "pseudo": "# Define a function to calculate the volume of a cube\n    # Accept a parameter for the side length of the cube\n    # Calculate the volume using the formula V = side_length^3\n    # Return the calculated volume",
        "test": [
            "assert volume_cube(3)==27",
            "assert volume_cube(2)==8",
            "assert volume_cube(5)==125"
        ],
        "draft_plan": [
            "# Define a function to calculate the volume of a cube\n    # Accept a parameter for the side length of the cube\n    # Calculate the volume using the formula V = side_length^3\n    # Return the calculated volume"
        ],
        "final_plan": [
            "#include <assert.h>\n\ndouble calculate_cube_volume(double side_length) {\n    double volume = side_length * side_length * side_length;\n    return volume;\n}"
        ]
    },
    {
        "id": "235",
        "prompt": "Write a python function to set all even bits of a given number.",
        "solution": "def even_bit_set_number(n): \n    count = 0;res = 0;temp = n \n    while(temp > 0): \n        if (count % 2 == 1): \n            res |= (1 << count)\n        count+=1\n        temp >>= 1\n    return (n | res) ",
        "code": [
            "def even_bit_set_number(n): \n    count = 0;res = 0;temp = n \n    while(temp > 0): \n        if (count % 2 == 1): \n            res |= (1 << count)\n        count+=1\n        temp >>= 1\n    return (n | res) "
        ],
        "pseudo": "# Create a mask with all even bits set to 1 and odd bits set to 0\n# Perform bitwise OR operation between the given number and the mask\n# Return the updated number",
        "test": [
            "assert even_bit_set_number(10) == 10",
            "assert even_bit_set_number(20) == 30",
            "assert even_bit_set_number(30) == 30"
        ],
        "draft_plan": [
            "# Create a mask with all even bits set to 1 and odd bits set to 0\n# Perform bitwise OR operation between the given number and the mask\n# Return the updated number"
        ],
        "final_plan": [
            "#include <assert.h>\n\nunsigned int set_even_bits(unsigned int num) {\n    unsigned int mask = 0xAAAAAAAA; // Mask with all even bits set to 1 and odd bits set to 0\n    return num | mask;\n}"
        ]
    },
    {
        "id": "237",
        "prompt": "Write a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.",
        "solution": "from collections import Counter \ndef check_occurences(test_list):\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\n  return  (res) ",
        "code": [
            "from collections import Counter \ndef check_occurences(test_list):\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\n  return  (res) "
        ],
        "pseudo": "# Initialize an empty dictionary\n\n# Iterate through each tuple in the list\n    # Check if the current tuple is already a key in the dictionary\n        # If it is, increment the count by 1\n        # If it is not, add the tuple as a key with a count of 1\n\n# Return the dictionary",
        "test": [
            "assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)] ) == {(1, 3): 2, (2, 5): 2, (3, 6): 1}",
            "assert check_occurences([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)] ) == {(2, 4): 2, (3, 6): 2, (4, 7): 1}",
            "assert check_occurences([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)] ) == {(2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1}"
        ],
        "draft_plan": [
            "# Initialize an empty dictionary\n\n# Iterate through each tuple in the list\n    # Check if the current tuple is already a key in the dictionary\n        # If it is, increment the count by 1\n        # If it is not, add the tuple as a key with a count of 1\n\n# Return the dictionary"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <unordered_map>\n#include <vector>\n#include <tuple>\n\nstd::unordered_map<std::tuple<int, int, int>, int> count_tuples(std::vector<std::tuple<int, int, int>> tuple_list) {\n    std::unordered_map<std::tuple<int, int, int>, int> tuple_count;\n\n    for (const auto& tuple : tuple_list) {\n        if (tuple_count.count(tuple) > 0) {\n            tuple_count[tuple]++;\n        } else {\n            tuple_count[tuple] = 1;\n        }\n    }\n\n    return tuple_count;\n}"
        ]
    },
    {
        "id": "238",
        "prompt": "Write a python function to count the number of non-empty substrings of a given string.",
        "solution": "def number_of_substrings(str): \n\tstr_len = len(str); \n\treturn int(str_len * (str_len + 1) / 2); ",
        "code": [
            "def number_of_substrings(str): \n\tstr_len = len(str); \n\treturn int(str_len * (str_len + 1) / 2); "
        ],
        "pseudo": "# Initialize a counter variable to 0\n\n# Iterate through each character and its index in the input string\n    # Iterate through each substring starting from the current character\n        # Increment the counter variable by 1 for each non-empty substring\n\n# Return the counter variable",
        "test": [
            "assert number_of_substrings(\"abc\") == 6",
            "assert number_of_substrings(\"abcd\") == 10",
            "assert number_of_substrings(\"abcde\") == 15"
        ],
        "draft_plan": [
            "# Initialize a counter variable to 0\n\n# Iterate through each character and its index in the input string\n    # Iterate through each substring starting from the current character\n        # Increment the counter variable by 1 for each non-empty substring\n\n# Return the counter variable"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint count_substrings(std::string str) {\n    int count = 0;\n\n    for (int i = 0; i < str.length(); i++) {\n        for (int j = i; j < str.length(); j++) {\n            std::string substr = str.substr(i, j - i + 1);\n            if (!substr.empty()) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}"
        ]
    },
    {
        "id": "239",
        "prompt": "Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.",
        "solution": "def get_total_number_of_sequences(m,n): \n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \n\tfor i in range(m+1): \n\t\tfor j in range(n+1): \n\t\t\tif i==0 or j==0: \n\t\t\t\tT[i][j]=0\n\t\t\telif i<j: \n\t\t\t\tT[i][j]=0\n\t\t\telif j==1: \n\t\t\t\tT[i][j]=i \n\t\t\telse: \n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \n\treturn T[m][n]",
        "code": [
            "def get_total_number_of_sequences(m,n): \n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \n\tfor i in range(m+1): \n\t\tfor j in range(n+1): \n\t\t\tif i==0 or j==0: \n\t\t\t\tT[i][j]=0\n\t\t\telif i<j: \n\t\t\t\tT[i][j]=0\n\t\t\telif j==1: \n\t\t\t\tT[i][j]=i \n\t\t\telse: \n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \n\treturn T[m][n]"
        ],
        "pseudo": "# Initialize a variable count to keep track of the number of possible sequences\n\n# Create a recursive function to find the number of possible sequences\n    # Base case: if n is equal to 0, return 1 (as we have found a valid sequence)\n    \n    # Initialize a variable total_count to keep track of the total number of sequences\n    \n    # Iterate through all possible values for the current element in the sequence\n        # Check if the current element is greater than or equal to twice the previous element and less than or equal to m\n            # If it is, recursively call the function with n-1 and update the total_count by adding the result\n            \n    # Return the total_count\n    \n# Call the recursive function with the given values of m and n and store the result in the variable count\n\n# Return the value of count as the final result",
        "test": [
            "assert get_total_number_of_sequences(10, 4) == 4",
            "assert get_total_number_of_sequences(5, 2) == 6",
            "assert get_total_number_of_sequences(16, 3) == 84"
        ],
        "draft_plan": [
            "# Initialize a variable count to keep track of the number of possible sequences\n\n# Create a recursive function to find the number of possible sequences\n    # Base case: if n is equal to 0, return 1 (as we have found a valid sequence)\n    \n    # Initialize a variable total_count to keep track of the total number of sequences\n    \n    # Iterate through all possible values for the current element in the sequence\n        # Check if the current element is greater than or equal to twice the previous element and less than or equal to m\n            # If it is, recursively call the function with n-1 and update the total_count by adding the result\n            \n    # Return the total_count\n    \n# Call the recursive function with the given values of m and n and store the result in the variable count\n\n# Return the value of count as the final result"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n\nint count_sequences(int m, int n) {\n    if (n == 0) {\n        return 1;\n    }\n\n    int total_count = 0;\n\n    for (int i = 1; i <= m; i++) {\n        if (i >= 2 && i <= m) {\n            total_count += count_sequences(m, n - 1);\n        }\n    }\n\n    return total_count;\n}\n\nint main() {\n    int m = 3;\n    int n = 4;\n\n    int count = count_sequences(m, n);\n    std::cout << count << std::endl;\n\n    return 0;\n}"
        ]
    },
    {
        "id": "240",
        "prompt": "Write a function that takes in two lists and replaces the last element of the first list with the elements of the second list.",
        "solution": "def replace_list(list1,list2):\n list1[-1:] = list2\n replace_list=list1\n return replace_list\n",
        "code": [
            "def replace_list(list1,list2):\n list1[-1:] = list2\n replace_list=list1\n return replace_list\n"
        ],
        "pseudo": "# Define a function that takes two lists as input\ndef replace_last_element(list1, list2):\n    # Replace the last element of list1 with the elements of list2\n    list1[-1:] = list2\n    # Return the modified list1\n    return list1",
        "test": [
            "assert replace_list([1, 3, 5, 7, 9, 10],[2, 4, 6, 8])==[1, 3, 5, 7, 9, 2, 4, 6, 8]",
            "assert replace_list([1,2,3,4,5],[5,6,7,8])==[1,2,3,4,5,6,7,8]",
            "assert replace_list([\"red\",\"blue\",\"green\"],[\"yellow\"])==[\"red\",\"blue\",\"yellow\"]"
        ],
        "draft_plan": [
            "# Define a function that takes two lists as input\ndef replace_last_element(list1, list2):\n    # Replace the last element of list1 with the elements of list2\n    list1[-1:] = list2\n    # Return the modified list1\n    return list1"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n\nstd::vector<int> replace_last_element(std::vector<int> list1, std::vector<int> list2) {\n    if (!list1.empty()) {\n        list1.pop_back();\n        list1.insert(list1.end(), list2.begin(), list2.end());\n    }\n    return list1;\n}"
        ]
    },
    {
        "id": "242",
        "prompt": "Write a function to count the total number of characters in a string.",
        "solution": "def count_charac(str1):\n total = 0\n for i in str1:\n    total = total + 1\n return total",
        "code": [
            "def count_charac(str1):\n total = 0\n for i in str1:\n    total = total + 1\n return total"
        ],
        "pseudo": "# Initialize a variable to keep track of the character count, set it to 0\n\n# Iterate through each character in the string\n    # Increment the character count by 1\n\n# Return the character count",
        "test": [
            "assert count_charac(\"python programming\")==18",
            "assert count_charac(\"language\")==8",
            "assert count_charac(\"words\")==5"
        ],
        "draft_plan": [
            "# Initialize a variable to keep track of the character count, set it to 0\n\n# Iterate through each character in the string\n    # Increment the character count by 1\n\n# Return the character count"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint count_characters(std::string str) {\n    int count = 0;\n\n    for (char ch : str) {\n        count++;\n    }\n\n    return count;\n}"
        ]
    },
    {
        "id": "244",
        "prompt": "Write a python function to find the next perfect square greater than a given number.",
        "solution": "import math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN ",
        "code": [
            "import math  \ndef next_Perfect_Square(N): \n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN "
        ],
        "pseudo": "# Calculate the square root of the given number using math.sqrt() function\n\n# Increment the square root by 1\n\n# Calculate the next perfect square by squaring the incremented square root\n\n# Return the next perfect square",
        "test": [
            "assert next_Perfect_Square(35) == 36",
            "assert next_Perfect_Square(6) == 9",
            "assert next_Perfect_Square(9) == 16"
        ],
        "draft_plan": [
            "# Calculate the square root of the given number using math.sqrt() function\n\n# Increment the square root by 1\n\n# Calculate the next perfect square by squaring the incremented square root\n\n# Return the next perfect square"
        ],
        "final_plan": [
            "#include <iostream>\n#include <cmath>\n\nlong long next_perfect_square(long long number) {\n    double square_root = sqrt(number);\n    long long next_square_root = ceil(square_root);\n    long long next_perfect_square = next_square_root * next_square_root;\n    return next_perfect_square;\n}"
        ]
    },
    {
        "id": "245",
        "prompt": "Write a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, where a sequence is bitonic if it is first increasing and then decreasing.",
        "solution": "def max_sum(arr): \n\tMSIBS = arr[:] \n\tfor i in range(len(arr)): \n\t\tfor j in range(0, i): \n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \n\tMSDBS = arr[:] \n\tfor i in range(1, len(arr) + 1): \n\t\tfor j in range(1, i): \n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \n\tmax_sum = float(\"-Inf\") \n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \n\t\tmax_sum = max(max_sum, i + j - k) \n\treturn max_sum",
        "code": [
            "def max_sum(arr): \n\tMSIBS = arr[:] \n\tfor i in range(len(arr)): \n\t\tfor j in range(0, i): \n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \n\tMSDBS = arr[:] \n\tfor i in range(1, len(arr) + 1): \n\t\tfor j in range(1, i): \n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \n\tmax_sum = float(\"-Inf\") \n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \n\t\tmax_sum = max(max_sum, i + j - k) \n\treturn max_sum"
        ],
        "pseudo": "# Initialize two arrays of the same length as the input array, one to store the maximum increasing subsequence sum ending at each index, and the other to store the maximum decreasing subsequence sum starting at each index\n\n# Iterate through each index in the input array\n    # Find the maximum increasing subsequence sum ending at the current index by comparing it with all previous indices\n    # Find the maximum decreasing subsequence sum starting at the current index by comparing it with all next indices\n\n# Find the maximum bitonic subsequence sum by adding the maximum increasing subsequence sum and the maximum decreasing subsequence sum for each index, and subtracting the value of the current index from the sum\n\n# Return the maximum bitonic subsequence sum",
        "test": [
            "assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194",
            "assert max_sum([80, 60, 30, 40, 20, 10]) == 210",
            "assert max_sum([2, 3 ,14, 16, 21, 23, 29, 30]) == 138"
        ],
        "draft_plan": [
            "# Initialize two arrays of the same length as the input array, one to store the maximum increasing subsequence sum ending at each index, and the other to store the maximum decreasing subsequence sum starting at each index\n\n# Iterate through each index in the input array\n    # Find the maximum increasing subsequence sum ending at the current index by comparing it with all previous indices\n    # Find the maximum decreasing subsequence sum starting at the current index by comparing it with all next indices\n\n# Find the maximum bitonic subsequence sum by adding the maximum increasing subsequence sum and the maximum decreasing subsequence sum for each index, and subtracting the value of the current index from the sum\n\n# Return the maximum bitonic subsequence sum"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n#include <assert.h>\n\nint max_bitonic_sum(std::vector<int> arr) {\n    int n = arr.size();\n\n    std::vector<int> increasing_sum(n, 0);\n    std::vector<int> decreasing_sum(n, 0);\n\n    // Calculate maximum increasing subsequence sum ending at each index\n    for (int i = 0; i < n; i++) {\n        increasing_sum[i] = arr[i];\n        for (int j = 0; j < i; j++) {\n            if (arr[j] < arr[i]) {\n                increasing_sum[i] = std::max(increasing_sum[i], increasing_sum[j] + arr[i]);\n            }\n        }\n    }\n\n    // Calculate maximum decreasing subsequence sum starting at each index\n    for (int i = n - 1; i >= 0; i--) {\n        decreasing_sum[i] = arr[i];\n        for (int j = n - 1; j > i; j--) {\n            if (arr[j] < arr[i]) {\n                decreasing_sum[i] = std::max(decreasing_sum[i], decreasing_sum[j] + arr[i]);\n            }\n        }\n    }\n\n    // Find the maximum bitonic subsequence sum\n    int max_bitonic_sum = 0;\n    for (int i = 0; i < n; i++) {\n        max_bitonic_sum = std::max(max_bitonic_sum, increasing_sum[i] + decreasing_sum[i] - arr[i]);\n    }\n\n    return max_bitonic_sum;\n}"
        ]
    },
    {
        "id": "246",
        "prompt": "Write a function for computing square roots using the babylonian method.",
        "solution": "def babylonian_squareroot(number):\n    if(number == 0):\n        return 0;\n    g = number/2.0;\n    g2 = g + 1;\n    while(g != g2):\n        n = number/ g;\n        g2 = g;\n        g = (g + n)/2;\n    return g;",
        "code": [
            "def babylonian_squareroot(number):\n    if(number == 0):\n        return 0;\n    g = number/2.0;\n    g2 = g + 1;\n    while(g != g2):\n        n = number/ g;\n        g2 = g;\n        g = (g + n)/2;\n    return g;"
        ],
        "pseudo": "# Define a function to compute square root using Babylonian method\n    # Check if the input number is less than 0, if so return None\n    \n    # Initialize the guess value as the input number divided by 2\n    \n    # Iterate until the difference between the guess value and the previous guess value is less than a small threshold\n        # Compute the new guess value as the average of the previous guess value and the input number divided by the previous guess value\n        \n    # Return the final guess value as the square root\n\n# Test the function by calling it with some example inputs",
        "test": [
            "assert math.isclose(babylonian_squareroot(10), 3.162277660168379, rel_tol=0.001)",
            "assert math.isclose(babylonian_squareroot(2), 1.414213562373095, rel_tol=0.001)",
            "assert math.isclose(babylonian_squareroot(9), 3.0, rel_tol=0.001)"
        ],
        "draft_plan": [
            "# Define a function to compute square root using Babylonian method\n    # Check if the input number is less than 0, if so return None\n    \n    # Initialize the guess value as the input number divided by 2\n    \n    # Iterate until the difference between the guess value and the previous guess value is less than a small threshold\n        # Compute the new guess value as the average of the previous guess value and the input number divided by the previous guess value\n        \n    # Return the final guess value as the square root\n\n# Test the function by calling it with some example inputs"
        ],
        "final_plan": [
            "#include <cmath>\n\ndouble compute_square_root(double number) {\n    if (number < 0) {\n        return -1; // Return -1 to indicate that the input number is invalid\n    }\n    \n    double guess = number / 2;\n    double prev_guess = 0;\n    \n    while (fabs(guess - prev_guess) > 1e-6) {\n        prev_guess = guess;\n        guess = (guess + number / guess) / 2;\n    }\n    \n    return guess;\n}"
        ]
    },
    {
        "id": "247",
        "prompt": "Write a function to find the length of the longest palindromic subsequence in the given string.",
        "solution": "def lps(str): \n\tn = len(str) \n\tL = [[0 for x in range(n)] for x in range(n)] \n\tfor i in range(n): \n\t\tL[i][i] = 1\n\tfor cl in range(2, n+1): \n\t\tfor i in range(n-cl+1): \n\t\t\tj = i+cl-1\n\t\t\tif str[i] == str[j] and cl == 2: \n\t\t\t\tL[i][j] = 2\n\t\t\telif str[i] == str[j]: \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\n\t\t\telse: \n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\treturn L[0][n-1]",
        "code": [
            "def lps(str): \n\tn = len(str) \n\tL = [[0 for x in range(n)] for x in range(n)] \n\tfor i in range(n): \n\t\tL[i][i] = 1\n\tfor cl in range(2, n+1): \n\t\tfor i in range(n-cl+1): \n\t\t\tj = i+cl-1\n\t\t\tif str[i] == str[j] and cl == 2: \n\t\t\t\tL[i][j] = 2\n\t\t\telif str[i] == str[j]: \n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\n\t\t\telse: \n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \n\treturn L[0][n-1]"
        ],
        "pseudo": "# Create a 2D array of size n x n, where n is the length of the input string\n# Fill the diagonal with 1, as each character is a palindrome of length 1\n\n# Iterate through the remaining elements of the array in a bottom-up manner\n    # If the characters at the current indices match\n        # Set the value of the current cell as 2 plus the value in the cell diagonally below and to the right (i+1, j+1)\n    # Otherwise, set the value of the current cell as the maximum of the value in the cell to the left (i, j-1) and the value in the cell below (i+1, j)\n\n# Return the value in the top-right cell of the array, which represents the length of the longest palindromic subsequence",
        "test": [
            "assert lps(\"TENS FOR TENS\") == 5",
            "assert lps(\"CARDIO FOR CARDS\") == 7",
            "assert lps(\"PART OF THE JOURNEY IS PART\") == 9"
        ],
        "draft_plan": [
            "# Create a 2D array of size n x n, where n is the length of the input string\n# Fill the diagonal with 1, as each character is a palindrome of length 1\n\n# Iterate through the remaining elements of the array in a bottom-up manner\n    # If the characters at the current indices match\n        # Set the value of the current cell as 2 plus the value in the cell diagonally below and to the right (i+1, j+1)\n    # Otherwise, set the value of the current cell as the maximum of the value in the cell to the left (i, j-1) and the value in the cell below (i+1, j)\n\n# Return the value in the top-right cell of the array, which represents the length of the longest palindromic subsequence"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint longest_palindromic_subsequence(std::string str) {\n    int n = str.length();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n, 0));\n\n    // Fill diagonal with 1\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n\n    // Bottom-up iteration\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n\n            if (str[i] == str[j]) {\n                dp[i][j] = 2 + dp[i+1][j-1];\n            } else {\n                dp[i][j] = std::max(dp[i][j-1], dp[i+1][j]);\n            }\n        }\n    }\n\n    return dp[0][n-1];\n}"
        ]
    },
    {
        "id": "248",
        "prompt": "Write a function that takes in an integer n and calculates the harmonic sum of n-1.",
        "solution": "def harmonic_sum(n):\n  if n < 2:\n    return 1\n  else:\n    return 1 / n + (harmonic_sum(n - 1)) ",
        "code": [
            "def harmonic_sum(n):\n  if n < 2:\n    return 1\n  else:\n    return 1 / n + (harmonic_sum(n - 1)) "
        ],
        "pseudo": "# Initialize the sum to 0\n\n# Iterate from i = 1 to n-1\n    # Add 1/i to the sum\n\n# Return the sum",
        "test": [
            "assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)",
            "assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)",
            "assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)"
        ],
        "draft_plan": [
            "# Initialize the sum to 0\n\n# Iterate from i = 1 to n-1\n    # Add 1/i to the sum\n\n# Return the sum"
        ],
        "final_plan": [
            "#include <iostream>\n\ndouble harmonic_sum(int n) {\n    double sum = 0.0;\n\n    for (int i = 1; i < n; i++) {\n        sum += 1.0 / i;\n    }\n\n    return sum;\n}"
        ]
    },
    {
        "id": "249",
        "prompt": "Write a function to find the intersection of two arrays.",
        "solution": "def intersection_array(array_nums1,array_nums2):\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \n return result",
        "code": [
            "def intersection_array(array_nums1,array_nums2):\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \n return result"
        ],
        "pseudo": "# Initialize an empty result array\n\n# Iterate through each element in the first array\n    # Check if the current element is present in the second array\n        # If it is present, append it to the result array\n\n# Return the result array",
        "test": [
            "assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[1, 2, 4, 8, 9])==[1, 2, 8, 9]",
            "assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[3,5,7,9])==[3,5,7,9]",
            "assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[10,20,30,40])==[10]"
        ],
        "draft_plan": [
            "# Initialize an empty result array\n\n# Iterate through each element in the first array\n    # Check if the current element is present in the second array\n        # If it is present, append it to the result array\n\n# Return the result array"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <unordered_set>\n#include <vector>\n\nstd::vector<int> find_intersection(const std::vector<int>& nums1, const std::vector<int>& nums2) {\n    std::unordered_set<int> set(nums1.begin(), nums1.end());\n    std::vector<int> intersection;\n\n    for (const auto& num : nums2) {\n        if (set.count(num)) {\n            intersection.push_back(num);\n        }\n    }\n\n    return intersection;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 2, 2, 1};\n    std::vector<int> nums2 = {2, 2};\n    std::vector<int> result = find_intersection(nums1, nums2);\n\n    std::cout << \"Intersection: \";\n    for (const auto& num : result) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}"
        ]
    },
    {
        "id": "250",
        "prompt": "Write a python function that takes in a tuple and an element and counts the occcurences of the element in the tuple.",
        "solution": "def count_X(tup, x): \n    count = 0\n    for ele in tup: \n        if (ele == x): \n            count = count + 1\n    return count ",
        "code": [
            "def count_X(tup, x): \n    count = 0\n    for ele in tup: \n        if (ele == x): \n            count = count + 1\n    return count "
        ],
        "pseudo": "# Initialize a counter variable to 0\n\n# Iterate through each element in the tuple\n    # Check if the current element is equal to the target element\n        # If it is, increment the counter by 1\n\n# Return the value of the counter variable",
        "test": [
            "assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),4) == 0",
            "assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),10) == 3",
            "assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),8) == 4"
        ],
        "draft_plan": [
            "# Initialize a counter variable to 0\n\n# Iterate through each element in the tuple\n    # Check if the current element is equal to the target element\n        # If it is, increment the counter by 1\n\n# Return the value of the counter variable"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint count_occurrences(std::tuple<int, int, int, int> t, int target) {\n    int count = 0;\n\n    if (std::get<0>(t) == target) {\n        count++;\n    }\n\n    if (std::get<1>(t) == target) {\n        count++;\n    }\n\n    if (std::get<2>(t) == target) {\n        count++;\n    }\n\n    if (std::get<3>(t) == target) {\n        count++;\n    }\n\n    return count;\n}"
        ]
    },
    {
        "id": "251",
        "prompt": "Write a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.",
        "solution": "def insert_element(list,element):\n list = [v for elt in list for v in (element, elt)]\n return list",
        "code": [
            "def insert_element(list,element):\n list = [v for elt in list for v in (element, elt)]\n return list"
        ],
        "pseudo": "# Initialize an empty list to store the modified elements\n# Iterate through each element in the original list\n    # Add the given element to the modified list\n    # Add the current element from the original list to the modified list\n\n# Return the modified list",
        "test": [
            "assert insert_element(['Red', 'Green', 'Black'] ,'c')==['c', 'Red', 'c', 'Green', 'c', 'Black']",
            "assert insert_element(['python', 'java'] ,'program')==['program', 'python', 'program', 'java']",
            "assert insert_element(['happy', 'sad'] ,'laugh')==['laugh', 'happy', 'laugh', 'sad']"
        ],
        "draft_plan": [
            "# Initialize an empty list to store the modified elements\n# Iterate through each element in the original list\n    # Add the given element to the modified list\n    # Add the current element from the original list to the modified list\n\n# Return the modified list"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <vector>\n\nstd::vector<int> insert_element_before_each(std::vector<int> lst, int element) {\n    std::vector<int> modified_lst;\n\n    for (int i = 0; i < lst.size(); i++) {\n        modified_lst.push_back(element);\n        modified_lst.push_back(lst[i]);\n    }\n\n    return modified_lst;\n}"
        ]
    },
    {
        "id": "252",
        "prompt": "Write a python function to convert complex numbers to polar coordinates.",
        "solution": "import cmath  \ndef convert(numbers):    \n  num = cmath.polar(numbers)  \n  return (num) ",
        "code": [
            "import cmath  \ndef convert(numbers):    \n  num = cmath.polar(numbers)  \n  return (num) "
        ],
        "pseudo": "# Import the cmath module to work with complex numbers\n\n# Define a function to convert complex numbers to polar coordinates\n    # Use the cmath.polar() method to convert the complex number to polar coordinates\n\n# Call the function with the complex number as the input",
        "test": [
            "assert convert(1) == (1.0, 0.0)",
            "assert convert(4) == (4.0,0.0)",
            "assert convert(5) == (5.0,0.0)"
        ],
        "draft_plan": [
            "# Import the cmath module to work with complex numbers\n\n# Define a function to convert complex numbers to polar coordinates\n    # Use the cmath.polar() method to convert the complex number to polar coordinates\n\n# Call the function with the complex number as the input"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::pair<double, double> convert_to_polar(double real, double imag) {\n    std::complex<double> complex_num(real, imag);\n    std::pair<double, double> polar = std::make_pair(std::abs(complex_num), std::arg(complex_num));\n    return polar;\n}"
        ]
    },
    {
        "id": "253",
        "prompt": "Write a python function that returns the number of integer elements in a given list.",
        "solution": "def count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr",
        "code": [
            "def count_integer(list1):\n    ctr = 0\n    for i in list1:\n        if isinstance(i, int):\n            ctr = ctr + 1\n    return ctr"
        ],
        "pseudo": "# Initialize a counter variable to 0\n\n# Iterate through each element in the given list\n    # Check if the current element is an integer\n        # If it is an integer, increment the counter variable\n\n# Return the counter variable as the number of integer elements in the list",
        "test": [
            "assert count_integer([1,2,'abc',1.2]) == 2",
            "assert count_integer([1,2,3]) == 3",
            "assert count_integer([1,1.2,4,5.1]) == 2"
        ],
        "draft_plan": [
            "# Initialize a counter variable to 0\n\n# Iterate through each element in the given list\n    # Check if the current element is an integer\n        # If it is an integer, increment the counter variable\n\n# Return the counter variable as the number of integer elements in the list"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <vector>\n\nint count_integer_elements(std::vector<int> test_list) {\n    int count = 0;\n\n    for (int element : test_list) {\n        if (std::is_integral(element)) {\n            count++;\n        }\n    }\n\n    return count;\n}"
        ]
    },
    {
        "id": "255",
        "prompt": "Write a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a tuple for each combination.",
        "solution": "from itertools import combinations_with_replacement \ndef combinations_colors(l, n):\n    return list(combinations_with_replacement(l,n))\n",
        "code": [
            "from itertools import combinations_with_replacement \ndef combinations_colors(l, n):\n    return list(combinations_with_replacement(l,n))\n"
        ],
        "pseudo": "import itertools\n\ndef generate_combinations(lst, n):\n    # Use itertools.combinations_with_replacement to generate all combinations of length n\n    combinations = list(itertools.combinations_with_replacement(lst, n))\n    \n    # Convert the combinations to a list of tuples\n    result = [tuple(comb) for comb in combinations]\n    \n    return result",
        "test": [
            "assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],1)==[('Red',), ('Green',), ('Blue',)]",
            "assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],2)==[('Red', 'Red'), ('Red', 'Green'), ('Red', 'Blue'), ('Green', 'Green'), ('Green', 'Blue'), ('Blue', 'Blue')]",
            "assert combinations_colors( [\"Red\",\"Green\",\"Blue\"],3)==[('Red', 'Red', 'Red'), ('Red', 'Red', 'Green'), ('Red', 'Red', 'Blue'), ('Red', 'Green', 'Green'), ('Red', 'Green', 'Blue'), ('Red', 'Blue', 'Blue'), ('Green', 'Green', 'Green'), ('Green', 'Green', 'Blue'), ('Green', 'Blue', 'Blue'), ('Blue', 'Blue', 'Blue')]"
        ],
        "draft_plan": [
            "import itertools\n\ndef generate_combinations(lst, n):\n    # Use itertools.combinations_with_replacement to generate all combinations of length n\n    combinations = list(itertools.combinations_with_replacement(lst, n))\n    \n    # Convert the combinations to a list of tuples\n    result = [tuple(comb) for comb in combinations]\n    \n    return result"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<std::vector<int>> generate_combinations(std::vector<int> lst, int n) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> combination(n, 0);\n\n    generate_combinations_helper(lst, n, 0, combination, result);\n\n    return result;\n}\n\nvoid generate_combinations_helper(std::vector<int> lst, int n, int index, std::vector<int>& combination, std::vector<std::vector<int>>& result) {\n    if (index == n) {\n        result.push_back(combination);\n        return;\n    }\n\n    for (int i = 0; i < lst.size(); i++) {\n        combination[index] = lst[i];\n        generate_combinations_helper(lst, n, index + 1, combination, result);\n    }\n}"
        ]
    },
    {
        "id": "256",
        "prompt": "Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.",
        "solution": "def count_Primes_nums(n):\n    ctr = 0\n    for num in range(n):\n        if num <= 1:\n            continue\n        for i in range(2,num):\n            if (num % i) == 0:\n                break\n        else:\n            ctr += 1\n    return ctr",
        "code": [
            "def count_Primes_nums(n):\n    ctr = 0\n    for num in range(n):\n        if num <= 1:\n            continue\n        for i in range(2,num):\n            if (num % i) == 0:\n                break\n        else:\n            ctr += 1\n    return ctr"
        ],
        "pseudo": "# Define a function to check if a number is prime\n    # Check if the number is less than 2, return False\n    # Iterate from 2 to the square root of the number\n        # Check if the number is divisible by any number in the range\n            # If divisible, return False\n    # If the number is not divisible by any number in the range, return True\n\n# Define a function to count the number of primes less than a given number\n    # Initialize a count variable to 0\n    # Iterate from 2 to the given number\n        # Check if the current number is prime\n            # If prime, increment the count\n    # Return the count",
        "test": [
            "assert count_Primes_nums(5) == 2",
            "assert count_Primes_nums(10) == 4",
            "assert count_Primes_nums(100) == 25"
        ],
        "draft_plan": [
            "# Define a function to check if a number is prime\n    # Check if the number is less than 2, return False\n    # Iterate from 2 to the square root of the number\n        # Check if the number is divisible by any number in the range\n            # If divisible, return False\n    # If the number is not divisible by any number in the range, return True\n\n# Define a function to count the number of primes less than a given number\n    # Initialize a count variable to 0\n    # Iterate from 2 to the given number\n        # Check if the current number is prime\n            # If prime, increment the count\n    # Return the count"
        ],
        "final_plan": [
            "#include <iostream>\n#include <cmath>\n\nbool is_prime(int number) {\n    if (number < 2) {\n        return false;\n    }\n\n    for (int i = 2; i <= std::sqrt(number); i++) {\n        if (number % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint count_primes(int n) {\n    int count = 0;\n\n    for (int i = 2; i < n; i++) {\n        if (is_prime(i)) {\n            count++;\n        }\n    }\n\n    return count;\n}"
        ]
    },
    {
        "id": "257",
        "prompt": "Write a function that takes in two numbers and returns a tuple with the second number and then the first number.",
        "solution": "def swap_numbers(a,b):\n temp = a\n a = b\n b = temp\n return (a,b)",
        "code": [
            "def swap_numbers(a,b):\n temp = a\n a = b\n b = temp\n return (a,b)"
        ],
        "pseudo": "# Define the function that takes in two numbers as input\n    # Create a tuple with the second number followed by the first number\n    # Return the tuple\n\n# Call the function with the desired numbers and store the returned tuple",
        "test": [
            "assert swap_numbers(10,20)==(20,10)",
            "assert swap_numbers(15,17)==(17,15)",
            "assert swap_numbers(100,200)==(200,100)"
        ],
        "draft_plan": [
            "# Define the function that takes in two numbers as input\n    # Create a tuple with the second number followed by the first number\n    # Return the tuple\n\n# Call the function with the desired numbers and store the returned tuple"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n\nstd::tuple<int, int> swap_numbers(int num1, int num2) {\n    return std::make_tuple(num2, num1);\n}\n\nint main() {\n    int num1 = 5;\n    int num2 = 10;\n\n    std::tuple<int, int> result = swap_numbers(num1, num2);\n\n    std::cout << \"Swapped Numbers: \" << std::get<0>(result) << \", \" << std::get<1>(result) << std::endl;\n\n    return 0;\n}"
        ]
    },
    {
        "id": "259",
        "prompt": "Write a function to maximize the given two tuples.",
        "solution": "def maximize_elements(test_tup1, test_tup2):\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ",
        "code": [
            "def maximize_elements(test_tup1, test_tup2):\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) "
        ],
        "pseudo": "# Initialize a new tuple to store the maximum values\n\n# Iterate through each element in the tuples\n    # Compare the corresponding elements of both tuples\n    # Add the maximum value to the new tuple\n\n# Return the new tuple containing the maximum values",
        "test": [
            "assert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))",
            "assert maximize_elements(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((7, 8), (5, 10), (3, 10), (8, 11))",
            "assert maximize_elements(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((8, 9), (6, 11), (4, 11), (9, 12))"
        ],
        "draft_plan": [
            "# Initialize a new tuple to store the maximum values\n\n# Iterate through each element in the tuples\n    # Compare the corresponding elements of both tuples\n    # Add the maximum value to the new tuple\n\n# Return the new tuple containing the maximum values"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::tuple<int, int, int> maximize_tuples(std::tuple<int, int, int> tuple1, std::tuple<int, int, int> tuple2) {\n    std::tuple<int, int, int> max_tuple;\n\n    std::get<0>(max_tuple) = std::max(std::get<0>(tuple1), std::get<0>(tuple2));\n    std::get<1>(max_tuple) = std::max(std::get<1>(tuple1), std::get<1>(tuple2));\n    std::get<2>(max_tuple) = std::max(std::get<2>(tuple1), std::get<2>(tuple2));\n\n    return max_tuple;\n}"
        ]
    },
    {
        "id": "260",
        "prompt": "Write a function to find the nth newman\u2013shanks\u2013williams prime number.",
        "solution": "def newman_prime(n): \n\tif n == 0 or n == 1: \n\t\treturn 1\n\treturn 2 * newman_prime(n - 1) + newman_prime(n - 2)",
        "code": [
            "def newman_prime(n): \n\tif n == 0 or n == 1: \n\t\treturn 1\n\treturn 2 * newman_prime(n - 1) + newman_prime(n - 2)"
        ],
        "pseudo": "# Check if the given number n is less than or equal to 2\n    # If true, return the nth newman\u2013shanks\u2013williams prime number directly\n\n# Initialize a list to store the prime numbers\n# Add the first two newman\u2013shanks\u2013williams prime numbers (2 and 3) to the list\n\n# Start the iteration from 4\n# While the length of the list is less than n\n    # Check if the current number is prime\n        # If true, add it to the list\n\n    # Increment the current number by 1\n\n# Return the nth newman\u2013shanks\u2013williams prime number from the list",
        "test": [
            "assert newman_prime(3) == 7",
            "assert newman_prime(4) == 17",
            "assert newman_prime(5) == 41"
        ],
        "draft_plan": [
            "# Check if the given number n is less than or equal to 2\n    # If true, return the nth newman\u2013shanks\u2013williams prime number directly\n\n# Initialize a list to store the prime numbers\n# Add the first two newman\u2013shanks\u2013williams prime numbers (2 and 3) to the list\n\n# Start the iteration from 4\n# While the length of the list is less than n\n    # Check if the current number is prime\n        # If true, add it to the list\n\n    # Increment the current number by 1\n\n# Return the nth newman\u2013shanks\u2013williams prime number from the list"
        ],
        "final_plan": [
            "#include <cassert>\n#include <cmath>\n#include <vector>\n\nbool is_prime(int num) {\n    if (num < 2) {\n        return false;\n    }\n\n    int sqrt_num = sqrt(num);\n    for (int i = 2; i <= sqrt_num; i++) {\n        if (num % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint nth_newman_shanks_williams_prime(int n) {\n    if (n <= 2) {\n        return n == 1 ? 2 : 3;\n    }\n\n    std::vector<int> primes = {2, 3};\n    int current_num = 4;\n    while (primes.size() < n) {\n        if (is_prime(current_num)) {\n            primes.push_back(current_num);\n        }\n\n        current_num++;\n    }\n\n    return primes[n - 1];\n}"
        ]
    },
    {
        "id": "261",
        "prompt": "Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.",
        "solution": "def division_elements(test_tup1, test_tup2):\n  res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) ",
        "code": [
            "def division_elements(test_tup1, test_tup2):\n  res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) "
        ],
        "pseudo": "# Create an empty list to store the result of the division operation\n\n# Iterate through the elements of the tuples\n    # Perform the division operation on the corresponding elements of the tuples\n    # Append the result to the result list\n\n# Return the result list",
        "test": [
            "assert division_elements((10, 4, 6, 9),(5, 2, 3, 3)) == (2, 2, 2, 3)",
            "assert division_elements((12, 6, 8, 16),(6, 3, 4, 4)) == (2, 2, 2, 4)",
            "assert division_elements((20, 14, 36, 18),(5, 7, 6, 9)) == (4, 2, 6, 2)"
        ],
        "draft_plan": [
            "# Create an empty list to store the result of the division operation\n\n# Iterate through the elements of the tuples\n    # Perform the division operation on the corresponding elements of the tuples\n    # Append the result to the result list\n\n# Return the result list"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<double> divide_tuples(std::tuple<double, double> tuple1, std::tuple<double, double> tuple2) {\n    std::vector<double> result;\n\n    double a1 = std::get<0>(tuple1);\n    double b1 = std::get<1>(tuple1);\n    double a2 = std::get<0>(tuple2);\n    double b2 = std::get<1>(tuple2);\n\n    double result_a = a1 / a2;\n    double result_b = b1 / b2;\n\n    result.push_back(result_a);\n    result.push_back(result_b);\n\n    return result;\n}"
        ]
    },
    {
        "id": "262",
        "prompt": "Write a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.",
        "solution": "def split_two_parts(list1, L):\n    return list1[:L], list1[L:]",
        "code": [
            "def split_two_parts(list1, L):\n    return list1[:L], list1[L:]"
        ],
        "pseudo": "# Check if the given list has enough elements to split into two parts\n    # If not, return the original list as the first part and an empty list as the second part\n\n# Split the list into two parts at index L\n    # First part is from index 0 to index L-1\n    # Second part is from index L to the end of the list\n\n# Return the resulting lists as a tuple",
        "test": [
            "assert split_two_parts([1,1,2,3,4,4,5,1],3)==([1, 1, 2], [3, 4, 4, 5, 1])",
            "assert split_two_parts(['a', 'b', 'c', 'd'],2)==(['a', 'b'], ['c', 'd'])",
            "assert split_two_parts(['p', 'y', 't', 'h', 'o', 'n'],4)==(['p', 'y', 't', 'h'], ['o', 'n'])"
        ],
        "draft_plan": [
            "# Check if the given list has enough elements to split into two parts\n    # If not, return the original list as the first part and an empty list as the second part\n\n# Split the list into two parts at index L\n    # First part is from index 0 to index L-1\n    # Second part is from index L to the end of the list\n\n# Return the resulting lists as a tuple"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::tuple<std::vector<int>, std::vector<int>> split_list(std::vector<int> lst, int L) {\n    if (L > lst.size()) {\n        return std::make_tuple(lst, std::vector<int>());\n    }\n\n    std::vector<int> first_part(lst.begin(), lst.begin() + L);\n    std::vector<int> second_part(lst.begin() + L, lst.end());\n\n    return std::make_tuple(first_part, second_part);\n}"
        ]
    },
    {
        "id": "264",
        "prompt": "Write a function to calculate a dog's age in dog's years.",
        "solution": "def dog_age(h_age):\n if h_age < 0:\n \texit()\n elif h_age <= 2:\n\t d_age = h_age * 10.5\n else:\n\t d_age = 21 + (h_age - 2)*4\n return d_age",
        "code": [
            "def dog_age(h_age):\n if h_age < 0:\n \texit()\n elif h_age <= 2:\n\t d_age = h_age * 10.5\n else:\n\t d_age = 21 + (h_age - 2)*4\n return d_age"
        ],
        "pseudo": "# Define a function called calculate_dog_age that takes in one parameter: human_age\n\n# Define a variable called dog_age and set it to 0\n\n# If human_age is less than or equal to 2, set dog_age to human_age multiplied by 10.5\n# If human_age is greater than 2, calculate the dog's age in dog's years by adding:\n    # 2 (for the first two years) multiplied by 10.5\n    # The remaining years multiplied by 4\n\n# Return the value of dog_age as the result of the function",
        "test": [
            "assert dog_age(12)==61",
            "assert dog_age(15)==73",
            "assert dog_age(24)==109"
        ],
        "draft_plan": [
            "# Define a function called calculate_dog_age that takes in one parameter: human_age\n\n# Define a variable called dog_age and set it to 0\n\n# If human_age is less than or equal to 2, set dog_age to human_age multiplied by 10.5\n# If human_age is greater than 2, calculate the dog's age in dog's years by adding:\n    # 2 (for the first two years) multiplied by 10.5\n    # The remaining years multiplied by 4\n\n# Return the value of dog_age as the result of the function"
        ],
        "final_plan": [
            "#include <assert.h>\n\nint calculate_dog_age(int human_age) {\n    int dog_age = 0;\n  \n    if (human_age <= 2) {\n        dog_age = human_age * 10.5;\n    } else {\n        dog_age = 21 + ((human_age - 2) * 4);\n    }\n\n    return dog_age;\n}"
        ]
    },
    {
        "id": "265",
        "prompt": "Write a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.",
        "solution": "def list_split(S, step):\n    return [S[i::step] for i in range(step)]",
        "code": [
            "def list_split(S, step):\n    return [S[i::step] for i in range(step)]"
        ],
        "pseudo": "# Create an empty list to store the resulting lists\n\n# Iterate through the range from 0 to the length of the input list with step size n\n    # Append a sublist that starts from the current index and ends at the current index + n to the resulting list\n\n# Return the resulting list",
        "test": [
            "assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'],3)==[['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]",
            "assert list_split([1,2,3,4,5,6,7,8,9,10,11,12,13,14],3)==[[1,4,7,10,13], [2,5,8,11,14], [3,6,9,12]]",
            "assert list_split(['python','java','C','C++','DBMS','SQL'],2)==[['python', 'C', 'DBMS'], ['java', 'C++', 'SQL']]"
        ],
        "draft_plan": [
            "# Create an empty list to store the resulting lists\n\n# Iterate through the range from 0 to the length of the input list with step size n\n    # Append a sublist that starts from the current index and ends at the current index + n to the resulting list\n\n# Return the resulting list"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\nstd::vector<std::vector<int>> split_list(std::vector<int> lst, int n) {\n    std::vector<std::vector<int>> result;\n    for (int i = 0; i < lst.size(); i += n) {\n        std::vector<int> sub_lst(lst.begin() + i, lst.begin() + i + n);\n        result.push_back(sub_lst);\n    }\n    return result;\n}\n\nint main() {\n    std::vector<int> lst = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int n = 3;\n    std::vector<std::vector<int>> result = split_list(lst, n);\n\n    for (const auto& sub_lst : result) {\n        for (const auto& num : sub_lst) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}"
        ]
    },
    {
        "id": "266",
        "prompt": "Write a function to find the lateral surface area of a cube given its side length.",
        "solution": "def lateralsurface_cube(l):\n  LSA = 4 * (l * l)\n  return LSA",
        "code": [
            "def lateralsurface_cube(l):\n  LSA = 4 * (l * l)\n  return LSA"
        ],
        "pseudo": "# Calculate the lateral surface area of a cube\n    # Lateral surface area of a cube is given by 4 times the square of the side length\n    # Return the calculated lateral surface area",
        "test": [
            "assert lateralsurface_cube(5)==100",
            "assert lateralsurface_cube(9)==324",
            "assert lateralsurface_cube(10)==400"
        ],
        "draft_plan": [
            "# Calculate the lateral surface area of a cube\n    # Lateral surface area of a cube is given by 4 times the square of the side length\n    # Return the calculated lateral surface area"
        ],
        "final_plan": [
            "#include <assert.h>\n\ndouble calculate_lateral_surface_area(double side_length) {\n    double lateral_surface_area = 4 * side_length * side_length;\n    return lateral_surface_area;\n}"
        ]
    },
    {
        "id": "267",
        "prompt": "Write a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.",
        "solution": "def square_Sum(n):  \n    return int(n*(4*n*n-1)/3) ",
        "code": [
            "def square_Sum(n):  \n    return int(n*(4*n*n-1)/3) "
        ],
        "pseudo": "# Initialize a variable to store the sum of squares\n# Initialize a counter variable to keep track of the odd numbers\n# Initialize a variable to store the current odd number\n\n# Iterate from 1 to n (inclusive)\n    # Check if the current number is odd\n        # If it is, square the number and add it to the sum of squares\n        # Increase the counter variable by 1\n        # Check if the counter variable is equal to n\n            # If it is, break the loop\n\n# Return the sum of squares",
        "test": [
            "assert square_Sum(2) == 10",
            "assert square_Sum(3) == 35",
            "assert square_Sum(4) == 84"
        ],
        "draft_plan": [
            "# Initialize a variable to store the sum of squares\n# Initialize a counter variable to keep track of the odd numbers\n# Initialize a variable to store the current odd number\n\n# Iterate from 1 to n (inclusive)\n    # Check if the current number is odd\n        # If it is, square the number and add it to the sum of squares\n        # Increase the counter variable by 1\n        # Check if the counter variable is equal to n\n            # If it is, break the loop\n\n# Return the sum of squares"
        ],
        "final_plan": [
            "#include <assert.h>\n\nint sum_of_squares_of_odds(int n) {\n    int sum = 0;\n    int counter = 0;\n    int current_odd = 1;\n\n    for (int i = 1; i <= n; i++) {\n        if (current_odd % 2 == 1) {\n            sum += current_odd * current_odd;\n            counter++;\n        }\n        current_odd += 2;\n\n        if (counter == n) {\n            break;\n        }\n    }\n\n    return sum;\n}"
        ]
    },
    {
        "id": "268",
        "prompt": "Write a function to find the n'th star number.",
        "solution": "def find_star_num(n): \n\treturn (6 * n * (n - 1) + 1) ",
        "code": [
            "def find_star_num(n): \n\treturn (6 * n * (n - 1) + 1) "
        ],
        "pseudo": "# The nth star number can be calculated using the formula: n * (n + 1) / 2\n\n# Define a function to find the nth star number\n    # Calculate the star number using the formula\n    # Return the star number",
        "test": [
            "assert find_star_num(3) == 37",
            "assert find_star_num(4) == 73",
            "assert find_star_num(5) == 121"
        ],
        "draft_plan": [
            "# The nth star number can be calculated using the formula: n * (n + 1) / 2\n\n# Define a function to find the nth star number\n    # Calculate the star number using the formula\n    # Return the star number"
        ],
        "final_plan": [
            "#include <assert.h>\n\nint find_nth_star_number(int n) {\n    return n * (n + 1) / 2;\n}"
        ]
    },
    {
        "id": "269",
        "prompt": "Write a function to find the ascii value of a character.",
        "solution": "def ascii_value(k):\n  ch=k\n  return ord(ch)",
        "code": [
            "def ascii_value(k):\n  ch=k\n  return ord(ch)"
        ],
        "pseudo": "To find the ASCII value of a character in Python, you can use the `ord()` function. Here is the code logic:\n\n1. Define a function `find_ascii_value(char)` that takes a character as input.\n2. Inside the function, use the `ord()` function to find the ASCII value of the character.\n3. Return the ASCII value.\n\nHere is the code:\n\n```python\ndef find_ascii_value(char):\n    return ord(char)\n```\n\nYou can then call this function and pass the character whose ASCII value you want to find, like this:\n\n```python\nprint(find_ascii_value('A')) # Output: 65\n```\n\nNote that the `ord()` function only works with single characters. If you pass a string with multiple characters, it will raise a `TypeError`.",
        "test": [
            "assert ascii_value('A')==65",
            "assert ascii_value('R')==82",
            "assert ascii_value('S')==83"
        ],
        "draft_plan": [
            "To find the ASCII value of a character in Python, you can use the `ord()` function. Here is the code logic:\n\n1. Define a function `find_ascii_value(char)` that takes a character as input.\n2. Inside the function, use the `ord()` function to find the ASCII value of the character.\n3. Return the ASCII value.\n\nHere is the code:\n\n```python\ndef find_ascii_value(char):\n    return ord(char)\n```\n\nYou can then call this function and pass the character whose ASCII value you want to find, like this:\n\n```python\nprint(find_ascii_value('A')) # Output: 65\n```\n\nNote that the `ord()` function only works with single characters. If you pass a string with multiple characters, it will raise a `TypeError`."
        ],
        "final_plan": [
            "To find the ASCII value of a character in C++, you can simply cast the character to an integer type. Here is the code logic:\n\n1. Define a function `find_ascii_value(char)` that takes a character as input.\n2. Inside the function, cast the character to an `int` type.\n3. Return the ASCII value.\n\nHere is the code:\n\n```cpp\nint find_ascii_value(char character) {\n    return static_cast<int>(character);\n}\n```\n\nYou can then call this function and pass the character whose ASCII value you want to find, like this:\n\n```cpp\nstd::cout << find_ascii_value('A') << std::endl; // Output: 65\n```\n\nNote that this code assumes you are working with characters in the ASCII character set. The ASCII value of a character depends on the character encoding scheme being used."
        ]
    },
    {
        "id": "270",
        "prompt": "Write a python function to find the sum of even numbers at even positions of a list.",
        "solution": "def sum_even_and_even_index(arr):  \n    i = 0\n    sum = 0\n    for i in range(0, len(arr),2): \n        if (arr[i] % 2 == 0) : \n            sum += arr[i]  \n    return sum",
        "code": [
            "def sum_even_and_even_index(arr):  \n    i = 0\n    sum = 0\n    for i in range(0, len(arr),2): \n        if (arr[i] % 2 == 0) : \n            sum += arr[i]  \n    return sum"
        ],
        "pseudo": "# Initialize a variable 'sum_even' to 0\n\n# Iterate through each element and its index in the input list\n    # Check if the index is even and the element is even\n        # If both conditions are satisfied, add the element to 'sum_even'\n\n# Return the value of 'sum_even'",
        "test": [
            "assert sum_even_and_even_index([5, 6, 12, 1, 18, 8]) == 30",
            "assert sum_even_and_even_index([3, 20, 17, 9, 2, 10, 18, 13, 6, 18]) == 26",
            "assert sum_even_and_even_index([5, 6, 12, 1]) == 12"
        ],
        "draft_plan": [
            "# Initialize a variable 'sum_even' to 0\n\n# Iterate through each element and its index in the input list\n    # Check if the index is even and the element is even\n        # If both conditions are satisfied, add the element to 'sum_even'\n\n# Return the value of 'sum_even'"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n\nint sum_even_at_even_positions(const std::vector<int>& lst) {\n    int sum_even = 0;\n\n    for (int i = 0; i < lst.size(); i++) {\n        if (i % 2 == 0 && lst[i] % 2 == 0) {\n            sum_even += lst[i];\n        }\n    }\n\n    return sum_even;\n}"
        ]
    },
    {
        "id": "271",
        "prompt": "Write a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.",
        "solution": "def even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; ",
        "code": [
            "def even_Power_Sum(n): \n    sum = 0; \n    for i in range(1,n+1): \n        j = 2*i; \n        sum = sum + (j*j*j*j*j); \n    return sum; "
        ],
        "pseudo": "# Initialize a variable `sum` to 0\n# Initialize a counter variable `count` to 0\n\n# Iterate through numbers starting from 1 until `count` reaches `n`\n    # Check if the current number is even\n        # Increment the `count` variable\n        # Add the current number raised to the fifth power to the `sum` variable\n\n# Return the `sum` variable",
        "test": [
            "assert even_Power_Sum(2) == 1056",
            "assert even_Power_Sum(3) == 8832",
            "assert even_Power_Sum(1) == 32"
        ],
        "draft_plan": [
            "# Initialize a variable `sum` to 0\n# Initialize a counter variable `count` to 0\n\n# Iterate through numbers starting from 1 until `count` reaches `n`\n    # Check if the current number is even\n        # Increment the `count` variable\n        # Add the current number raised to the fifth power to the `sum` variable\n\n# Return the `sum` variable"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n\nlong long sum_of_even_powers(int n) {\n    long long sum = 0;\n    int count = 0;\n    \n    for (int i = 1; count < n; i++) {\n        if (i % 2 == 0) {\n            count++;\n            sum += pow(i, 5);\n        }\n    }\n    \n    return sum;\n}"
        ]
    },
    {
        "id": "272",
        "prompt": "Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.",
        "solution": "def rear_extract(test_list):\n  res = [lis[-1] for lis in test_list]\n  return (res) ",
        "code": [
            "def rear_extract(test_list):\n  res = [lis[-1] for lis in test_list]\n  return (res) "
        ],
        "pseudo": "# Create an empty list to store the rear elements\n# Iterate through each tuple in the input list\n    # Append the rear element of the current tuple to the list\n\n# Return the list containing the rear elements",
        "test": [
            "assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]",
            "assert rear_extract([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]) == [36, 25, 45]",
            "assert rear_extract([(1, 'Sudeep', 14), (2, 'Vandana', 36), (3, 'Dawood', 56)]) == [14, 36, 56]"
        ],
        "draft_plan": [
            "# Create an empty list to store the rear elements\n# Iterate through each tuple in the input list\n    # Append the rear element of the current tuple to the list\n\n# Return the list containing the rear elements"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n\nstd::vector<int> get_rear_elements(std::vector<std::tuple<int, int>> tuples) {\n    std::vector<int> rear_elements;\n\n    for (const auto& tuple : tuples) {\n        rear_elements.push_back(std::get<1>(tuple));\n    }\n\n    return rear_elements;\n}"
        ]
    },
    {
        "id": "273",
        "prompt": "Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.",
        "solution": "def substract_elements(test_tup1, test_tup2):\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\n  return (res) ",
        "code": [
            "def substract_elements(test_tup1, test_tup2):\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\n  return (res) "
        ],
        "pseudo": "# Define a function that takes in two tuples as arguments\n    # Create an empty list to store the result of the subtraction\n\n    # Iterate through the indices of the tuples\n        # Subtract the element at the current index of the first tuple from the element at the current index of the second tuple\n        # Append the result to the list\n\n    # Return the resulting list",
        "test": [
            "assert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)",
            "assert substract_elements((11, 2, 3), (24, 45 ,16)) == (-13, -43, -13)",
            "assert substract_elements((7, 18, 9), (10, 11, 12)) == (-3, 7, -3)"
        ],
        "draft_plan": [
            "# Define a function that takes in two tuples as arguments\n    # Create an empty list to store the result of the subtraction\n\n    # Iterate through the indices of the tuples\n        # Subtract the element at the current index of the first tuple from the element at the current index of the second tuple\n        # Append the result to the list\n\n    # Return the resulting list"
        ],
        "final_plan": [
            "#include <iostream>\n#include <tuple>\n#include <vector>\n\nstd::vector<int> subtract_tuples(const std::tuple<int, int, int>& tuple1, const std::tuple<int, int, int>& tuple2) {\n    std::vector<int> result;\n\n    for (int i = 0; i < std::tuple_size<std::tuple<int, int, int>>::value; i++) {\n        int element1 = std::get<i>(tuple1);\n        int element2 = std::get<i>(tuple2);\n        int difference = element1 - element2;\n        result.push_back(difference);\n    }\n\n    return result;\n}\n\nint main() {\n    std::tuple<int, int, int> tuple1(1, 2, 3);\n    std::tuple<int, int, int> tuple2(4, 5, 6);\n\n    std::vector<int> result = subtract_tuples(tuple1, tuple2);\n\n    for (int element : result) {\n        std::cout << element << \" \";\n    }\n\n    return 0;\n}"
        ]
    },
    {
        "id": "274",
        "prompt": "Write a python function that takes in a positive integer n and finds the sum of even index binomial coefficients.",
        "solution": "import math  \ndef even_binomial_Coeff_Sum( n): \n    return (1 << (n - 1)) ",
        "code": [
            "import math  \ndef even_binomial_Coeff_Sum( n): \n    return (1 << (n - 1)) "
        ],
        "pseudo": "# Import the math module\n\n# Define a function that takes in a positive integer n\n    # Initialize a variable `sum_even` to store the sum of even index binomial coefficients\n    # Iterate from 0 to n\n        # Calculate the binomial coefficient using the math module's comb function\n        # Check if the index is even\n            # If it is even, add the binomial coefficient to `sum_even`\n    # Return `sum_even`",
        "test": [
            "assert even_binomial_Coeff_Sum(4) == 8",
            "assert even_binomial_Coeff_Sum(6) == 32",
            "assert even_binomial_Coeff_Sum(2) == 2"
        ],
        "draft_plan": [
            "# Import the math module\n\n# Define a function that takes in a positive integer n\n    # Initialize a variable `sum_even` to store the sum of even index binomial coefficients\n    # Iterate from 0 to n\n        # Calculate the binomial coefficient using the math module's comb function\n        # Check if the index is even\n            # If it is even, add the binomial coefficient to `sum_even`\n    # Return `sum_even`"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nlong long binomialCoeff(int n, int k) {\n    if (k == 0 || k == n) {\n        return 1;\n    }\n    return binomialCoeff(n - 1, k - 1) + binomialCoeff(n - 1, k);\n}\n\nlong long sum_even_index_binomial_coeffs(int n) {\n    long long sum_even = 0;\n    for (int i = 0; i <= n; i++) {\n        long long coeff = binomialCoeff(n, i);\n        if (i % 2 == 0) {\n            sum_even += coeff;\n        }\n    }\n    return sum_even;\n}"
        ]
    },
    {
        "id": "276",
        "prompt": "Write a function that takes in the radius and height of a cylinder and returns the the volume.",
        "solution": "def volume_cylinder(r,h):\n  volume=3.1415*r*r*h\n  return volume",
        "code": [
            "def volume_cylinder(r,h):\n  volume=3.1415*r*r*h\n  return volume"
        ],
        "pseudo": "# Define a function named \"cylinder_volume\" that takes in two parameters: radius and height\n    # Calculate the volume of the cylinder using the formula: volume = \u03c0 * radius^2 * height\n    # Return the calculated volume\n\n# Test the function by calling it with sample inputs",
        "test": [
            "assert math.isclose(volume_cylinder(10,5), 1570.7500000000002, rel_tol=0.001)",
            "assert math.isclose(volume_cylinder(4,5), 251.32000000000002, rel_tol=0.001)",
            "assert math.isclose(volume_cylinder(4,10), 502.64000000000004, rel_tol=0.001)"
        ],
        "draft_plan": [
            "# Define a function named \"cylinder_volume\" that takes in two parameters: radius and height\n    # Calculate the volume of the cylinder using the formula: volume = \u03c0 * radius^2 * height\n    # Return the calculated volume\n\n# Test the function by calling it with sample inputs"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <cmath>\n\ndouble cylinder_volume(double radius, double height) {\n    double volume = M_PI * pow(radius, 2) * height;\n    return volume;\n}\n\nint main() {\n    // Test the function\n    double radius = 3.0;\n    double height = 5.0;\n    double result = cylinder_volume(radius, height);\n    assert(result == 141.3716694115407);\n\n    return 0;\n}"
        ]
    },
    {
        "id": "277",
        "prompt": "Write a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.",
        "solution": "def dict_filter(dict,n):\n result = {key:value for (key, value) in dict.items() if value >=n}\n return result",
        "code": [
            "def dict_filter(dict,n):\n result = {key:value for (key, value) in dict.items() if value >=n}\n return result"
        ],
        "pseudo": "# Initialize an empty dictionary to store the filtered entries\n\n# Iterate through each key-value pair in the input dictionary\n    # Check if the value is greater than or equal to n\n        # If it is, add the key-value pair to the filtered dictionary\n\n# Return the filtered dictionary",
        "test": [
            "assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},170)=={'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}",
            "assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},180)=={ 'Alden Cantrell': 180, 'Pierre Cox': 190}",
            "assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},190)=={ 'Pierre Cox': 190}"
        ],
        "draft_plan": [
            "# Initialize an empty dictionary to store the filtered entries\n\n# Iterate through each key-value pair in the input dictionary\n    # Check if the value is greater than or equal to n\n        # If it is, add the key-value pair to the filtered dictionary\n\n# Return the filtered dictionary"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <unordered_map>\n\nstd::unordered_map<int, int> filter_dictionary(std::unordered_map<int, int> dictionary, int n) {\n    std::unordered_map<int, int> filtered_dict;\n\n    for (const auto& kvp : dictionary) {\n        if (kvp.second >= n) {\n            filtered_dict[kvp.first] = kvp.second;\n        }\n    }\n\n    return filtered_dict;\n}"
        ]
    },
    {
        "id": "278",
        "prompt": "Write a function to find the number of elements that occurs before the tuple element in the given tuple.",
        "solution": "def count_first_elements(test_tup):\n  for count, ele in enumerate(test_tup):\n    if isinstance(ele, tuple):\n      break\n  return (count) ",
        "code": [
            "def count_first_elements(test_tup):\n  for count, ele in enumerate(test_tup):\n    if isinstance(ele, tuple):\n      break\n  return (count) "
        ],
        "pseudo": "# Initialize a count variable to 0\n# Iterate through each element and its index in the given tuple\n    # Check if the current element is equal to the target element in the tuple\n        # If it is, return the count\n    # If the current element is not equal to the target element, increment the count by 1\n\n# If the target element is not found in the tuple, return -1",
        "test": [
            "assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3",
            "assert count_first_elements((2, 9, (5, 7), 11) ) == 2",
            "assert count_first_elements((11, 15, 5, 8, (2, 3), 8) ) == 4"
        ],
        "draft_plan": [
            "# Initialize a count variable to 0\n# Iterate through each element and its index in the given tuple\n    # Check if the current element is equal to the target element in the tuple\n        # If it is, return the count\n    # If the current element is not equal to the target element, increment the count by 1\n\n# If the target element is not found in the tuple, return -1"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <tuple>\n#include <vector>\n\ntemplate <typename T>\nint count_elements_before(const std::tuple<T, T, T>& tuple, const T& target) {\n    int count = 0;\n    if (std::get<0>(tuple) == target) {\n        return count;\n    }\n    count++;\n    if (std::get<1>(tuple) == target) {\n        return count;\n    }\n    count++;\n    if (std::get<2>(tuple) == target) {\n        return count;\n    }\n    return -1;\n}\n\nint main() {\n    std::tuple<int, int, int> tuple1 = std::make_tuple(1, 2, 3);\n    std::tuple<int, int, int> tuple2 = std::make_tuple(4, 5, 6);\n    std::tuple<int, int, int> tuple3 = std::make_tuple(7, 8, 9);\n\n    assert(count_elements_before(tuple1, 2) == 1);\n    assert(count_elements_before(tuple2, 4) == 0);\n    assert(count_elements_before(tuple3, 10) == -1);\n\n    std::cout << \"All test cases passed!\" << std::endl;\n\n    return 0;\n}"
        ]
    },
    {
        "id": "279",
        "prompt": "Write a function to find the nth decagonal number.",
        "solution": "def is_num_decagonal(n): \n\treturn 4 * n * n - 3 * n ",
        "code": [
            "def is_num_decagonal(n): \n\treturn 4 * n * n - 3 * n "
        ],
        "pseudo": "# Formula to find the nth decagonal number is: 3n^2 - 2n\n\n# Define a function named nth_decagonal_number that takes an argument n\n    # Calculate the decagonal number using the formula: 3*n*n - 2*n\n    # Return the calculated decagonal number\n\n# Call the function nth_decagonal_number with the desired value of n to find the nth decagonal number",
        "test": [
            "assert is_num_decagonal(3) == 27",
            "assert is_num_decagonal(7) == 175",
            "assert is_num_decagonal(10) == 370"
        ],
        "draft_plan": [
            "# Formula to find the nth decagonal number is: 3n^2 - 2n\n\n# Define a function named nth_decagonal_number that takes an argument n\n    # Calculate the decagonal number using the formula: 3*n*n - 2*n\n    # Return the calculated decagonal number\n\n# Call the function nth_decagonal_number with the desired value of n to find the nth decagonal number"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n\nint nth_decagonal_number(int n) {\n    return 3 * n * n - 2 * n;\n}"
        ]
    },
    {
        "id": "280",
        "prompt": "Write a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).",
        "solution": "def sequential_search(dlist, item):\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos = pos + 1\n    return found, pos",
        "code": [
            "def sequential_search(dlist, item):\n    pos = 0\n    found = False\n    while pos < len(dlist) and not found:\n        if dlist[pos] == item:\n            found = True\n        else:\n            pos = pos + 1\n    return found, pos"
        ],
        "pseudo": "# Initialize a variable to store the index position of the element, initialized to -1\n# Iterate through each element in the array along with its index\n    # Check if the current element is equal to the target element\n        # If they are equal, update the index variable with the current index and break out of the loop\n\n# Check if the index variable is still equal to -1\n    # If it is, set the boolean variable to False, indicating the element is not found\n    # If it is not, set the boolean variable to True, indicating the element is found\n\n# Return a tuple with the boolean variable and the index variable",
        "test": [
            "assert sequential_search([11,23,58,31,56,77,43,12,65,19],31) == (True, 3)",
            "assert sequential_search([12, 32, 45, 62, 35, 47, 44, 61],61) == (True, 7)",
            "assert sequential_search([9, 10, 17, 19, 22, 39, 48, 56],48) == (True, 6)"
        ],
        "draft_plan": [
            "# Initialize a variable to store the index position of the element, initialized to -1\n# Iterate through each element in the array along with its index\n    # Check if the current element is equal to the target element\n        # If they are equal, update the index variable with the current index and break out of the loop\n\n# Check if the index variable is still equal to -1\n    # If it is, set the boolean variable to False, indicating the element is not found\n    # If it is not, set the boolean variable to True, indicating the element is found\n\n# Return a tuple with the boolean variable and the index variable"
        ],
        "final_plan": [
            "#include <tuple>\n#include <vector>\n\nstd::tuple<bool, int> find_element(const std::vector<int>& array, int element) {\n    int index = -1;\n    \n    for (int i = 0; i < array.size(); i++) {\n        if (array[i] == element) {\n            index = i;\n            break;\n        }\n    }\n    \n    bool is_found = (index != -1);\n    \n    return std::make_tuple(is_found, index);\n}"
        ]
    },
    {
        "id": "281",
        "prompt": "Write a python function to check if the elements of a given list are unique or not.",
        "solution": "def all_unique(test_list):\n    if len(test_list) > len(set(test_list)):\n        return False\n    return True",
        "code": [
            "def all_unique(test_list):\n    if len(test_list) > len(set(test_list)):\n        return False\n    return True"
        ],
        "pseudo": "# Convert the input list into a set\n# Compare the length of the input list with the length of the set\n    # If they are equal, return True (all elements are unique)\n    # If they are not equal, return False (there are duplicate elements)",
        "test": [
            "assert all_unique([1,2,3]) == True",
            "assert all_unique([1,2,1,2]) == False",
            "assert all_unique([1,2,3,4,5]) == True"
        ],
        "draft_plan": [
            "# Convert the input list into a set\n# Compare the length of the input list with the length of the set\n    # If they are equal, return True (all elements are unique)\n    # If they are not equal, return False (there are duplicate elements)"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nbool is_unique(std::vector<int> input_list) {\n    std::set<int> unique_set(input_list.begin(), input_list.end());\n    return input_list.size() == unique_set.size();\n}"
        ]
    },
    {
        "id": "282",
        "prompt": "Write a function to subtract two lists element-wise.",
        "solution": "def sub_list(nums1,nums2):\n  result = map(lambda x, y: x - y, nums1, nums2)\n  return list(result)",
        "code": [
            "def sub_list(nums1,nums2):\n  result = map(lambda x, y: x - y, nums1, nums2)\n  return list(result)"
        ],
        "pseudo": "# Create an empty list to store the result\n\n# Iterate through the indices of the lists\n    # Subtract the elements at the corresponding indices of the two lists\n    # Append the result to the result list\n\n# Return the result list",
        "test": [
            "assert sub_list([1, 2, 3],[4,5,6])==[-3,-3,-3]",
            "assert sub_list([1,2],[3,4])==[-2,-2]",
            "assert sub_list([90,120],[50,70])==[40,50]"
        ],
        "draft_plan": [
            "# Create an empty list to store the result\n\n# Iterate through the indices of the lists\n    # Subtract the elements at the corresponding indices of the two lists\n    # Append the result to the result list\n\n# Return the result list"
        ],
        "final_plan": [
            "#include <cassert>\n#include <vector>\n\nstd::vector<int> subtract_lists(const std::vector<int>& list1, const std::vector<int>& list2) {\n    assert(list1.size() == list2.size());\n\n    std::vector<int> result;\n    for (std::size_t i = 0; i < list1.size(); ++i) {\n        result.push_back(list1[i] - list2[i]);\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "283",
        "prompt": "Write a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.",
        "solution": "def validate(n): \n    for i in range(10): \n        temp = n;  \n        count = 0; \n        while (temp): \n            if (temp % 10 == i): \n                count+=1;  \n            if (count > i): \n                return False\n            temp //= 10; \n    return True",
        "code": [
            "def validate(n): \n    for i in range(10): \n        temp = n;  \n        count = 0; \n        while (temp): \n            if (temp % 10 == i): \n                count+=1;  \n            if (count > i): \n                return False\n            temp //= 10; \n    return True"
        ],
        "pseudo": "# Convert the input integer to a string\n# Initialize a dictionary to store the frequency of each digit\n\n# Iterate through each digit in the string\n    # Increment the frequency of the digit in the dictionary\n\n# Iterate through each digit in the string\n    # Check if the frequency of the digit is greater than the digit itself\n        # If yes, return False\n\n# If all frequencies are less than or equal to their respective digits, return True",
        "test": [
            "assert validate(1234) == True",
            "assert validate(51241) == False",
            "assert validate(321) == True"
        ],
        "draft_plan": [
            "# Convert the input integer to a string\n# Initialize a dictionary to store the frequency of each digit\n\n# Iterate through each digit in the string\n    # Increment the frequency of the digit in the dictionary\n\n# Iterate through each digit in the string\n    # Check if the frequency of the digit is greater than the digit itself\n        # If yes, return False\n\n# If all frequencies are less than or equal to their respective digits, return True"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nbool check_digit_frequency(int n) {\n    std::string num_str = std::to_string(n);\n    std::unordered_map<char, int> digit_freq;\n\n    for (char digit : num_str) {\n        digit_freq[digit]++;\n    }\n\n    for (char digit : num_str) {\n        if (digit_freq[digit] > (digit - '0')) {\n            return false;\n        }\n    }\n\n    return true;\n}"
        ]
    },
    {
        "id": "284",
        "prompt": "Write a function that takes in a list and element and checks whether all items in the list are equal to the given element.",
        "solution": "def check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element",
        "code": [
            "def check_element(list,element):\n  check_element=all(v== element for v in list)\n  return check_element"
        ],
        "pseudo": "# Iterate through each item in the list\n    # Check if the current item is equal to the given element\n        # If not, return False\n\n# If all items in the list are equal to the given element, return True",
        "test": [
            "assert check_element([\"green\", \"orange\", \"black\", \"white\"],'blue')==False",
            "assert check_element([1,2,3,4],7)==False",
            "assert check_element([\"green\", \"green\", \"green\", \"green\"],'green')==True"
        ],
        "draft_plan": [
            "# Iterate through each item in the list\n    # Check if the current item is equal to the given element\n        # If not, return False\n\n# If all items in the list are equal to the given element, return True"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\ntemplate<typename T>\nbool check_all_equal(std::vector<T> lst, T element) {\n    for (const auto& item : lst) {\n        if (item != element) {\n            return false;\n        }\n    }\n    return true;\n}"
        ]
    },
    {
        "id": "285",
        "prompt": "Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.",
        "solution": "import re\ndef text_match_two_three(text):\n        patterns = 'ab{2,3}'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False",
        "code": [
            "import re\ndef text_match_two_three(text):\n        patterns = 'ab{2,3}'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False"
        ],
        "pseudo": "# Iterate through each character in the input string\n    # Check if the current character is 'a'\n        # If it is, check the next two characters (if they exist) to see if they are 'b'\n            # If they are, return True\n    # If the current character is not 'a', continue to the next character\n\n# If no 'a' followed by two or three 'b' characters is found, return False",
        "test": [
            "assert text_match_two_three(\"ac\")==(False)",
            "assert text_match_two_three(\"dc\")==(False)",
            "assert text_match_two_three(\"abbbba\")==(True)"
        ],
        "draft_plan": [
            "# Iterate through each character in the input string\n    # Check if the current character is 'a'\n        # If it is, check the next two characters (if they exist) to see if they are 'b'\n            # If they are, return True\n    # If the current character is not 'a', continue to the next character\n\n# If no 'a' followed by two or three 'b' characters is found, return False"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nbool check_pattern(std::string text) {\n    int n = text.length();\n    for (int i = 0; i < n - 2; i++) {\n        if (text[i] == 'a' && text[i + 1] == 'b' && (text[i + 2] == 'b' || text[i + 2] == 'b')) {\n            return true;\n        }\n    }\n    return false;\n}"
        ]
    },
    {
        "id": "286",
        "prompt": "Write a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.",
        "solution": "def max_sub_array_sum_repeated(a, n, k): \n\tmax_so_far = -2147483648\n\tmax_ending_here = 0\n\tfor i in range(n*k): \n\t\tmax_ending_here = max_ending_here + a[i%n] \n\t\tif (max_so_far < max_ending_here): \n\t\t\tmax_so_far = max_ending_here \n\t\tif (max_ending_here < 0): \n\t\t\tmax_ending_here = 0\n\treturn max_so_far",
        "code": [
            "def max_sub_array_sum_repeated(a, n, k): \n\tmax_so_far = -2147483648\n\tmax_ending_here = 0\n\tfor i in range(n*k): \n\t\tmax_ending_here = max_ending_here + a[i%n] \n\t\tif (max_so_far < max_ending_here): \n\t\t\tmax_so_far = max_ending_here \n\t\tif (max_ending_here < 0): \n\t\t\tmax_ending_here = 0\n\treturn max_so_far"
        ],
        "pseudo": "# Initialize variables to store the maximum sum and the current sum\n# Repeat the given array k times to form the modified array\n\n# Iterate through each element in the modified array\n    # Add the current element to the current sum\n    # Check if the current sum is greater than the maximum sum\n        # If so, update the maximum sum\n    # Check if the current sum is less than 0\n        # If so, reset the current sum to 0\n\n# Return the maximum sum",
        "test": [
            "assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30",
            "assert max_sub_array_sum_repeated([-1, 10, 20], 3, 2) == 59",
            "assert max_sub_array_sum_repeated([-1, -2, -3], 3, 3) == -1"
        ],
        "draft_plan": [
            "# Initialize variables to store the maximum sum and the current sum\n# Repeat the given array k times to form the modified array\n\n# Iterate through each element in the modified array\n    # Add the current element to the current sum\n    # Check if the current sum is greater than the maximum sum\n        # If so, update the maximum sum\n    # Check if the current sum is less than 0\n        # If so, reset the current sum to 0\n\n# Return the maximum sum"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n#include <assert.h>\n\nint largest_sum(std::vector<int> nums, int k) {\n    int n = nums.size();\n    std::vector<int> modified_array;\n    int max_sum = INT_MIN;\n    int current_sum = 0;\n\n    // Repeat the given array k times to form the modified array\n    for (int i = 0; i < k; i++) {\n        for (int j = 0; j < n; j++) {\n            modified_array.push_back(nums[j]);\n        }\n    }\n\n    // Iterate through each element in the modified array\n    for (int i = 0; i < modified_array.size(); i++) {\n        // Add the current element to the current sum\n        current_sum += modified_array[i];\n\n        // Check if the current sum is greater than the maximum sum\n        if (current_sum > max_sum) {\n            max_sum = current_sum;\n        }\n\n        // Check if the current sum is less than 0\n        if (current_sum < 0) {\n            current_sum = 0;\n        }\n    }\n\n    return max_sum;\n}"
        ]
    },
    {
        "id": "287",
        "prompt": "Write a python function takes in an integer n and returns the sum of squares of first n even natural numbers.",
        "solution": "def square_Sum(n):  \n    return int(2*n*(n+1)*(2*n+1)/3)",
        "code": [
            "def square_Sum(n):  \n    return int(2*n*(n+1)*(2*n+1)/3)"
        ],
        "pseudo": "# Initialize the sum of squares variable to 0\n\n# Iterate from 1 to n\n    # Check if the current number is even\n        # Add the square of the current number to the sum of squares variable\n\n# Return the sum of squares",
        "test": [
            "assert square_Sum(2) == 20",
            "assert square_Sum(3) == 56",
            "assert square_Sum(4) == 120"
        ],
        "draft_plan": [
            "# Initialize the sum of squares variable to 0\n\n# Iterate from 1 to n\n    # Check if the current number is even\n        # Add the square of the current number to the sum of squares variable\n\n# Return the sum of squares"
        ],
        "final_plan": [
            "#include <iostream>\n\nint sum_of_squares_of_even(int n) {\n    int sum = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            sum += (i * i);\n        }\n    }\n    \n    return sum;\n}\n\nint main() {\n    int n = 10;\n    int result = sum_of_squares_of_even(n);\n    \n    std::cout << \"Sum of squares of first \" << n << \" even natural numbers: \" << result << std::endl;\n    \n    return 0;\n}"
        ]
    },
    {
        "id": "290",
        "prompt": "Write a function to find the list of maximum length in a list of lists.",
        "solution": "def max_length(list1):\n    max_length = max(len(x) for x in  list1 )  \n    max_list = max((x) for x in   list1)\n    return(max_length, max_list)",
        "code": [
            "def max_length(list1):\n    max_length = max(len(x) for x in  list1 )  \n    max_list = max((x) for x in   list1)\n    return(max_length, max_list)"
        ],
        "pseudo": "# Initialize a variable to store the maximum length and an empty list to store the list with maximum length\n\n# Iterate through each list in the input list of lists\n    # Check if the length of the current list is greater than the maximum length\n        # If so, update the maximum length and the list with maximum length\n\n# Return the list with maximum length",
        "test": [
            "assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])",
            "assert max_length([[1], [5, 7], [10, 12, 14,15]])==(4, [10, 12, 14,15])",
            "assert max_length([[5], [15,20,25]])==(3, [15,20,25])"
        ],
        "draft_plan": [
            "# Initialize a variable to store the maximum length and an empty list to store the list with maximum length\n\n# Iterate through each list in the input list of lists\n    # Check if the length of the current list is greater than the maximum length\n        # If so, update the maximum length and the list with maximum length\n\n# Return the list with maximum length"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<int> max_length_list(std::vector<std::vector<int>> list_of_lists) {\n    int max_length = 0;\n    std::vector<int> max_length_list;\n\n    for (const auto& lst : list_of_lists) {\n        if (lst.size() > max_length) {\n            max_length = lst.size();\n            max_length_list = lst;\n        }\n    }\n\n    return max_length_list;\n}"
        ]
    },
    {
        "id": "291",
        "prompt": "Write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.",
        "solution": "def count_no_of_ways(n, k): \n\tdp = [0] * (n + 1) \n\ttotal = k \n\tmod = 1000000007\n\tdp[1] = k \n\tdp[2] = k * k\t \n\tfor i in range(3,n+1): \n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \n\treturn dp[n]",
        "code": [
            "def count_no_of_ways(n, k): \n\tdp = [0] * (n + 1) \n\ttotal = k \n\tmod = 1000000007\n\tdp[1] = k \n\tdp[2] = k * k\t \n\tfor i in range(3,n+1): \n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \n\treturn dp[n]"
        ],
        "pseudo": "# If there are no posts or no colors, return 0\n# If there is only 1 post, return k (number of colors)\n\n# Initialize two variables to keep track of the number of ways with different colors and the number of ways with the same color for the first two posts\n# Set the number of ways with different colors to k\n# Set the number of ways with the same color to k\n\n# Iterate from the third post to the nth post\n    # Calculate the number of ways with different colors for the current post\n        # Multiply the number of ways with different colors for the previous post by (k-1)\n    # Calculate the number of ways with the same color for the current post\n        # Set it equal to the number of ways with different colors for the previous post\n\n# Return the sum of the number of ways with different colors and the number of ways with the same color for the nth post",
        "test": [
            "assert count_no_of_ways(2, 4) == 16",
            "assert count_no_of_ways(3, 2) == 6",
            "assert count_no_of_ways(4, 4) == 228"
        ],
        "draft_plan": [
            "# If there are no posts or no colors, return 0\n# If there is only 1 post, return k (number of colors)\n\n# Initialize two variables to keep track of the number of ways with different colors and the number of ways with the same color for the first two posts\n# Set the number of ways with different colors to k\n# Set the number of ways with the same color to k\n\n# Iterate from the third post to the nth post\n    # Calculate the number of ways with different colors for the current post\n        # Multiply the number of ways with different colors for the previous post by (k-1)\n    # Calculate the number of ways with the same color for the current post\n        # Set it equal to the number of ways with different colors for the previous post\n\n# Return the sum of the number of ways with different colors and the number of ways with the same color for the nth post"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n\nint num_ways_to_paint_fence(int n, int k) {\n    if (n == 0 || k == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return k;\n    }\n\n    int same_color = k;\n    int diff_color = k;\n\n    for (int i = 2; i <= n; i++) {\n        int prev_same_color = same_color;\n        same_color = diff_color;\n        diff_color = (prev_same_color + diff_color) * (k - 1);\n    }\n\n    return same_color + diff_color;\n}"
        ]
    },
    {
        "id": "292",
        "prompt": "Write a python function to find quotient of two numbers (rounded down to the nearest integer).",
        "solution": "def find(n,m):  \n    q = n//m \n    return (q)",
        "code": [
            "def find(n,m):  \n    q = n//m \n    return (q)"
        ],
        "pseudo": "To find the quotient of two numbers rounded down to the nearest integer, you can use the floor division operator `//` in Python.\n\nHere is the code logic:\n\n```python\ndef quotient(a, b):\n    return a // b\n```\n\nIn this code, the function `quotient` takes two parameters `a` and `b`, representing the numbers for which we want to find the quotient. The floor division `a // b` divides `a` by `b` and returns the quotient rounded down to the nearest integer.\n\nYou can call this function with your desired values to find the quotient. For example:\n\n```python\nresult = quotient(10, 3)\nprint(result)  # Output: 3\n```",
        "test": [
            "assert find(10,3) == 3",
            "assert find(4,2) == 2",
            "assert find(20,5) == 4"
        ],
        "draft_plan": [
            "To find the quotient of two numbers rounded down to the nearest integer, you can use the floor division operator `//` in Python.\n\nHere is the code logic:\n\n```python\ndef quotient(a, b):\n    return a // b\n```\n\nIn this code, the function `quotient` takes two parameters `a` and `b`, representing the numbers for which we want to find the quotient. The floor division `a // b` divides `a` by `b` and returns the quotient rounded down to the nearest integer.\n\nYou can call this function with your desired values to find the quotient. For example:\n\n```python\nresult = quotient(10, 3)\nprint(result)  # Output: 3\n```"
        ],
        "final_plan": [
            "Here is the C++ code to find the quotient of two numbers (rounded down to the nearest integer):\n\n```cpp\n#include <iostream>\n\nint quotient(int a, int b) {\n    return a / b;\n}\n\nint main() {\n    int a = 10;\n    int b = 3;\n    \n    int result = quotient(a, b);\n    std::cout << result << std::endl;  // Output: 3\n    \n    return 0;\n}\n```\n\nIn this code, the function `quotient` takes two parameters `a` and `b`, representing the numbers for which we want to find the quotient. The division `a / b` in C++ returns the quotient rounded down to the nearest integer.\n\nYou can call this function with your desired values to find the quotient."
        ]
    },
    {
        "id": "293",
        "prompt": "Write a function to find the third side of a right angled triangle.",
        "solution": "import math\ndef otherside_rightangle(w,h):\n  s=math.sqrt((w*w)+(h*h))\n  return s",
        "code": [
            "import math\ndef otherside_rightangle(w,h):\n  s=math.sqrt((w*w)+(h*h))\n  return s"
        ],
        "pseudo": "# Import the math module\n\n# Define a function to find the third side of a right-angled triangle\n    # Calculate the square of the two given sides\n    # Calculate the sum of the squares of the two given sides\n    # Take the square root of the sum to find the length of the hypotenuse\n    # Return the length of the hypotenuse\n\n# Call the function with the given sides of the triangle and print the result",
        "test": [
            "assert otherside_rightangle(7,8)==10.63014581273465",
            "assert otherside_rightangle(3,4)==5",
            "assert otherside_rightangle(7,15)==16.55294535724685"
        ],
        "draft_plan": [
            "# Import the math module\n\n# Define a function to find the third side of a right-angled triangle\n    # Calculate the square of the two given sides\n    # Calculate the sum of the squares of the two given sides\n    # Take the square root of the sum to find the length of the hypotenuse\n    # Return the length of the hypotenuse\n\n# Call the function with the given sides of the triangle and print the result"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <cmath>\n\ndouble find_third_side(double side1, double side2) {\n    double hypotenuse = std::sqrt((side1 * side1) + (side2 * side2));\n    return hypotenuse;\n}"
        ]
    },
    {
        "id": "294",
        "prompt": "Write a function to find the maximum value in a given heterogeneous list.",
        "solution": "def max_val(listval):\n     max_val = max(i for i in listval if isinstance(i, int)) \n     return(max_val)",
        "code": [
            "def max_val(listval):\n     max_val = max(i for i in listval if isinstance(i, int)) \n     return(max_val)"
        ],
        "pseudo": "# Initialize the maximum value with the first element in the list\n\n# Iterate through each element in the list starting from the second element\n    # Compare the current element with the maximum value\n        # If the current element is greater than the maximum value, update the maximum value\n\n# Return the maximum value",
        "test": [
            "assert max_val(['Python', 3, 2, 4, 5, 'version'])==5",
            "assert max_val(['Python', 15, 20, 25])==25",
            "assert max_val(['Python', 30, 20, 40, 50, 'version'])==50"
        ],
        "draft_plan": [
            "# Initialize the maximum value with the first element in the list\n\n# Iterate through each element in the list starting from the second element\n    # Compare the current element with the maximum value\n        # If the current element is greater than the maximum value, update the maximum value\n\n# Return the maximum value"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n#include <algorithm>\n\ntemplate <typename T>\nT find_maximum(std::vector<T> values) {\n    if (values.empty()) {\n        throw std::invalid_argument(\"Input list is empty.\");\n    }\n\n    T maximum = values[0];\n\n    for (size_t i = 1; i < values.size(); i++) {\n        if (values[i] > maximum) {\n            maximum = values[i];\n        }\n    }\n\n    return maximum;\n}"
        ]
    },
    {
        "id": "295",
        "prompt": "Write a function to return the sum of all divisors of a number.",
        "solution": "def sum_div(number):\n    divisors = [1]\n    for i in range(2, number):\n        if (number % i)==0:\n            divisors.append(i)\n    return sum(divisors)",
        "code": [
            "def sum_div(number):\n    divisors = [1]\n    for i in range(2, number):\n        if (number % i)==0:\n            divisors.append(i)\n    return sum(divisors)"
        ],
        "pseudo": "# Initialize the sum of divisors to 0\n\n# Iterate from 1 to the given number\n    # Check if the current number is a divisor of the given number\n        # If it is, add it to the sum of divisors\n\n# Return the sum of divisors",
        "test": [
            "assert sum_div(8)==7",
            "assert sum_div(12)==16",
            "assert sum_div(7)==1"
        ],
        "draft_plan": [
            "# Initialize the sum of divisors to 0\n\n# Iterate from 1 to the given number\n    # Check if the current number is a divisor of the given number\n        # If it is, add it to the sum of divisors\n\n# Return the sum of divisors"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\nusing namespace std;\n\nint sum_of_divisors(int n) {\n    int sum = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        if (n % i == 0) {\n            sum += i;\n        }\n    }\n    \n    return sum;\n}"
        ]
    },
    {
        "id": "296",
        "prompt": "Write a python function to count inversions in an array.",
        "solution": "def get_Inv_Count(arr): \n    inv_count = 0\n    for i in range(len(arr)): \n        for j in range(i + 1, len(arr)): \n            if (arr[i] > arr[j]): \n                inv_count += 1\n    return inv_count ",
        "code": [
            "def get_Inv_Count(arr): \n    inv_count = 0\n    for i in range(len(arr)): \n        for j in range(i + 1, len(arr)): \n            if (arr[i] > arr[j]): \n                inv_count += 1\n    return inv_count "
        ],
        "pseudo": "# Initialize a variable to count the number of inversions\n# Iterate through each element in the array\n    # For each element, iterate through the remaining elements\n        # Check if the current element is greater than any of the remaining elements\n            # If so, increment the inversion count\n\n# Return the inversion count",
        "test": [
            "assert get_Inv_Count([1,20,6,4,5]) == 5",
            "assert get_Inv_Count([1,2,1]) == 1",
            "assert get_Inv_Count([1,2,5,6,1]) == 3"
        ],
        "draft_plan": [
            "# Initialize a variable to count the number of inversions\n# Iterate through each element in the array\n    # For each element, iterate through the remaining elements\n        # Check if the current element is greater than any of the remaining elements\n            # If so, increment the inversion count\n\n# Return the inversion count"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\nint count_inversions(std::vector<int> array) {\n    int inversions = 0;\n    int n = array.size();\n\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (array[i] > array[j]) {\n                inversions++;\n            }\n        }\n    }\n\n    return inversions;\n}"
        ]
    },
    {
        "id": "297",
        "prompt": "Write a function to flatten a given nested list structure.",
        "solution": "def flatten_list(list1):\n    result_list = []\n    if not list1: return result_list\n    stack = [list(list1)]\n    while stack:\n        c_num = stack.pop()\n        next = c_num.pop()\n        if c_num: stack.append(c_num)\n        if isinstance(next, list):\n            if next: stack.append(list(next))\n        else: result_list.append(next)\n    result_list.reverse()\n    return result_list ",
        "code": [
            "def flatten_list(list1):\n    result_list = []\n    if not list1: return result_list\n    stack = [list(list1)]\n    while stack:\n        c_num = stack.pop()\n        next = c_num.pop()\n        if c_num: stack.append(c_num)\n        if isinstance(next, list):\n            if next: stack.append(list(next))\n        else: result_list.append(next)\n    result_list.reverse()\n    return result_list "
        ],
        "pseudo": "# Initialize an empty list to store the flattened elements\n\n# Iterate through each element in the given list\n    # If the element is a list, recursively flatten it and append each element to the flattened list\n    # If the element is not a list, append it directly to the flattened list\n\n# Return the flattened list",
        "test": [
            "assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]",
            "assert flatten_list([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]])==[10, 20, 40, 30, 56, 25, 10, 20, 33, 40]",
            "assert flatten_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]"
        ],
        "draft_plan": [
            "# Initialize an empty list to store the flattened elements\n\n# Iterate through each element in the given list\n    # If the element is a list, recursively flatten it and append each element to the flattened list\n    # If the element is not a list, append it directly to the flattened list\n\n# Return the flattened list"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\nstd::vector<int> flatten(std::vector<std::variant<int, std::vector<int>>> nested_list) {\n    std::vector<int> flattened_list;\n\n    for (const auto& element : nested_list) {\n        if (std::holds_alternative<int>(element)) {\n            flattened_list.push_back(std::get<int>(element));\n        } else {\n            std::vector<int> sub_list = std::get<std::vector<int>>(element);\n            std::vector<int> flattened_sub_list = flatten(sub_list);\n            flattened_list.insert(flattened_list.end(), flattened_sub_list.begin(), flattened_sub_list.end());\n        }\n    }\n\n    return flattened_list;\n}"
        ]
    },
    {
        "id": "299",
        "prompt": "Write a function to calculate the maximum aggregate from the list of tuples.",
        "solution": "from collections import defaultdict\ndef max_aggregate(stdata):\n    temp = defaultdict(int)\n    for name, marks in stdata:\n        temp[name] += marks\n    return max(temp.items(), key=lambda x: x[1])",
        "code": [
            "from collections import defaultdict\ndef max_aggregate(stdata):\n    temp = defaultdict(int)\n    for name, marks in stdata:\n        temp[name] += marks\n    return max(temp.items(), key=lambda x: x[1])"
        ],
        "pseudo": "# Sort the list of tuples in descending order based on the second element\n\n# Initialize the maximum aggregate to 0\n\n# Iterate through each tuple in the sorted list\n    # Calculate the current aggregate by adding the second element of the tuple to the maximum aggregate\n    # Update the maximum aggregate if the current aggregate is greater\n\n# Return the maximum aggregate",
        "test": [
            "assert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', 212)",
            "assert max_aggregate([('Juan Whelan',50),('Sabah Colley',48),('Peter Nichols',37),('Juan Whelan',22),('Sabah Colley',14)])==('Juan Whelan', 72)",
            "assert max_aggregate([('Juan Whelan',10),('Sabah Colley',20),('Peter Nichols',30),('Juan Whelan',40),('Sabah Colley',50)])==('Sabah Colley', 70)"
        ],
        "draft_plan": [
            "# Sort the list of tuples in descending order based on the second element\n\n# Initialize the maximum aggregate to 0\n\n# Iterate through each tuple in the sorted list\n    # Calculate the current aggregate by adding the second element of the tuple to the maximum aggregate\n    # Update the maximum aggregate if the current aggregate is greater\n\n# Return the maximum aggregate"
        ],
        "final_plan": [
            "#include <cassert>\n#include <algorithm>\n#include <vector>\n\nint calculate_maximum_aggregate(std::vector<std::pair<int, int>> tuples) {\n    // Sort the list of tuples in descending order based on the second element\n    std::sort(tuples.begin(), tuples.end(), [](const auto& a, const auto& b) {\n        return a.second > b.second;\n    });\n\n    // Initialize the maximum aggregate to 0\n    int maximum_aggregate = 0;\n\n    // Iterate through each tuple in the sorted list\n    for (const auto& tuple : tuples) {\n        // Calculate the current aggregate by adding the second element of the tuple to the maximum aggregate\n        int current_aggregate = maximum_aggregate + tuple.second;\n\n        // Update the maximum aggregate if the current aggregate is greater\n        if (current_aggregate > maximum_aggregate) {\n            maximum_aggregate = current_aggregate;\n        }\n    }\n\n    // Return the maximum aggregate\n    return maximum_aggregate;\n}"
        ]
    },
    {
        "id": "300",
        "prompt": "Write a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.",
        "solution": "def count_binary_seq(n): \n\tnCr = 1\n\tres = 1\n\tfor r in range(1, n + 1): \n\t\tnCr = (nCr * (n + 1 - r)) / r \n\t\tres += nCr * nCr \n\treturn res ",
        "code": [
            "def count_binary_seq(n): \n\tnCr = 1\n\tres = 1\n\tfor r in range(1, n + 1): \n\t\tnCr = (nCr * (n + 1 - r)) / r \n\t\tres += nCr * nCr \n\treturn res "
        ],
        "pseudo": "# Define a recursive function count_sequences with parameters n (length of the binary sequence), \n# curr_sum (current sum of the bits), and total_sum (the target sum of both halves)\n\n    # Base case: if n is 0, check if the current sum is equal to the target sum\n        # If so, return 1 (valid sequence)\n        # Otherwise, return 0 (invalid sequence)\n    \n    # Recursive case:\n        # Initialize a variable count to 0 (to keep track of the count of valid sequences)\n        \n        # Call the count_sequences function recursively with n-1, curr_sum+1, and total_sum\n        # Add the return value to count\n        \n        # Call the count_sequences function recursively with n-1, curr_sum-1, and total_sum\n        # Add the return value to count\n        \n        # Return the total count\n    \n# Call the count_sequences function with n as the length of the binary sequence, curr_sum as 0, and total_sum as 0 to get the count of valid sequences",
        "test": [
            "assert math.isclose(count_binary_seq(1), 2.0, rel_tol=0.001)",
            "assert math.isclose(count_binary_seq(2), 6.0, rel_tol=0.001)",
            "assert math.isclose(count_binary_seq(3), 20.0, rel_tol=0.001)"
        ],
        "draft_plan": [
            "# Define a recursive function count_sequences with parameters n (length of the binary sequence), \n# curr_sum (current sum of the bits), and total_sum (the target sum of both halves)\n\n    # Base case: if n is 0, check if the current sum is equal to the target sum\n        # If so, return 1 (valid sequence)\n        # Otherwise, return 0 (invalid sequence)\n    \n    # Recursive case:\n        # Initialize a variable count to 0 (to keep track of the count of valid sequences)\n        \n        # Call the count_sequences function recursively with n-1, curr_sum+1, and total_sum\n        # Add the return value to count\n        \n        # Call the count_sequences function recursively with n-1, curr_sum-1, and total_sum\n        # Add the return value to count\n        \n        # Return the total count\n    \n# Call the count_sequences function with n as the length of the binary sequence, curr_sum as 0, and total_sum as 0 to get the count of valid sequences"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n\nint count_sequences(int n, int curr_sum, int total_sum) {\n    // Base case: when n is 0\n    if (n == 0) {\n        // Check if the current sum is equal to the target sum\n        if (curr_sum == total_sum) {\n            return 1; // Valid sequence\n        } else {\n            return 0; // Invalid sequence\n        }\n    }\n\n    // Recursive case\n    int count = 0;\n\n    // Call the count_sequences function recursively with n-1, curr_sum+1, and total_sum\n    count += count_sequences(n - 1, curr_sum + 1, total_sum);\n\n    // Call the count_sequences function recursively with n-1, curr_sum-1, and total_sum\n    count += count_sequences(n - 1, curr_sum - 1, total_sum);\n\n    return count;\n}\n\nint main() {\n    int n;\n    std::cout << \"Enter the value of n: \";\n    std::cin >> n;\n\n    int total_sum = 0;\n    int count = count_sequences(2 * n, 0, total_sum);\n\n    std::cout << \"Count of valid sequences: \" << count << std::endl;\n\n    return 0;\n}"
        ]
    },
    {
        "id": "301",
        "prompt": "Write a function to find the depth of a dictionary.",
        "solution": "def dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0",
        "code": [
            "def dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0"
        ],
        "pseudo": "# Initialize the depth to 1\n\n# Iterate through each key-value pair in the dictionary\n    # Check if the value is a dictionary\n        # If it is, recursively find the depth of the nested dictionary and increment it by 1\n\n# Return the maximum depth",
        "test": [
            "assert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4",
            "assert dict_depth({'a':1, 'b': {'c':'python'}})==2",
            "assert dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}})==3"
        ],
        "draft_plan": [
            "# Initialize the depth to 1\n\n# Iterate through each key-value pair in the dictionary\n    # Check if the value is a dictionary\n        # If it is, recursively find the depth of the nested dictionary and increment it by 1\n\n# Return the maximum depth"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint find_depth(std::map<std::string, std::variant<int, std::map<std::string, std::variant<int, std::map<std::string, std::variant<int>>>>>>> dictionary) {\n    int max_depth = 1;\n\n    for (const auto& [key, value] : dictionary) {\n        if (std::holds_alternative<std::map<std::string, std::variant<int, std::map<std::string, std::variant<int>>>>>>>>(value)) {\n            int nested_depth = find_depth(std::get<std::map<std::string, std::variant<int, std::map<std::string, std::variant<int>>>>>>>>(value)) + 1;\n            max_depth = std::max(max_depth, nested_depth);\n        }\n    }\n\n    return max_depth;\n}"
        ]
    },
    {
        "id": "304",
        "prompt": "Write a python function to find element at a given index after number of rotations.",
        "solution": "def find_Element(arr,ranges,rotations,index) :  \n    for i in range(rotations - 1,-1,-1 ) : \n        left = ranges[i][0] \n        right = ranges[i][1] \n        if (left <= index and right >= index) : \n            if (index == left) : \n                index = right \n            else : \n                index = index - 1 \n    return arr[index] ",
        "code": [
            "def find_Element(arr,ranges,rotations,index) :  \n    for i in range(rotations - 1,-1,-1 ) : \n        left = ranges[i][0] \n        right = ranges[i][1] \n        if (left <= index and right >= index) : \n            if (index == left) : \n                index = right \n            else : \n                index = index - 1 \n    return arr[index] "
        ],
        "pseudo": "# Calculate the effective rotations by taking the remainder of the given rotations divided by the length of the array\n\n# Return the element at the given index after applying the effective rotations\n",
        "test": [
            "assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3",
            "assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3",
            "assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1"
        ],
        "draft_plan": [
            "# Calculate the effective rotations by taking the remainder of the given rotations divided by the length of the array\n\n# Return the element at the given index after applying the effective rotations\n"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\nusing namespace std;\n\nint findElementAfterRotations(vector<int>& nums, int rotations, int index) {\n    int n = nums.size();\n    int effective_rotations = rotations % n;\n    int rotated_index = (index + n - effective_rotations) % n;\n\n    return nums[rotated_index];\n}"
        ]
    },
    {
        "id": "305",
        "prompt": "Write a function to return two words from a list of words starting with letter 'p'.",
        "solution": "import re\ndef start_withp(words):\n for w in words:\n        m = re.match(\"(P\\w+)\\W(P\\w+)\", w)\n        if m:\n            return m.groups()",
        "code": [
            "import re\ndef start_withp(words):\n for w in words:\n        m = re.match(\"(P\\w+)\\W(P\\w+)\", w)\n        if m:\n            return m.groups()"
        ],
        "pseudo": "# Initialize an empty list to store the words starting with 'p'\n\n# Iterate through each word in the list\n    # Check if the first letter of the word is 'p'\n        # If yes, append the word to the list\n\n# Check if the list has at least two words\n    # If yes, return the first two words from the list\n    # If no, return None or an appropriate message",
        "test": [
            "assert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"])==('Python', 'PHP')",
            "assert start_withp([\"Python Programming\",\"Java Programming\"])==('Python','Programming')",
            "assert start_withp([\"Pqrst Pqr\",\"qrstuv\"])==('Pqrst','Pqr')"
        ],
        "draft_plan": [
            "# Initialize an empty list to store the words starting with 'p'\n\n# Iterate through each word in the list\n    # Check if the first letter of the word is 'p'\n        # If yes, append the word to the list\n\n# Check if the list has at least two words\n    # If yes, return the first two words from the list\n    # If no, return None or an appropriate message"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> get_words_starting_with_p(std::vector<std::string> words) {\n    std::vector<std::string> p_words;\n\n    for (const std::string& word : words) {\n        if (word[0] == 'p' || word[0] == 'P') {\n            p_words.push_back(word);\n        }\n    }\n\n    if (p_words.size() >= 2) {\n        return {p_words[0], p_words[1]};\n    } else {\n        return {};\n    }\n}\n\nint main() {\n    std::vector<std::string> words = {\"apple\", \"banana\", \"pear\", \"peach\", \"plum\"};\n    std::vector<std::string> result = get_words_starting_with_p(words);\n\n    assert(result.size() == 2);\n    assert(result[0] == \"pear\");\n    assert(result[1] == \"peach\");\n\n    std::cout << \"Test cases pass\" << std::endl;\n\n    return 0;\n}"
        ]
    },
    {
        "id": "306",
        "prompt": "Write a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .",
        "solution": "def max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)] \n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif a[i] > a[0]:\n\t\t\tdp[0][i] = a[i] + a[0]\n\t\telse:\n\t\t\tdp[0][i] = a[i]\n\tfor i in range(1, n):\n\t\tfor j in range(n):\n\t\t\tif a[j] > a[i] and j > i:\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\n\t\t\t\telse:\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i - 1][j]\n\treturn dp[index][k]",
        "code": [
            "def max_sum_increasing_subseq(a, n, index, k):\n\tdp = [[0 for i in range(n)] \n\t\t\tfor i in range(n)]\n\tfor i in range(n):\n\t\tif a[i] > a[0]:\n\t\t\tdp[0][i] = a[i] + a[0]\n\t\telse:\n\t\t\tdp[0][i] = a[i]\n\tfor i in range(1, n):\n\t\tfor j in range(n):\n\t\t\tif a[j] > a[i] and j > i:\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\n\t\t\t\telse:\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\n\t\t\telse:\n\t\t\t\tdp[i][j] = dp[i - 1][j]\n\treturn dp[index][k]"
        ],
        "pseudo": "# Initialize a list to store the maximum sum of increasing subsequences for each index\n# Initialize the maximum sum to be 0\n\n# Iterate through each index i in the given list\n    # Initialize a variable to store the maximum sum of increasing subsequence until index i, including the kth element\n    # Iterate through each index k starting from i+1 to the end of the list\n        # Check if the element at index k is greater than the element at index i\n            # Update the maximum sum of increasing subsequence until index i, including the kth element\n    # Update the maximum sum if the maximum sum of increasing subsequence until index i, including the kth element, is greater than the current maximum sum\n\n# Return the maximum sum",
        "test": [
            "assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11",
            "assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 2, 5) == 7",
            "assert max_sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71"
        ],
        "draft_plan": [
            "# Initialize a list to store the maximum sum of increasing subsequences for each index\n# Initialize the maximum sum to be 0\n\n# Iterate through each index i in the given list\n    # Initialize a variable to store the maximum sum of increasing subsequence until index i, including the kth element\n    # Iterate through each index k starting from i+1 to the end of the list\n        # Check if the element at index k is greater than the element at index i\n            # Update the maximum sum of increasing subsequence until index i, including the kth element\n    # Update the maximum sum if the maximum sum of increasing subsequence until index i, including the kth element, is greater than the current maximum sum\n\n# Return the maximum sum"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n#include <assert.h>\n\nint find_max_sum(std::vector<int> nums) {\n    int n = nums.size();\n    std::vector<int> max_sum(n, 0);\n    int max_sum_value = 0;\n\n    for (int i = 0; i < n; i++) {\n        int curr_max_sum = nums[i];\n\n        for (int k = i + 1; k < n; k++) {\n            if (nums[k] > nums[i]) {\n                curr_max_sum += nums[k];\n            }\n        }\n\n        max_sum[i] = curr_max_sum;\n        max_sum_value = std::max(max_sum_value, curr_max_sum);\n    }\n\n    return max_sum_value;\n}"
        ]
    },
    {
        "id": "307",
        "prompt": "Write a function to get a colon of a tuple.",
        "solution": "from copy import deepcopy\ndef colon_tuplex(tuplex,m,n):\n  tuplex_colon = deepcopy(tuplex)\n  tuplex_colon[m].append(n)\n  return tuplex_colon",
        "code": [
            "from copy import deepcopy\ndef colon_tuplex(tuplex,m,n):\n  tuplex_colon = deepcopy(tuplex)\n  tuplex_colon[m].append(n)\n  return tuplex_colon"
        ],
        "pseudo": "To get a colon of a tuple, we can use tuple slicing. Here is the code logic:\n\n# Define a function that takes a tuple as input\ndef get_colon(tup):\n    # Use tuple slicing to get the colon\n    colon = tup[1]\n    return colon\n\n# Test the function\ntuple_example = (1, 2, 3, 4, 5)\nresult = get_colon(tuple_example)\nprint(result)  # Output: 2",
        "test": [
            "assert colon_tuplex((\"HELLO\", 5, [], True) ,2,50)==(\"HELLO\", 5, [50], True)",
            "assert colon_tuplex((\"HELLO\", 5, [], True) ,2,100)==((\"HELLO\", 5, [100],True))",
            "assert colon_tuplex((\"HELLO\", 5, [], True) ,2,500)==(\"HELLO\", 5, [500], True)"
        ],
        "draft_plan": [
            "To get a colon of a tuple, we can use tuple slicing. Here is the code logic:\n\n# Define a function that takes a tuple as input\ndef get_colon(tup):\n    # Use tuple slicing to get the colon\n    colon = tup[1]\n    return colon\n\n# Test the function\ntuple_example = (1, 2, 3, 4, 5)\nresult = get_colon(tuple_example)\nprint(result)  # Output: 2"
        ],
        "final_plan": [
            "C++ does not have a built-in tuple type, so we cannot directly access elements by index like we can with Python's tuple slicing. However, we can create a custom function to achieve a similar result. Here's an example:\n\n```cpp\n#include <iostream>\n#include <tuple>\n\ntemplate <typename T, typename... Args>\nT get_colon(const std::tuple<Args...>& tup) {\n    return std::get<1>(tup);\n}\n\nint main() {\n    std::tuple<int, int, int, int, int> tuple_example(1, 2, 3, 4, 5);\n    int result = get_colon<int>(tuple_example);\n    std::cout << result << std::endl;  // Output: 2\n\n    return 0;\n}\n```\n\nIn this code, we define a template function `get_colon` that takes a tuple as input and returns the second element of the tuple. We use the `std::get` function to access the tuple element by its index (1 in this case). The `main` function demonstrates how to use the `get_colon` function with a tuple of integers."
        ]
    },
    {
        "id": "308",
        "prompt": "Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.",
        "solution": "def large_product(nums1, nums2, N):\n    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\n    return result",
        "code": [
            "def large_product(nums1, nums2, N):\n    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\n    return result"
        ],
        "pseudo": "# Create an empty list to store the products\n\n# Iterate through each element in the first list\n    # Iterate through each element in the second list\n        # Calculate the product of the current elements from both lists\n        # Append the product to the list of products\n\n# Sort the list of products in descending order\n\n# Return the specified number of largest products from the list",
        "test": [
            "assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)==[60, 54, 50]",
            "assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],4)==[60, 54, 50, 48]",
            "assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],5)==[60, 54, 50, 48, 45]"
        ],
        "draft_plan": [
            "# Create an empty list to store the products\n\n# Iterate through each element in the first list\n    # Iterate through each element in the second list\n        # Calculate the product of the current elements from both lists\n        # Append the product to the list of products\n\n# Sort the list of products in descending order\n\n# Return the specified number of largest products from the list"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n#include <assert.h>\n\nstd::vector<int> find_largest_products(std::vector<int> list1, std::vector<int> list2, int n) {\n    std::vector<int> products;\n\n    for (int i = 0; i < list1.size(); i++) {\n        for (int j = 0; j < list2.size(); j++) {\n            products.push_back(list1[i] * list2[j]);\n        }\n    }\n\n    std::sort(products.begin(), products.end(), std::greater<int>());\n\n    std::vector<int> largest_products(products.begin(), products.begin() + n);\n\n    return largest_products;\n}"
        ]
    },
    {
        "id": "309",
        "prompt": "Write a python function to find the maximum of two numbers.",
        "solution": "def maximum(a,b):   \n    if a >= b: \n        return a \n    else: \n        return b ",
        "code": [
            "def maximum(a,b):   \n    if a >= b: \n        return a \n    else: \n        return b "
        ],
        "pseudo": "# Define a function that takes two numbers as input\n\n# Check if the first number is greater than the second number\n    # If it is, return the first number as the maximum\n    # Otherwise, return the second number as the maximum",
        "test": [
            "assert maximum(5,10) == 10",
            "assert maximum(-1,-2) == -1",
            "assert maximum(9,7) == 9"
        ],
        "draft_plan": [
            "# Define a function that takes two numbers as input\n\n# Check if the first number is greater than the second number\n    # If it is, return the first number as the maximum\n    # Otherwise, return the second number as the maximum"
        ],
        "final_plan": [
            "int find_maximum(int a, int b) {\n    if (a > b) {\n        return a;\n    } else {\n        return b;\n    }\n}"
        ]
    },
    {
        "id": "310",
        "prompt": "Write a function to convert a given string to a tuple of characters.",
        "solution": "def string_to_tuple(str1):\n    result = tuple(x for x in str1 if not x.isspace()) \n    return result",
        "code": [
            "def string_to_tuple(str1):\n    result = tuple(x for x in str1 if not x.isspace()) \n    return result"
        ],
        "pseudo": "# Initialize an empty tuple\n\n# Iterate through each character in the input string\n    # Append the character to the tuple\n\n# Return the tuple",
        "test": [
            "assert string_to_tuple(\"python 3.0\")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')",
            "assert string_to_tuple(\"item1\")==('i', 't', 'e', 'm', '1')",
            "assert string_to_tuple(\"15.10\")==('1', '5', '.', '1', '0')"
        ],
        "draft_plan": [
            "# Initialize an empty tuple\n\n# Iterate through each character in the input string\n    # Append the character to the tuple\n\n# Return the tuple"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n\nstd::tuple<char> convert_to_tuple(std::string input_string) {\n    std::tuple<char> result;\n\n    for (char c : input_string) {\n        std::get<0>(result) = c;\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "311",
        "prompt": "Write a python function to set the left most unset bit.",
        "solution": "def set_left_most_unset_bit(n): \n    if not (n & (n + 1)): \n        return n \n    pos, temp, count = 0, n, 0 \n    while temp: \n        if not (temp & 1): \n            pos = count      \n        count += 1; temp>>=1\n    return (n | (1 << (pos))) ",
        "code": [
            "def set_left_most_unset_bit(n): \n    if not (n & (n + 1)): \n        return n \n    pos, temp, count = 0, n, 0 \n    while temp: \n        if not (temp & 1): \n            pos = count      \n        count += 1; temp>>=1\n    return (n | (1 << (pos))) "
        ],
        "pseudo": "To find the leftmost unset bit in a given number, we can use the bitwise operators in Python. Here is the code logic:\n\n1. Create a function `leftmost_unset_bit(num)` that takes a number as input.\n\n2. Initialize a variable `position` as 1, which represents the position of the leftmost bit (starting from 1 for the least significant bit).\n\n3. Iterate through each bit position from right to left using a while loop:\n     - Check if the bit is unset (0) using the bitwise AND operation of the number and a mask (1 << position).\n     - If the bit is unset, return the current position.\n     - If the bit is set (1), increment the position by 1.\n\n4. If no unset bit is found after the loop, return -1 to indicate that no unset bit is present in the number.\n\nHere is the code implementation for the above logic:\n\n```python\ndef leftmost_unset_bit(num):\n    position = 1\n    while num:\n        if not (num & (1 << position)):\n            return position\n        position += 1\n    return -1\n```\n\nYou can then call the `leftmost_unset_bit()` function with a number as input to find the position of the leftmost unset bit.",
        "test": [
            "assert set_left_most_unset_bit(10) == 14",
            "assert set_left_most_unset_bit(12) == 14",
            "assert set_left_most_unset_bit(15) == 15"
        ],
        "draft_plan": [
            "To find the leftmost unset bit in a given number, we can use the bitwise operators in Python. Here is the code logic:\n\n1. Create a function `leftmost_unset_bit(num)` that takes a number as input.\n\n2. Initialize a variable `position` as 1, which represents the position of the leftmost bit (starting from 1 for the least significant bit).\n\n3. Iterate through each bit position from right to left using a while loop:\n     - Check if the bit is unset (0) using the bitwise AND operation of the number and a mask (1 << position).\n     - If the bit is unset, return the current position.\n     - If the bit is set (1), increment the position by 1.\n\n4. If no unset bit is found after the loop, return -1 to indicate that no unset bit is present in the number.\n\nHere is the code implementation for the above logic:\n\n```python\ndef leftmost_unset_bit(num):\n    position = 1\n    while num:\n        if not (num & (1 << position)):\n            return position\n        position += 1\n    return -1\n```\n\nYou can then call the `leftmost_unset_bit()` function with a number as input to find the position of the leftmost unset bit."
        ],
        "final_plan": [
            "Here is the C++ code for finding the leftmost unset bit in a given number:\n\n```cpp\n#include <iostream>\n\nint leftmost_unset_bit(int num) {\n    int position = 1;\n    while (num) {\n        if (!(num & (1 << position))) {\n            return position;\n        }\n        position++;\n    }\n    return -1;\n}\n\nint main() {\n    int num = 10;\n    int result = leftmost_unset_bit(num);\n    if (result != -1) {\n        std::cout << \"The leftmost unset bit position is: \" << result << std::endl;\n    } else {\n        std::cout << \"No unset bit found.\" << std::endl;\n    }\n    return 0;\n}\n```\n\nIn the `main()` function, you can modify the `num` variable to the desired number for which you want to find the leftmost unset bit. The program will output the position of the leftmost unset bit, or \"No unset bit found\" if no unset bit is present."
        ]
    },
    {
        "id": "312",
        "prompt": "Write a function to find the volume of a cone.",
        "solution": "import math\ndef volume_cone(r,h):\n  volume = (1.0/3) * math.pi * r * r * h\n  return volume",
        "code": [
            "import math\ndef volume_cone(r,h):\n  volume = (1.0/3) * math.pi * r * r * h\n  return volume"
        ],
        "pseudo": "# Define a function to calculate the volume of a cone\n    # Accept the radius and height of the cone as input parameters\n    # Calculate the volume using the formula V = (1/3) * \u03c0 * r^2 * h\n    # Return the calculated volume\n\n# Test the function by calling it with appropriate values for radius and height",
        "test": [
            "assert math.isclose(volume_cone(5,12), 314.15926535897927, rel_tol=0.001)",
            "assert math.isclose(volume_cone(10,15), 1570.7963267948965, rel_tol=0.001)",
            "assert math.isclose(volume_cone(19,17), 6426.651371693521, rel_tol=0.001)"
        ],
        "draft_plan": [
            "# Define a function to calculate the volume of a cone\n    # Accept the radius and height of the cone as input parameters\n    # Calculate the volume using the formula V = (1/3) * \u03c0 * r^2 * h\n    # Return the calculated volume\n\n# Test the function by calling it with appropriate values for radius and height"
        ],
        "final_plan": [
            "#include <iostream>\n#include <cmath>\n\ndouble calculate_volume_of_cone(double radius, double height) {\n    double volume = (1.0 / 3.0) * M_PI * pow(radius, 2) * height;\n    return volume;\n}\n\nint main() {\n    double radius = 3.0;\n    double height = 5.0;\n\n    double volume = calculate_volume_of_cone(radius, height);\n\n    std::cout << \"Volume of the cone: \" << volume << std::endl;\n\n    return 0;\n}"
        ]
    },
    {
        "id": "388",
        "prompt": "Write a python function to find the highest power of 2 that is less than or equal to n.",
        "solution": "def highest_Power_of_2(n): \n    res = 0 \n    for i in range(n, 0, -1): \n        if ((i & (i - 1)) == 0): \n            res = i \n            break \n    return res ",
        "code": [
            "def highest_Power_of_2(n): \n    res = 0 \n    for i in range(n, 0, -1): \n        if ((i & (i - 1)) == 0): \n            res = i \n            break \n    return res "
        ],
        "pseudo": "# Initialize the highest power of 2 to 1\n\n# While the highest power of 2 is less than or equal to n\n    # Multiply the highest power of 2 by 2\n\n# Divide the highest power of 2 by 2 to get the result",
        "test": [
            "assert highest_Power_of_2(10) == 8",
            "assert highest_Power_of_2(19) == 16",
            "assert highest_Power_of_2(32) == 32"
        ],
        "draft_plan": [
            "# Initialize the highest power of 2 to 1\n\n# While the highest power of 2 is less than or equal to n\n    # Multiply the highest power of 2 by 2\n\n# Divide the highest power of 2 by 2 to get the result"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n\nint highest_power_of_two(int n) {\n    int highest_power = 1;\n    while (highest_power <= n) {\n        highest_power *= 2;\n    }\n    return highest_power / 2;\n}\n\nint main() {\n    assert(highest_power_of_two(10) == 8);\n    assert(highest_power_of_two(16) == 16);\n    assert(highest_power_of_two(17) == 16);\n    assert(highest_power_of_two(32) == 32);\n    assert(highest_power_of_two(1) == 1);\n    assert(highest_power_of_two(0) == 0);\n    return 0;\n}"
        ]
    },
    {
        "id": "389",
        "prompt": "Write a function to find the n'th lucas number.",
        "solution": "def find_lucas(n): \n\tif (n == 0): \n\t\treturn 2\n\tif (n == 1): \n\t\treturn 1\n\treturn find_lucas(n - 1) + find_lucas(n - 2) ",
        "code": [
            "def find_lucas(n): \n\tif (n == 0): \n\t\treturn 2\n\tif (n == 1): \n\t\treturn 1\n\treturn find_lucas(n - 1) + find_lucas(n - 2) "
        ],
        "pseudo": "# Define a function to find the n-th Lucas number\ndef lucas_number(n):\n    # Base cases for n = 0 and n = 1\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Lucas numbers\n    lucas_0 = 2\n    lucas_1 = 1\n    \n    # Iterate from 2 to n\n    for i in range(2, n+1):\n        # Calculate the current Lucas number using the formula L(n) = L(n-1) + L(n-2)\n        lucas_n = lucas_0 + lucas_1\n        \n        # Update the values of previous Lucas numbers for the next iteration\n        lucas_0 = lucas_1\n        lucas_1 = lucas_n\n    \n    # Return the n-th Lucas number\n    return lucas_n",
        "test": [
            "assert find_lucas(9) == 76",
            "assert find_lucas(4) == 7",
            "assert find_lucas(3) == 4"
        ],
        "draft_plan": [
            "# Define a function to find the n-th Lucas number\ndef lucas_number(n):\n    # Base cases for n = 0 and n = 1\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Lucas numbers\n    lucas_0 = 2\n    lucas_1 = 1\n    \n    # Iterate from 2 to n\n    for i in range(2, n+1):\n        # Calculate the current Lucas number using the formula L(n) = L(n-1) + L(n-2)\n        lucas_n = lucas_0 + lucas_1\n        \n        # Update the values of previous Lucas numbers for the next iteration\n        lucas_0 = lucas_1\n        lucas_1 = lucas_n\n    \n    # Return the n-th Lucas number\n    return lucas_n"
        ],
        "final_plan": [
            "#include <assert.h>\n\nint lucas_number(int n) {\n    // Base cases for n = 0 and n = 1\n    if (n == 0) {\n        return 2;\n    } else if (n == 1) {\n        return 1;\n    }\n    \n    // Initialize the first two Lucas numbers\n    int lucas_0 = 2;\n    int lucas_1 = 1;\n    \n    // Iterate from 2 to n\n    for (int i = 2; i <= n; i++) {\n        // Calculate the current Lucas number using the formula L(n) = L(n-1) + L(n-2)\n        int lucas_n = lucas_0 + lucas_1;\n        \n        // Update the values of previous Lucas numbers for the next iteration\n        lucas_0 = lucas_1;\n        lucas_1 = lucas_n;\n    }\n    \n    // Return the n-th Lucas number\n    return lucas_n;\n}"
        ]
    },
    {
        "id": "390",
        "prompt": "Write a function to apply a given format string to all of the elements in a list.",
        "solution": "def add_string(list_, string):\n add_string=[string.format(i) for i in  list_]\n return add_string",
        "code": [
            "def add_string(list_, string):\n add_string=[string.format(i) for i in  list_]\n return add_string"
        ],
        "pseudo": "# Define a function that takes a format string and a list of elements as input\n\n# Create an empty list to store the formatted elements\n\n# Iterate through each element in the input list\n    # Apply the format string to the current element using the format() function\n    # Append the formatted element to the new list\n\n# Return the new list with all the formatted elements",
        "test": [
            "assert add_string([1,2,3,4],'temp{0}')==['temp1', 'temp2', 'temp3', 'temp4']",
            "assert add_string(['a','b','c','d'], 'python{0}')==[ 'pythona', 'pythonb', 'pythonc', 'pythond']",
            "assert add_string([5,6,7,8],'string{0}')==['string5', 'string6', 'string7', 'string8']"
        ],
        "draft_plan": [
            "# Define a function that takes a format string and a list of elements as input\n\n# Create an empty list to store the formatted elements\n\n# Iterate through each element in the input list\n    # Apply the format string to the current element using the format() function\n    # Append the formatted element to the new list\n\n# Return the new list with all the formatted elements"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\ntemplate<typename T>\nstd::vector<std::string> apply_format(const std::string& format_string, const std::vector<T>& elements) {\n    std::vector<std::string> formatted_elements;\n    \n    for (const auto& element : elements) {\n        std::stringstream ss;\n        ss << std::format(format_string, element);\n        formatted_elements.push_back(ss.str());\n    }\n    \n    return formatted_elements;\n}"
        ]
    },
    {
        "id": "391",
        "prompt": "Write a function to convert more than one list to nested dictionary.",
        "solution": "def convert_list_dictionary(l1, l2, l3):\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\n     return result",
        "code": [
            "def convert_list_dictionary(l1, l2, l3):\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\n     return result"
        ],
        "pseudo": "# Initialize an empty dictionary\n\n# Iterate through each list in the input lists\n    # Get the first element of the list as the key for the nested dictionary\n    # Get the remaining elements of the list as the values for the nested dictionary\n    # Create a nested dictionary using the key and values\n\n# Return the nested dictionary",
        "test": [
            "assert convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"],[\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"] ,[85, 98, 89, 92])==[{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]",
            "assert convert_list_dictionary([\"abc\",\"def\",\"ghi\",\"jkl\"],[\"python\",\"program\",\"language\",\"programs\"],[100,200,300,400])==[{'abc':{'python':100}},{'def':{'program':200}},{'ghi':{'language':300}},{'jkl':{'programs':400}}]",
            "assert convert_list_dictionary([\"A1\",\"A2\",\"A3\",\"A4\"],[\"java\",\"C\",\"C++\",\"DBMS\"],[10,20,30,40])==[{'A1':{'java':10}},{'A2':{'C':20}},{'A3':{'C++':30}},{'A4':{'DBMS':40}}]"
        ],
        "draft_plan": [
            "# Initialize an empty dictionary\n\n# Iterate through each list in the input lists\n    # Get the first element of the list as the key for the nested dictionary\n    # Get the remaining elements of the list as the values for the nested dictionary\n    # Create a nested dictionary using the key and values\n\n# Return the nested dictionary"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n#include <assert.h>\n\ntemplate<typename T>\nstd::map<T, std::map<T, T>> convert_to_nested_dictionary(std::vector<std::vector<T>> input_lists) {\n    std::map<T, std::map<T, T>> nested_dict;\n\n    for (const auto& lst : input_lists) {\n        if (lst.empty()) {\n            continue;\n        }\n\n        T key = lst[0];\n        std::vector<T> values(lst.begin() + 1, lst.end());\n\n        std::map<T, T> nested_dict_values;\n        for (const auto& value : values) {\n            nested_dict_values[value] = value;\n        }\n\n        nested_dict[key] = nested_dict_values;\n    }\n\n    return nested_dict;\n}"
        ]
    },
    {
        "id": "392",
        "prompt": "Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).",
        "solution": "def get_max_sum (n):\n\tres = list()\n\tres.append(0)\n\tres.append(1)\n\ti = 2\n\twhile i<n + 1:\n\t\tres.append(max(i, (res[int(i / 2)] \n\t\t\t\t\t\t+ res[int(i / 3)] +\n\t\t\t\t\t\t\tres[int(i / 4)]\n\t\t\t\t\t\t+ res[int(i / 5)])))\n\t\ti = i + 1\n\treturn res[n]",
        "code": [
            "def get_max_sum (n):\n\tres = list()\n\tres.append(0)\n\tres.append(1)\n\ti = 2\n\twhile i<n + 1:\n\t\tres.append(max(i, (res[int(i / 2)] \n\t\t\t\t\t\t+ res[int(i / 3)] +\n\t\t\t\t\t\t\tres[int(i / 4)]\n\t\t\t\t\t\t+ res[int(i / 5)])))\n\t\ti = i + 1\n\treturn res[n]"
        ],
        "pseudo": "# Create a dictionary to store the maximum sum for each number\n# Set the base cases for f(0) and f(1) as 0 and 1 respectively\n\n# Define a recursive function to calculate the maximum sum for a given number\n    # Check if the maximum sum for the current number has already been calculated\n        # If yes, return the stored value\n        # If no, calculate the maximum sum using the given equation\n\n# Call the recursive function to calculate the maximum sum for the given number",
        "test": [
            "assert get_max_sum(60) == 106",
            "assert get_max_sum(10) == 12",
            "assert get_max_sum(2) == 2"
        ],
        "draft_plan": [
            "# Create a dictionary to store the maximum sum for each number\n# Set the base cases for f(0) and f(1) as 0 and 1 respectively\n\n# Define a recursive function to calculate the maximum sum for a given number\n    # Check if the maximum sum for the current number has already been calculated\n        # If yes, return the stored value\n        # If no, calculate the maximum sum using the given equation\n\n# Call the recursive function to calculate the maximum sum for the given number"
        ],
        "final_plan": [
            "#include<bits/stdc++.h>\n\nstd::unordered_map<int, long long> max_sum_cache;\n\nlong long calculate_max_sum(int n) {\n    if (n == 0)\n        return 0;\n    if (n == 1)\n        return 1;\n    \n    if (max_sum_cache.find(n) != max_sum_cache.end())\n        return max_sum_cache[n];\n\n    long long max_sum = std::max((calculate_max_sum(n/2) + calculate_max_sum(n/3) + calculate_max_sum(n/4) + calculate_max_sum(n/5)), (long long)n);\n    max_sum_cache[n] = max_sum;\n    return max_sum;\n}\n\nlong long find_maximum_sum(int n) {\n    return calculate_max_sum(n);\n}"
        ]
    },
    {
        "id": "393",
        "prompt": "Write a function to find the list with maximum length.",
        "solution": "def max_length_list(input_list):\n    max_length = max(len(x) for x in input_list )   \n    max_list = max(input_list, key = lambda i: len(i))    \n    return(max_length, max_list)",
        "code": [
            "def max_length_list(input_list):\n    max_length = max(len(x) for x in input_list )   \n    max_list = max(input_list, key = lambda i: len(i))    \n    return(max_length, max_list)"
        ],
        "pseudo": "# Initialize the maximum length and the list with maximum length to empty values\n\n# Iterate through each list in the input list of lists\n    # Check if the length of the current list is greater than the maximum length\n        # If so, update the maximum length and the list with maximum length\n\n# Return the list with maximum length",
        "test": [
            "assert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])",
            "assert max_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(5,[1,2,3,4,5])",
            "assert max_length_list([[3,4,5],[6,7,8,9],[10,11,12]])==(4,[6,7,8,9])"
        ],
        "draft_plan": [
            "# Initialize the maximum length and the list with maximum length to empty values\n\n# Iterate through each list in the input list of lists\n    # Check if the length of the current list is greater than the maximum length\n        # If so, update the maximum length and the list with maximum length\n\n# Return the list with maximum length"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<int> find_max_length_list(std::vector<std::vector<int>> input_list) {\n    int max_length = 0;\n    std::vector<int> max_length_list;\n\n    for (const auto& lst : input_list) {\n        if (lst.size() > max_length) {\n            max_length = lst.size();\n            max_length_list = lst;\n        }\n    }\n\n    return max_length_list;\n}"
        ]
    },
    {
        "id": "394",
        "prompt": "Write a function to check if given tuple contains no duplicates.",
        "solution": "def check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res ",
        "code": [
            "def check_distinct(test_tup):\n  res = True\n  temp = set()\n  for ele in test_tup:\n    if ele in temp:\n      res = False\n      break\n    temp.add(ele)\n  return res "
        ],
        "pseudo": "# Convert the tuple to a set\n# Check if the length of the set is equal to the length of the tuple\n    # If they are equal, it means there are no duplicates\n    # Otherwise, there are duplicates",
        "test": [
            "assert check_distinct((1, 4, 5, 6, 1, 4)) == False",
            "assert check_distinct((1, 4, 5, 6)) == True",
            "assert check_distinct((2, 3, 4, 5, 6)) == True"
        ],
        "draft_plan": [
            "# Convert the tuple to a set\n# Check if the length of the set is equal to the length of the tuple\n    # If they are equal, it means there are no duplicates\n    # Otherwise, there are duplicates"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\ntemplate<typename T>\nbool contains_no_duplicates(const std::tuple<T...>& tup) {\n    std::set<T> unique_elements;\n\n    for (const auto& elem : tup) {\n        if (unique_elements.count(elem) > 0) {\n            return false;\n        }\n        unique_elements.insert(elem);\n    }\n\n    return true;\n}"
        ]
    },
    {
        "id": "395",
        "prompt": "Write a python function to find the first non-repeated character in a given string.",
        "solution": "def first_non_repeating_character(str1):\n  char_order = []\n  ctr = {}\n  for c in str1:\n    if c in ctr:\n      ctr[c] += 1\n    else:\n      ctr[c] = 1 \n      char_order.append(c)\n  for c in char_order:\n    if ctr[c] == 1:\n      return c\n  return None",
        "code": [
            "def first_non_repeating_character(str1):\n  char_order = []\n  ctr = {}\n  for c in str1:\n    if c in ctr:\n      ctr[c] += 1\n    else:\n      ctr[c] = 1 \n      char_order.append(c)\n  for c in char_order:\n    if ctr[c] == 1:\n      return c\n  return None"
        ],
        "pseudo": "# Create an empty dictionary to store the count of each character\n# Iterate through each character in the given string\n    # If the character is already in the dictionary, increase its count by 1\n    # If the character is not in the dictionary, add it with a count of 1\n\n# Iterate through each character in the given string again\n    # Check if the count of the current character in the dictionary is 1\n        # If it is, return the current character as the first non-repeated character\n\n# If no non-repeated character is found, return \"None\"",
        "test": [
            "assert first_non_repeating_character(\"abcabc\") == None",
            "assert first_non_repeating_character(\"abc\") == \"a\"",
            "assert first_non_repeating_character(\"ababc\") == \"c\""
        ],
        "draft_plan": [
            "# Create an empty dictionary to store the count of each character\n# Iterate through each character in the given string\n    # If the character is already in the dictionary, increase its count by 1\n    # If the character is not in the dictionary, add it with a count of 1\n\n# Iterate through each character in the given string again\n    # Check if the count of the current character in the dictionary is 1\n        # If it is, return the current character as the first non-repeated character\n\n# If no non-repeated character is found, return \"None\""
        ],
        "final_plan": [
            "Here's the C++ code for finding the first non-repeated character in a given string:\n\n```cpp\n#include <iostream>\n#include <unordered_map>\n\nchar first_non_repeated_char(std::string text) {\n    std::unordered_map<char, int> char_count;\n\n    // Count the frequency of each character in the string\n    for (char ch : text) {\n        char_count[ch]++;\n    }\n\n    // Iterate through each character in the string again\n    for (char ch : text) {\n        // Check if the count of the current character is 1\n        if (char_count[ch] == 1) {\n            return ch;\n        }\n    }\n\n    // If no non-repeated character is found, return '\\0'\n    return '\\0';\n}\n\nint main() {\n    std::string text = \"hello world\";\n    char result = first_non_repeated_char(text);\n    if (result != '\\0') {\n        std::cout << \"First non-repeated character: \" << result << std::endl;\n    } else {\n        std::cout << \"No non-repeated character found.\" << std::endl;\n    }\n    return 0;\n}\n```\nNote: In C++, the null character '\\0' is used to represent the absence of a value."
        ]
    },
    {
        "id": "396",
        "prompt": "Write a function to check whether the given string starts and ends with the same character or not.",
        "solution": "import re  \nregex = r'^[a-z]$|^([a-z]).*\\1$'\ndef check_char(string): \n\tif(re.search(regex, string)): \n\t\treturn \"Valid\" \n\telse: \n\t\treturn \"Invalid\" ",
        "code": [
            "import re  \nregex = r'^[a-z]$|^([a-z]).*\\1$'\ndef check_char(string): \n\tif(re.search(regex, string)): \n\t\treturn \"Valid\" \n\telse: \n\t\treturn \"Invalid\" "
        ],
        "pseudo": "# Check if the first character of the string is equal to the last character\n    # If they are equal, return True\n    # If they are not equal, return False",
        "test": [
            "assert check_char(\"abba\") == \"Valid\"",
            "assert check_char(\"a\") == \"Valid\"",
            "assert check_char(\"abcd\") == \"Invalid\""
        ],
        "draft_plan": [
            "# Check if the first character of the string is equal to the last character\n    # If they are equal, return True\n    # If they are not equal, return False"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <string>\n\nbool check_start_end_same(const std::string& str) {\n    if (str.empty()) {\n        return false;\n    }\n    return str.front() == str.back();\n}"
        ]
    },
    {
        "id": "397",
        "prompt": "Write a function to find the median of three numbers.",
        "solution": "def median_numbers(a,b,c):\n if a > b:\n    if a < c:\n        median = a\n    elif b > c:\n        median = b\n    else:\n        median = c\n else:\n    if a > c:\n        median = a\n    elif b < c:\n        median = b\n    else:\n        median = c\n return median",
        "code": [
            "def median_numbers(a,b,c):\n if a > b:\n    if a < c:\n        median = a\n    elif b > c:\n        median = b\n    else:\n        median = c\n else:\n    if a > c:\n        median = a\n    elif b < c:\n        median = b\n    else:\n        median = c\n return median"
        ],
        "pseudo": "# Sort the three numbers in ascending order\n\n# If the middle number is an integer, return it as the median\n# Otherwise, calculate the average of the two middle numbers and return it as the median",
        "test": [
            "assert median_numbers(25,55,65)==55.0",
            "assert median_numbers(20,10,30)==20.0",
            "assert median_numbers(15,45,75)==45.0"
        ],
        "draft_plan": [
            "# Sort the three numbers in ascending order\n\n# If the middle number is an integer, return it as the median\n# Otherwise, calculate the average of the two middle numbers and return it as the median"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n\ndouble find_median(double a, double b, double c) {\n    std::vector<double> nums = {a, b, c};\n    std::sort(nums.begin(), nums.end());\n\n    if (nums[1] == floor(nums[1])) {\n        return nums[1];\n    } else {\n        return (nums[1] + nums[2]) / 2.0;\n    }\n}"
        ]
    },
    {
        "id": "398",
        "prompt": "Write a function to compute the sum of digits of each number of a given list.",
        "solution": "def sum_of_digits(nums):\n    return sum(int(el) for n in nums for el in str(n) if el.isdigit())",
        "code": [
            "def sum_of_digits(nums):\n    return sum(int(el) for n in nums for el in str(n) if el.isdigit())"
        ],
        "pseudo": "# Initialize an empty list to store the sum of digits for each number\n\n# Iterate through each number in the given list\n    # Convert the number to a string\n    # Initialize a variable to store the sum of digits\n    # Iterate through each digit in the string representation of the number\n        # Convert the digit back to an integer and add it to the sum of digits\n    # Append the sum of digits to the list\n\n# Return the list of sum of digits for each number",
        "test": [
            "assert sum_of_digits([10,2,56])==14",
            "assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19",
            "assert sum_of_digits([10,20,-4,5,-70])==19"
        ],
        "draft_plan": [
            "# Initialize an empty list to store the sum of digits for each number\n\n# Iterate through each number in the given list\n    # Convert the number to a string\n    # Initialize a variable to store the sum of digits\n    # Iterate through each digit in the string representation of the number\n        # Convert the digit back to an integer and add it to the sum of digits\n    # Append the sum of digits to the list\n\n# Return the list of sum of digits for each number"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\nstd::vector<int> sum_of_digits(std::vector<int> num_list) {\n    std::vector<int> sum_list;\n\n    for (int num : num_list) {\n        std::string num_str = std::to_string(num);\n        int digit_sum = 0;\n\n        for (char digit : num_str) {\n            digit_sum += digit - '0';\n        }\n\n        sum_list.push_back(digit_sum);\n    }\n\n    return sum_list;\n}"
        ]
    },
    {
        "id": "399",
        "prompt": "Write a function to perform the mathematical bitwise xor operation across the given tuples.",
        "solution": "def bitwise_xor(test_tup1, test_tup2):\n  res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) ",
        "code": [
            "def bitwise_xor(test_tup1, test_tup2):\n  res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) "
        ],
        "pseudo": "# Initialize an empty list to store the result of bitwise XOR operation on each tuple\n\n# Iterate through each tuple in the input list\n    # Initialize a variable to store the result of XOR operation\n    # Iterate through each element in the tuple\n        # Perform bitwise XOR operation with the current element and the result variable\n    # Append the result of XOR operation to the result list\n\n# Return the result list",
        "test": [
            "assert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)",
            "assert bitwise_xor((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)",
            "assert bitwise_xor((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)"
        ],
        "draft_plan": [
            "# Initialize an empty list to store the result of bitwise XOR operation on each tuple\n\n# Iterate through each tuple in the input list\n    # Initialize a variable to store the result of XOR operation\n    # Iterate through each element in the tuple\n        # Perform bitwise XOR operation with the current element and the result variable\n    # Append the result of XOR operation to the result list\n\n# Return the result list"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<int> perform_bitwise_xor(std::vector<std::tuple<int, int>> tuples) {\n    std::vector<int> result;\n\n    for (const auto& tup : tuples) {\n        int xor_result = 0;\n        for (const auto& elem : tup) {\n            xor_result ^= elem;\n        }\n        result.push_back(xor_result);\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "400",
        "prompt": "Write a function to extract the number of unique tuples in the given list.",
        "solution": "def extract_freq(test_list):\n  res = len(list(set(tuple(sorted(sub)) for sub in test_list)))\n  return (res)",
        "code": [
            "def extract_freq(test_list):\n  res = len(list(set(tuple(sorted(sub)) for sub in test_list)))\n  return (res)"
        ],
        "pseudo": "# Create an empty set to store unique tuples\n\n# Iterate through each tuple in the given list\n    # Convert the tuple to a frozenset and add it to the set of unique tuples\n\n# Return the length of the set of unique tuples",
        "test": [
            "assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3",
            "assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4",
            "assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4"
        ],
        "draft_plan": [
            "# Create an empty set to store unique tuples\n\n# Iterate through each tuple in the given list\n    # Convert the tuple to a frozenset and add it to the set of unique tuples\n\n# Return the length of the set of unique tuples"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint count_unique_tuples(std::vector<std::tuple<int, int, int>> lst) {\n    std::set<std::tuple<int, int, int>> unique_tuples;\n\n    for (const auto& tup : lst) {\n        unique_tuples.insert(tup);\n    }\n\n    return unique_tuples.size();\n}"
        ]
    },
    {
        "id": "401",
        "prompt": "Write a function to perform index wise addition of tuple elements in the given two nested tuples.",
        "solution": "def add_nested_tuples(test_tup1, test_tup2):\n  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ",
        "code": [
            "def add_nested_tuples(test_tup1, test_tup2):\n  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) "
        ],
        "pseudo": "# Create an empty result tuple\n\n# Iterate through the nested tuples, getting each inner tuple\n    # Iterate through the inner tuples, getting each element and its index\n        # Check if the index is within the range of the result tuple\n            # If it is, add the element at the corresponding index to the current element\n            # Create a new tuple with the updated element and append it to the result tuple\n        # If the index is not within the range of the result tuple\n            # Create a new tuple with only the current element and append it to the result tuple\n\n# Return the result tuple",
        "test": [
            "assert add_nested_tuples(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((7, 10), (7, 14), (3, 10), (8, 13))",
            "assert add_nested_tuples(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((9, 12), (9, 16), (5, 12), (10, 15))",
            "assert add_nested_tuples(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((11, 14), (11, 18), (7, 14), (12, 17))"
        ],
        "draft_plan": [
            "# Create an empty result tuple\n\n# Iterate through the nested tuples, getting each inner tuple\n    # Iterate through the inner tuples, getting each element and its index\n        # Check if the index is within the range of the result tuple\n            # If it is, add the element at the corresponding index to the current element\n            # Create a new tuple with the updated element and append it to the result tuple\n        # If the index is not within the range of the result tuple\n            # Create a new tuple with only the current element and append it to the result tuple\n\n# Return the result tuple"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::tuple<int, int, int> add_tuples(std::tuple<std::tuple<int, int, int>, std::tuple<int, int, int>> tuple1, std::tuple<std::tuple<int, int, int>, std::tuple<int, int, int>> tuple2) {\n    std::tuple<int, int, int> result;\n    std::get<0>(result) = std::get<0>(std::get<0>(tuple1)) + std::get<0>(std::get<0>(tuple2));\n    std::get<1>(result) = std::get<1>(std::get<0>(tuple1)) + std::get<1>(std::get<0>(tuple2));\n    std::get<2>(result) = std::get<2>(std::get<0>(tuple1)) + std::get<2>(std::get<0>(tuple2));\n\n    return result;\n}"
        ]
    },
    {
        "id": "404",
        "prompt": "Write a python function to find the minimum of two numbers.",
        "solution": "def minimum(a,b):   \n    if a <= b: \n        return a \n    else: \n        return b ",
        "code": [
            "def minimum(a,b):   \n    if a <= b: \n        return a \n    else: \n        return b "
        ],
        "pseudo": "# Define a function to find the minimum of two numbers\n    # Check if the first number is less than the second number\n        # If true, return the first number\n        # If false, return the second number\n\n# Call the function and pass two numbers as arguments",
        "test": [
            "assert minimum(1,2) == 1",
            "assert minimum(-5,-4) == -5",
            "assert minimum(0,0) == 0"
        ],
        "draft_plan": [
            "# Define a function to find the minimum of two numbers\n    # Check if the first number is less than the second number\n        # If true, return the first number\n        # If false, return the second number\n\n# Call the function and pass two numbers as arguments"
        ],
        "final_plan": [
            "int find_minimum(int num1, int num2) {\n    if (num1 < num2) {\n        return num1;\n    } else {\n        return num2;\n    }\n}"
        ]
    },
    {
        "id": "405",
        "prompt": "Write a function to check whether an element exists within a tuple.",
        "solution": "def check_tuplex(tuplex,tuple1): \n  if tuple1 in tuplex:\n    return True\n  else:\n     return False",
        "code": [
            "def check_tuplex(tuplex,tuple1): \n  if tuple1 in tuplex:\n    return True\n  else:\n     return False"
        ],
        "pseudo": "# Iterate through each element in the tuple\n    # Check if the current element is equal to the target element\n        # If the element is found, return True\n\n# If the element is not found, return False",
        "test": [
            "assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'r')==True",
            "assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'5')==False",
            "assert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\",\"e\"),3)==True"
        ],
        "draft_plan": [
            "# Iterate through each element in the tuple\n    # Check if the current element is equal to the target element\n        # If the element is found, return True\n\n# If the element is not found, return False"
        ],
        "final_plan": [
            "#include<assert.h>\n#include<bits/stdc++.h>\n\ntemplate<typename T, typename U>\nbool element_exists(const std::tuple<T, U>& tuple, const T& element) {\n    for (size_t i = 0; i < std::tuple_size<decltype(tuple)>::value; ++i) {\n        if (std::get<T>(tuple) == element) {\n            return true;\n        }\n    }\n    return false;\n}"
        ]
    },
    {
        "id": "406",
        "prompt": "Write a python function to find whether the parity of a given number is odd.",
        "solution": "def find_Parity(x): \n    y = x ^ (x >> 1); \n    y = y ^ (y >> 2); \n    y = y ^ (y >> 4); \n    y = y ^ (y >> 8); \n    y = y ^ (y >> 16); \n    if (y & 1): \n        return True\n    return False",
        "code": [
            "def find_Parity(x): \n    y = x ^ (x >> 1); \n    y = y ^ (y >> 2); \n    y = y ^ (y >> 4); \n    y = y ^ (y >> 8); \n    y = y ^ (y >> 16); \n    if (y & 1): \n        return True\n    return False"
        ],
        "pseudo": "# Check if the number modulo 2 is equal to 1\n    # If the modulo is 1, the number is odd\n    # Return True\n\n# If the modulo is not 1, the number is even\n# Return False",
        "test": [
            "assert find_Parity(12) == False",
            "assert find_Parity(7) == True",
            "assert find_Parity(10) == False"
        ],
        "draft_plan": [
            "# Check if the number modulo 2 is equal to 1\n    # If the modulo is 1, the number is odd\n    # Return True\n\n# If the modulo is not 1, the number is even\n# Return False"
        ],
        "final_plan": [
            "#include <cassert>\n\nbool is_odd_parity(int number) {\n    return (number % 2 == 1);\n}"
        ]
    },
    {
        "id": "407",
        "prompt": "Write a function to create the next bigger number by rearranging the digits of a given number.",
        "solution": "def rearrange_bigger(n):\n    nums = list(str(n))\n    for i in range(len(nums)-2,-1,-1):\n        if nums[i] < nums[i+1]:\n            z = nums[i:]\n            y = min(filter(lambda x: x > z[0], z))\n            z.remove(y)\n            z.sort()\n            nums[i:] = [y] + z\n            return int(\"\".join(nums))\n    return False",
        "code": [
            "def rearrange_bigger(n):\n    nums = list(str(n))\n    for i in range(len(nums)-2,-1,-1):\n        if nums[i] < nums[i+1]:\n            z = nums[i:]\n            y = min(filter(lambda x: x > z[0], z))\n            z.remove(y)\n            z.sort()\n            nums[i:] = [y] + z\n            return int(\"\".join(nums))\n    return False"
        ],
        "pseudo": "# Convert the given number to a list of digits\n\n# Find the first index (from right to left) where the digit is smaller than the digit to its right\n    # If no such index is found, return \"None\" since the number is already the largest possible\n\n# Find the smallest digit to the right of the found index that is larger than the digit at the found index\n\n# Swap the found digit with the smallest larger digit to its right\n\n# Sort the digits to the right of the found index in ascending order\n\n# Concatenate the digits to form the next bigger number\n\n# Return the next bigger number",
        "test": [
            "assert rearrange_bigger(12)==21",
            "assert rearrange_bigger(10)==False",
            "assert rearrange_bigger(102)==120"
        ],
        "draft_plan": [
            "# Convert the given number to a list of digits\n\n# Find the first index (from right to left) where the digit is smaller than the digit to its right\n    # If no such index is found, return \"None\" since the number is already the largest possible\n\n# Find the smallest digit to the right of the found index that is larger than the digit at the found index\n\n# Swap the found digit with the smallest larger digit to its right\n\n# Sort the digits to the right of the found index in ascending order\n\n# Concatenate the digits to form the next bigger number\n\n# Return the next bigger number"
        ],
        "final_plan": [
            "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <sstream>\n\nstd::string create_next_bigger_number(int number) {\n    // Convert the given number to a list of digits\n    std::string number_str = std::to_string(number);\n    std::vector<int> digits;\n    for (char digit_char : number_str) {\n        digits.push_back(digit_char - '0');\n    }\n\n    // Find the first index where the digit is smaller than the digit to its right\n    int i;\n    for (i = digits.size() - 2; i >= 0; i--) {\n        if (digits[i] < digits[i + 1]) {\n            break;\n        }\n    }\n\n    // If no such index is found, return \"None\"\n    if (i == -1) {\n        return \"None\";\n    }\n\n    // Find the smallest digit to the right of the found index that is larger than the digit at the found index\n    int j;\n    for (j = digits.size() - 1; j > i; j--) {\n        if (digits[j] > digits[i]) {\n            break;\n        }\n    }\n\n    // Swap the found digit with the smallest larger digit to its right\n    std::swap(digits[i], digits[j]);\n\n    // Sort the digits to the right of the found index in ascending order\n    std::sort(digits.begin() + i + 1, digits.end());\n\n    // Concatenate the digits to form the next bigger number\n    std::stringstream ss;\n    for (int digit : digits) {\n        ss << digit;\n    }\n\n    // Return the next bigger number\n    return ss.str();\n}"
        ]
    },
    {
        "id": "408",
        "prompt": "Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.",
        "solution": "import heapq\ndef k_smallest_pairs(nums1, nums2, k):\n   queue = []\n   def push(i, j):\n       if i < len(nums1) and j < len(nums2):\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\n   push(0, 0)\n   pairs = []\n   while queue and len(pairs) < k:\n       _, i, j = heapq.heappop(queue)\n       pairs.append([nums1[i], nums2[j]])\n       push(i, j + 1)\n       if j == 0:\n           push(i + 1, 0)\n   return pairs",
        "code": [
            "import heapq\ndef k_smallest_pairs(nums1, nums2, k):\n   queue = []\n   def push(i, j):\n       if i < len(nums1) and j < len(nums2):\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\n   push(0, 0)\n   pairs = []\n   while queue and len(pairs) < k:\n       _, i, j = heapq.heappop(queue)\n       pairs.append([nums1[i], nums2[j]])\n       push(i, j + 1)\n       if j == 0:\n           push(i + 1, 0)\n   return pairs"
        ],
        "pseudo": "# Create an empty list to store the pairs\n\n# Sort both arrays in ascending order\n\n# Iterate through each element in the first array\n    # Iterate through each element in the second array\n        # Add the pair (first_array[i], second_array[j]) to the list of pairs\n\n# Sort the list of pairs based on the sum of the elements in each pair\n\n# Return the first k pairs from the sorted list",
        "test": [
            "assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]",
            "assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]",
            "assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]"
        ],
        "draft_plan": [
            "# Create an empty list to store the pairs\n\n# Sort both arrays in ascending order\n\n# Iterate through each element in the first array\n    # Iterate through each element in the second array\n        # Add the pair (first_array[i], second_array[j]) to the list of pairs\n\n# Sort the list of pairs based on the sum of the elements in each pair\n\n# Return the first k pairs from the sorted list"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<std::pair<int, int>> find_smallest_pairs(std::vector<int>& first_array, std::vector<int>& second_array, int k) {\n    std::vector<std::pair<int, int>> pairs;\n    std::sort(first_array.begin(), first_array.end());\n    std::sort(second_array.begin(), second_array.end());\n\n    for (int i = 0; i < first_array.size(); i++) {\n        for (int j = 0; j < second_array.size(); j++) {\n            pairs.push_back(std::make_pair(first_array[i], second_array[j]));\n        }\n    }\n\n    std::sort(pairs.begin(), pairs.end(), [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n        return a.first + a.second < b.first + b.second;\n    });\n\n    return std::vector<std::pair<int, int>>(pairs.begin(), pairs.begin() + k);\n}"
        ]
    },
    {
        "id": "409",
        "prompt": "Write a function to find the minimum product from the pairs of tuples within a given list.",
        "solution": "def min_product_tuple(list1):\n    result_min = min([abs(x * y) for x, y in list1] )\n    return result_min",
        "code": [
            "def min_product_tuple(list1):\n    result_min = min([abs(x * y) for x, y in list1] )\n    return result_min"
        ],
        "pseudo": "# Initialize the minimum product to positive infinity\n\n# Iterate through each pair of tuples in the list\n    # Calculate the product of the two tuples\n    # Check if the product is less than the current minimum product\n        # If yes, update the minimum product\n\n# Return the minimum product",
        "test": [
            "assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==8",
            "assert min_product_tuple([(10,20), (15,2), (5,10)] )==30",
            "assert min_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==100"
        ],
        "draft_plan": [
            "# Initialize the minimum product to positive infinity\n\n# Iterate through each pair of tuples in the list\n    # Calculate the product of the two tuples\n    # Check if the product is less than the current minimum product\n        # If yes, update the minimum product\n\n# Return the minimum product"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nlong long find_minimum_product(std::vector<std::pair<std::tuple<int, int>, std::tuple<int, int>>> pairs) {\n    long long min_product = LLONG_MAX;\n\n    for (const auto& pair : pairs) {\n        int a1 = std::get<0>(pair.first);\n        int b1 = std::get<1>(pair.first);\n        int a2 = std::get<0>(pair.second);\n        int b2 = std::get<1>(pair.second);\n\n        long long product = static_cast<long long>(a1) * static_cast<long long>(b1) * static_cast<long long>(a2) * static_cast<long long>(b2);\n\n        min_product = std::min(min_product, product);\n    }\n\n    return min_product;\n}"
        ]
    },
    {
        "id": "410",
        "prompt": "Write a function to find the minimum value in a given heterogeneous list.",
        "solution": "def min_val(listval):\n     min_val = min(i for i in listval if isinstance(i, int))\n     return min_val",
        "code": [
            "def min_val(listval):\n     min_val = min(i for i in listval if isinstance(i, int))\n     return min_val"
        ],
        "pseudo": "# Initialize the minimum value to the first element in the list\n\n# Iterate through each element in the list\n    # Check if the current element is smaller than the minimum value\n        # If it is, update the minimum value\n\n# Return the minimum value",
        "test": [
            "assert min_val(['Python', 3, 2, 4, 5, 'version'])==2",
            "assert min_val(['Python', 15, 20, 25])==15",
            "assert min_val(['Python', 30, 20, 40, 50, 'version'])==20"
        ],
        "draft_plan": [
            "# Initialize the minimum value to the first element in the list\n\n# Iterate through each element in the list\n    # Check if the current element is smaller than the minimum value\n        # If it is, update the minimum value\n\n# Return the minimum value"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\ntemplate<typename T>\nT find_minimum(std::vector<T> values) {\n    assert(!values.empty()); // Ensure the list is not empty\n    \n    T minimum = values[0]; // Initialize minimum to first element\n    \n    for (const auto& value : values) {\n        if (value < minimum) {\n            minimum = value;\n        }\n    }\n    \n    return minimum;\n}"
        ]
    },
    {
        "id": "411",
        "prompt": "Write a function to convert the given snake case string to camel case string.",
        "solution": "import re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))",
        "code": [
            "import re\ndef snake_to_camel(word):\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))"
        ],
        "pseudo": "# Split the snake case string into words based on the underscore\n# Initialize an empty camel case string\n\n# Iterate through each word in the snake case string\n    # Capitalize the first letter of each word except the first word\n    # Append the capitalized word to the camel case string\n\n# Return the camel case string",
        "test": [
            "assert snake_to_camel('android_tv') == 'AndroidTv'",
            "assert snake_to_camel('google_pixel') == 'GooglePixel'",
            "assert snake_to_camel('apple_watch') == 'AppleWatch'"
        ],
        "draft_plan": [
            "# Split the snake case string into words based on the underscore\n# Initialize an empty camel case string\n\n# Iterate through each word in the snake case string\n    # Capitalize the first letter of each word except the first word\n    # Append the capitalized word to the camel case string\n\n# Return the camel case string"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n#include <assert.h>\n\nstd::string snake_to_camel(std::string snake_case) {\n    std::stringstream ss(snake_case);\n    std::string word;\n    std::string camel_case;\n\n    while (std::getline(ss, word, '_')) {\n        if (camel_case.empty()) {\n            camel_case += word;\n        } else {\n            camel_case += std::toupper(word[0]) + word.substr(1);\n        }\n    }\n\n    return camel_case;\n}"
        ]
    },
    {
        "id": "412",
        "prompt": "Write a python function to remove odd numbers from a given list.",
        "solution": "def remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l",
        "code": [
            "def remove_odd(l):\n    for i in l:\n        if i % 2 != 0:\n            l.remove(i)\n    return l"
        ],
        "pseudo": "# Create an empty list to store the even numbers\n\n# Iterate through each number in the given list\n    # Check if the number is even (number % 2 == 0)\n        # If the number is even, append it to the list of even numbers\n\n# Return the list of even numbers",
        "test": [
            "assert remove_odd([1,2,3]) == [2]",
            "assert remove_odd([2,4,6]) == [2,4,6]",
            "assert remove_odd([10,20,3]) == [10,20]"
        ],
        "draft_plan": [
            "# Create an empty list to store the even numbers\n\n# Iterate through each number in the given list\n    # Check if the number is even (number % 2 == 0)\n        # If the number is even, append it to the list of even numbers\n\n# Return the list of even numbers"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n\nstd::vector<int> remove_odd_numbers(const std::vector<int>& nums) {\n    std::vector<int> even_nums;\n\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            even_nums.push_back(num);\n        }\n    }\n\n    return even_nums;\n}\n\nint main() {\n    std::vector<int> nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    std::vector<int> even_nums = remove_odd_numbers(nums);\n\n    std::cout << \"Even numbers: \";\n    for (int num : even_nums) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}"
        ]
    },
    {
        "id": "413",
        "prompt": "Write a function to extract the nth element from a given list of tuples.",
        "solution": "def extract_nth_element(list1, n):\n    result = [x[n] for x in list1]\n    return result",
        "code": [
            "def extract_nth_element(list1, n):\n    result = [x[n] for x in list1]\n    return result"
        ],
        "pseudo": "# Initialize an empty list to store the nth element from each tuple\n\n# Iterate through each tuple in the given list\n    # Check if the tuple has at least n elements\n        # If yes, append the nth element to the result list\n\n# Return the result list",
        "test": [
            "assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']",
            "assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,2)==[99, 96, 94, 98]",
            "assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)],1)==[98, 97, 91, 94]"
        ],
        "draft_plan": [
            "# Initialize an empty list to store the nth element from each tuple\n\n# Iterate through each tuple in the given list\n    # Check if the tuple has at least n elements\n        # If yes, append the nth element to the result list\n\n# Return the result list"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n#include <tuple>\n\ntemplate<typename T>\nstd::vector<T> extract_nth_element(const std::vector<std::tuple<T>>& tuples, int n) {\n    std::vector<T> result;\n\n    for (const auto& tup : tuples) {\n        if (std::tuple_size<decltype(tup)>::value >= n) {\n            result.push_back(std::get<n - 1>(tup));\n        }\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "414",
        "prompt": "Write a python function to check whether any value in a sequence exists in a sequence or not.",
        "solution": "def overlapping(list1,list2):  \n    for i in range(len(list1)): \n        for j in range(len(list2)): \n            if(list1[i]==list2[j]): \n                return True\n    return False",
        "code": [
            "def overlapping(list1,list2):  \n    for i in range(len(list1)): \n        for j in range(len(list2)): \n            if(list1[i]==list2[j]): \n                return True\n    return False"
        ],
        "pseudo": "# Iterate through each value in the first sequence\n    # Check if the value exists in the second sequence\n        # If the value exists, return True\n\n# If no matching value is found, return False",
        "test": [
            "assert overlapping([1,2,3,4,5],[6,7,8,9]) == False",
            "assert overlapping([1,2,3],[4,5,6]) == False",
            "assert overlapping([1,4,5],[1,4,5]) == True"
        ],
        "draft_plan": [
            "# Iterate through each value in the first sequence\n    # Check if the value exists in the second sequence\n        # If the value exists, return True\n\n# If no matching value is found, return False"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\ntemplate <typename T>\nbool value_exists_in_sequence(const std::vector<T>& seq1, const std::vector<T>& seq2) {\n    for (const auto& val : seq1) {\n        if (std::find(seq2.begin(), seq2.end(), val) != seq2.end()) {\n            return true;\n        }\n    }\n    return false;\n}"
        ]
    },
    {
        "id": "415",
        "prompt": "Write a python function to find a pair with highest product from a given array of integers.",
        "solution": "def max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    ",
        "code": [
            "def max_Product(arr): \n    arr_len = len(arr) \n    if (arr_len < 2): \n        return (\"No pairs exists\")           \n    x = arr[0]; y = arr[1]      \n    for i in range(0,arr_len): \n        for j in range(i + 1,arr_len): \n            if (arr[i] * arr[j] > x * y): \n                x = arr[i]; y = arr[j] \n    return x,y    "
        ],
        "pseudo": "# Initialize the maximum product to -infinity\n\n# Iterate through each pair of numbers in the array\n    # Calculate the product of the current pair\n    # Update the maximum product if the current product is greater\n\n# Return the pair with the highest product",
        "test": [
            "assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)",
            "assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)",
            "assert max_Product([1,2,3]) == (2,3)"
        ],
        "draft_plan": [
            "# Initialize the maximum product to -infinity\n\n# Iterate through each pair of numbers in the array\n    # Calculate the product of the current pair\n    # Update the maximum product if the current product is greater\n\n# Return the pair with the highest product"
        ],
        "final_plan": [
            "#include <cassert>\n#include <vector>\n#include <algorithm>\n\nstd::pair<int, int> find_highest_product_pair(std::vector<int>& nums) {\n    assert(nums.size() >= 2);\n\n    int max_product = std::numeric_limits<int>::min();\n    std::pair<int, int> highest_product_pair;\n\n    for (int i = 0; i < nums.size() - 1; i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            int product = nums[i] * nums[j];\n            if (product > max_product) {\n                max_product = product;\n                highest_product_pair = std::make_pair(nums[i], nums[j]);\n            }\n        }\n    }\n\n    return highest_product_pair;\n}"
        ]
    },
    {
        "id": "417",
        "prompt": "Write a function to find common first element in given list of tuple.",
        "solution": "def group_tuples(Input): \n\tout = {} \n\tfor elem in Input: \n\t\ttry: \n\t\t\tout[elem[0]].extend(elem[1:]) \n\t\texcept KeyError: \n\t\t\tout[elem[0]] = list(elem) \n\treturn [tuple(values) for values in out.values()] ",
        "code": [
            "def group_tuples(Input): \n\tout = {} \n\tfor elem in Input: \n\t\ttry: \n\t\t\tout[elem[0]].extend(elem[1:]) \n\t\texcept KeyError: \n\t\t\tout[elem[0]] = list(elem) \n\treturn [tuple(values) for values in out.values()] "
        ],
        "pseudo": "# Initialize a set to store the first elements of the tuples\n# Initialize a variable to store the common first element, initially None\n\n# Iterate through each tuple in the list\n    # Check if the first element of the tuple is already in the set\n        # If it is, set the common first element to the current element\n        # Break the loop as we have found the common first element\n    # If the first element is not in the set, add it to the set\n\n# Return the common first element",
        "test": [
            "assert group_tuples([('x', 'y'), ('x', 'z'), ('w', 't')]) == [('x', 'y', 'z'), ('w', 't')]",
            "assert group_tuples([('a', 'b'), ('a', 'c'), ('d', 'e')]) == [('a', 'b', 'c'), ('d', 'e')]",
            "assert group_tuples([('f', 'g'), ('f', 'g'), ('h', 'i')]) == [('f', 'g', 'g'), ('h', 'i')]"
        ],
        "draft_plan": [
            "# Initialize a set to store the first elements of the tuples\n# Initialize a variable to store the common first element, initially None\n\n# Iterate through each tuple in the list\n    # Check if the first element of the tuple is already in the set\n        # If it is, set the common first element to the current element\n        # Break the loop as we have found the common first element\n    # If the first element is not in the set, add it to the set\n\n# Return the common first element"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nint find_common_first_element(std::vector<std::tuple<int, int>> tuples) {\n    std::unordered_set<int> first_elements;\n    int common_first_element = -1;\n\n    for (const auto& tuple : tuples) {\n        int first = std::get<0>(tuple);\n\n        if (first_elements.count(first) > 0) {\n            common_first_element = first;\n            break;\n        }\n\n        first_elements.insert(first);\n    }\n\n    return common_first_element;\n}"
        ]
    },
    {
        "id": "418",
        "prompt": "Write a python function to find the element of a list having maximum length.",
        "solution": "def Find_Max(lst): \n    maxList = max((x) for x in lst) \n    return maxList",
        "code": [
            "def Find_Max(lst): \n    maxList = max((x) for x in lst) \n    return maxList"
        ],
        "pseudo": "# Initialize a variable to store the index of the element with maximum length\n# Initialize a variable to store the maximum length, initially set to 0\n\n# Iterate through each element in the list\n    # Check if the length of the current element is greater than the maximum length\n        # If so, update the maximum length and the index of the element\n\n# Return the element at the index with maximum length",
        "test": [
            "assert Find_Max([['A'],['A','B'],['A','B','C']]) == ['A','B','C']",
            "assert Find_Max([[1],[1,2],[1,2,3]]) == [1,2,3]",
            "assert Find_Max([[1,1],[1,2,3],[1,5,6,1]]) == [1,5,6,1]"
        ],
        "draft_plan": [
            "# Initialize a variable to store the index of the element with maximum length\n# Initialize a variable to store the maximum length, initially set to 0\n\n# Iterate through each element in the list\n    # Check if the length of the current element is greater than the maximum length\n        # If so, update the maximum length and the index of the element\n\n# Return the element at the index with maximum length"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string find_max_length_element(const std::vector<std::string>& lst) {\n    std::string max_length_element = \"\";\n    int max_length = 0;\n\n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i].length() > max_length) {\n            max_length = lst[i].length();\n            max_length_element = lst[i];\n        }\n    }\n\n    return max_length_element;\n}"
        ]
    },
    {
        "id": "419",
        "prompt": "Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.",
        "solution": "def round_and_sum(list1):\n  lenght=len(list1)\n  round_and_sum=sum(list(map(round,list1))* lenght)\n  return round_and_sum",
        "code": [
            "def round_and_sum(list1):\n  lenght=len(list1)\n  round_and_sum=sum(list(map(round,list1))* lenght)\n  return round_and_sum"
        ],
        "pseudo": "# Initialize a variable to store the total sum\n# Iterate through each number in the list\n    # Round the number to the nearest integer\n    # Add the rounded number to the total sum\n\n# Calculate the total sum multiplied by the length of the list\n# Print the result",
        "test": [
            "assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243",
            "assert round_and_sum([5,2,9,24.3,29])==345",
            "assert round_and_sum([25.0,56.7,89.2])==513"
        ],
        "draft_plan": [
            "# Initialize a variable to store the total sum\n# Iterate through each number in the list\n    # Round the number to the nearest integer\n    # Add the rounded number to the total sum\n\n# Calculate the total sum multiplied by the length of the list\n# Print the result"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n#include <cmath>\n\nint round_numbers_and_print_sum(std::vector<double> numbers) {\n    double total_sum = 0;\n\n    for (const auto& num : numbers) {\n        total_sum += std::round(num);\n    }\n\n    int result = total_sum * numbers.size();\n    std::cout << result << std::endl;\n\n    return result;\n}"
        ]
    },
    {
        "id": "420",
        "prompt": "Write a python function to find the cube sum of first n even natural numbers.",
        "solution": "def cube_Sum(n): \n    sum = 0\n    for i in range(1,n + 1): \n        sum += (2*i)*(2*i)*(2*i) \n    return sum",
        "code": [
            "def cube_Sum(n): \n    sum = 0\n    for i in range(1,n + 1): \n        sum += (2*i)*(2*i)*(2*i) \n    return sum"
        ],
        "pseudo": "# Initialize a variable to store the sum of the cube of even numbers\n# Iterate through each even number from 2 to (2*n) with a step size of 2\n    # Calculate the cube of the current even number\n    # Add the cube to the sum\n\n# Return the sum of the cube of even numbers",
        "test": [
            "assert cube_Sum(2) == 72",
            "assert cube_Sum(3) == 288",
            "assert cube_Sum(4) == 800"
        ],
        "draft_plan": [
            "# Initialize a variable to store the sum of the cube of even numbers\n# Iterate through each even number from 2 to (2*n) with a step size of 2\n    # Calculate the cube of the current even number\n    # Add the cube to the sum\n\n# Return the sum of the cube of even numbers"
        ],
        "final_plan": [
            "#include <assert.h>\n\nlong long cube_sum_of_even_numbers(int n) {\n    long long sum = 0;\n\n    for (int i = 2; i <= 2 * n; i += 2) {\n        long long cube = i * i * i;\n        sum += cube;\n    }\n\n    return sum;\n}"
        ]
    },
    {
        "id": "421",
        "prompt": "Write a function to concatenate each element of tuple by the delimiter.",
        "solution": "def concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) ",
        "code": [
            "def concatenate_tuple(test_tup):\n    delim = \"-\"\n    res = ''.join([str(ele) + delim for ele in test_tup])\n    res = res[ : len(res) - len(delim)]\n    return (str(res)) "
        ],
        "pseudo": "# Initialize an empty string to store the concatenated elements\n\n# Iterate through each tuple in the input list\n    # Iterate through each element in the tuple\n        # Concatenate the element to the output string\n        # If the current element is not the last element in the tuple, append the delimiter\n\n# Return the concatenated string",
        "test": [
            "assert concatenate_tuple((\"ID\", \"is\", 4, \"UTS\") ) == 'ID-is-4-UTS'",
            "assert concatenate_tuple((\"QWE\", \"is\", 4, \"RTY\") ) == 'QWE-is-4-RTY'",
            "assert concatenate_tuple((\"ZEN\", \"is\", 4, \"OP\") ) == 'ZEN-is-4-OP'"
        ],
        "draft_plan": [
            "# Initialize an empty string to store the concatenated elements\n\n# Iterate through each tuple in the input list\n    # Iterate through each element in the tuple\n        # Concatenate the element to the output string\n        # If the current element is not the last element in the tuple, append the delimiter\n\n# Return the concatenated string"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::string concatenate_tuple_elements(std::vector<std::tuple<std::string, std::string, std::string>> input_list, std::string delimiter) {\n    std::string concatenated_string;\n\n    for (const auto& tup : input_list) {\n        concatenated_string += std::get<0>(tup) + delimiter + std::get<1>(tup) + delimiter + std::get<2>(tup);\n    }\n\n    return concatenated_string;\n}"
        ]
    },
    {
        "id": "422",
        "prompt": "Write a python function to find the average of cubes of first n natural numbers.",
        "solution": "def find_Average_Of_Cube(n):  \n    sum = 0\n    for i in range(1, n + 1): \n        sum += i * i * i  \n    return round(sum / n, 6) ",
        "code": [
            "def find_Average_Of_Cube(n):  \n    sum = 0\n    for i in range(1, n + 1): \n        sum += i * i * i  \n    return round(sum / n, 6) "
        ],
        "pseudo": "# Define a function to find the average of cubes of first n natural numbers\ndef average_of_cubes(n):\n    # Initialize sum of cubes to 0\n    sum_of_cubes = 0\n    \n    # Iterate through the range of 1 to n+1\n    for i in range(1, n+1):\n        # Calculate the cube of the current number and add it to the sum_of_cubes\n        sum_of_cubes += i**3\n    \n    # Calculate the average by dividing the sum_of_cubes by n\n    average = sum_of_cubes / n\n    \n    # Return the average\n    return average",
        "test": [
            "assert find_Average_Of_Cube(2) == 4.5",
            "assert find_Average_Of_Cube(3) == 12",
            "assert find_Average_Of_Cube(1) == 1"
        ],
        "draft_plan": [
            "# Define a function to find the average of cubes of first n natural numbers\ndef average_of_cubes(n):\n    # Initialize sum of cubes to 0\n    sum_of_cubes = 0\n    \n    # Iterate through the range of 1 to n+1\n    for i in range(1, n+1):\n        # Calculate the cube of the current number and add it to the sum_of_cubes\n        sum_of_cubes += i**3\n    \n    # Calculate the average by dividing the sum_of_cubes by n\n    average = sum_of_cubes / n\n    \n    # Return the average\n    return average"
        ],
        "final_plan": [
            "#include <assert.h>\n\ndouble average_of_cubes(int n) {\n    double sum_of_cubes = 0.0;\n    \n    for (int i = 1; i <= n; i++) {\n        sum_of_cubes += pow(i, 3);\n    }\n    \n    double average = sum_of_cubes / n;\n    \n    return average;\n}"
        ]
    },
    {
        "id": "424",
        "prompt": "Write a function to extract only the rear index element of each string in the given tuple.",
        "solution": "def extract_rear(test_tuple):\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\n  return (res) ",
        "code": [
            "def extract_rear(test_tuple):\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\n  return (res) "
        ],
        "pseudo": "# Create an empty list to store the rear index elements\n# Iterate through each string in the given tuple\n    # Get the rear index element of the current string using indexing\n    # Append the rear index element to the list\n\n# Return the list of rear index elements",
        "test": [
            "assert extract_rear(('Mers', 'for', 'Vers') ) == ['s', 'r', 's']",
            "assert extract_rear(('Avenge', 'for', 'People') ) == ['e', 'r', 'e']",
            "assert extract_rear(('Gotta', 'get', 'go') ) == ['a', 't', 'o']"
        ],
        "draft_plan": [
            "# Create an empty list to store the rear index elements\n# Iterate through each string in the given tuple\n    # Get the rear index element of the current string using indexing\n    # Append the rear index element to the list\n\n# Return the list of rear index elements"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<char> extract_rear_index(std::tuple<std::string, std::string, std::string> strings) {\n    std::vector<char> rear_indices;\n\n    std::string str1 = std::get<0>(strings);\n    std::string str2 = std::get<1>(strings);\n    std::string str3 = std::get<2>(strings);\n\n    rear_indices.push_back(str1[str1.size() - 1]);\n    rear_indices.push_back(str2[str2.size() - 1]);\n    rear_indices.push_back(str3[str3.size() - 1]);\n\n    return rear_indices;\n}"
        ]
    },
    {
        "id": "425",
        "prompt": "Write a function to count the number of sublists containing a particular element.",
        "solution": "def count_element_in_list(list1, x): \n    ctr = 0\n    for i in range(len(list1)): \n        if x in list1[i]: \n            ctr+= 1          \n    return ctr",
        "code": [
            "def count_element_in_list(list1, x): \n    ctr = 0\n    for i in range(len(list1)): \n        if x in list1[i]: \n            ctr+= 1          \n    return ctr"
        ],
        "pseudo": "# Initialize a count variable to 0\n\n# Iterate through each sublist in the main list\n    # Check if the particular element is present in the sublist\n        # If yes, increment the count variable\n\n# Return the count variable",
        "test": [
            "assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]],1)==3",
            "assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'A')==3",
            "assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'E')==1"
        ],
        "draft_plan": [
            "# Initialize a count variable to 0\n\n# Iterate through each sublist in the main list\n    # Check if the particular element is present in the sublist\n        # If yes, increment the count variable\n\n# Return the count variable"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\nusing namespace std;\n\nint count_sublists_with_element(vector<vector<int>>& main_list, int element) {\n    int count = 0;\n\n    for (const auto& sublist : main_list) {\n        if (find(sublist.begin(), sublist.end(), element) != sublist.end()) {\n            count++;\n        }\n    }\n\n    return count;\n}"
        ]
    },
    {
        "id": "426",
        "prompt": "Write a function to filter odd numbers.",
        "solution": "def filter_oddnumbers(nums):\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\n return odd_nums",
        "code": [
            "def filter_oddnumbers(nums):\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\n return odd_nums"
        ],
        "pseudo": "# Initialize an empty list to store the filtered numbers\n\n# Iterate through each number in the input list\n    # Check if the number is odd\n        # If the number is odd, append it to the filtered list\n\n# Return the filtered list",
        "test": [
            "assert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1,3,5,7,9]",
            "assert filter_oddnumbers([10,20,45,67,84,93])==[45,67,93]",
            "assert filter_oddnumbers([5,7,9,8,6,4,3])==[5,7,9,3]"
        ],
        "draft_plan": [
            "# Initialize an empty list to store the filtered numbers\n\n# Iterate through each number in the input list\n    # Check if the number is odd\n        # If the number is odd, append it to the filtered list\n\n# Return the filtered list"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n\nstd::vector<int> filter_odd_numbers(std::vector<int> numbers) {\n    std::vector<int> filtered_numbers;\n    \n    for (int number : numbers) {\n        if (number % 2 != 0) {\n            filtered_numbers.push_back(number);\n        }\n    }\n    \n    return filtered_numbers;\n}"
        ]
    },
    {
        "id": "427",
        "prompt": "Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.",
        "solution": "import re\ndef change_date_format(dt):\n        return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)",
        "code": [
            "import re\ndef change_date_format(dt):\n        return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)"
        ],
        "pseudo": "# Split the input date string by '-' to get year, month, and day\n# Create a new date string in the format of dd-mm-yyyy using day, month, and year obtained from the split\n# Return the new date string",
        "test": [
            "assert change_date_format(\"2026-01-02\") == '02-01-2026'",
            "assert change_date_format(\"2020-11-13\") == '13-11-2020'",
            "assert change_date_format(\"2021-04-26\") == '26-04-2021'"
        ],
        "draft_plan": [
            "# Split the input date string by '-' to get year, month, and day\n# Create a new date string in the format of dd-mm-yyyy using day, month, and year obtained from the split\n# Return the new date string"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <sstream>\n#include <string>\n\nstd::string convert_date_format(const std::string& date) {\n    std::stringstream ss(date);\n    std::string year, month, day;\n    std::getline(ss, year, '-');\n    std::getline(ss, month, '-');\n    std::getline(ss, day, '-');\n\n    std::string new_date = day + \"-\" + month + \"-\" + year;\n    return new_date;\n}"
        ]
    },
    {
        "id": "428",
        "prompt": "Write a function to sort the given array by using shell sort.",
        "solution": "def shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > current_item:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n\n    return my_list",
        "code": [
            "def shell_sort(my_list):\n    gap = len(my_list) // 2\n    while gap > 0:\n        for i in range(gap, len(my_list)):\n            current_item = my_list[i]\n            j = i\n            while j >= gap and my_list[j - gap] > current_item:\n                my_list[j] = my_list[j - gap]\n                j -= gap\n            my_list[j] = current_item\n        gap //= 2\n\n    return my_list"
        ],
        "pseudo": "# Define a function to perform shell sort on the given array\n    # Start with a large gap (length of array divided by 2)\n    # Iterate until the gap becomes 0\n        # Iterate through the array from the current gap to the end\n            # Compare the current element with the element at the position gap steps before it\n            # If the current element is smaller, swap them\n        # Reduce the gap by dividing it by 2\n\n# Call the shell sort function on the given array\n# Return the sorted array",
        "test": [
            "assert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]",
            "assert shell_sort([24, 22, 39, 34, 87, 73, 68]) == [22, 24, 34, 39, 68, 73, 87]",
            "assert shell_sort([32, 30, 16, 96, 82, 83, 74]) == [16, 30, 32, 74, 82, 83, 96]"
        ],
        "draft_plan": [
            "# Define a function to perform shell sort on the given array\n    # Start with a large gap (length of array divided by 2)\n    # Iterate until the gap becomes 0\n        # Iterate through the array from the current gap to the end\n            # Compare the current element with the element at the position gap steps before it\n            # If the current element is smaller, swap them\n        # Reduce the gap by dividing it by 2\n\n# Call the shell sort function on the given array\n# Return the sorted array"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n\nvoid shellSort(std::vector<int>& arr) {\n    int n = arr.size();\n    for (int gap = n / 2; gap > 0; gap /= 2) {\n        for (int i = gap; i < n; i++) {\n            int temp = arr[i];\n            int j;\n            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {\n                arr[j] = arr[j - gap];\n            }\n            arr[j] = temp;\n        }\n    }\n}\n\nint main() {\n    std::vector<int> arr = {9, 4, 7, 2, 1, 5, 3, 6, 8};\n    shellSort(arr);\n    std::cout << \"Sorted array: \";\n    for (int num : arr) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}"
        ]
    },
    {
        "id": "429",
        "prompt": "Write a function to extract the elementwise and tuples from the given two tuples.",
        "solution": "def and_tuples(test_tup1, test_tup2):\n  res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) ",
        "code": [
            "def and_tuples(test_tup1, test_tup2):\n  res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n  return (res) "
        ],
        "pseudo": "# Initialize an empty list to store the elementwise AND tuples\n\n# Iterate through each element in the first tuple\n    # Iterate through each element in the second tuple\n        # Perform elementwise AND operation on the corresponding elements of the tuples\n        # Append the result to the list of elementwise AND tuples\n\n# Return the list of elementwise AND tuples",
        "test": [
            "assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)",
            "assert and_tuples((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)",
            "assert and_tuples((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)"
        ],
        "draft_plan": [
            "# Initialize an empty list to store the elementwise AND tuples\n\n# Iterate through each element in the first tuple\n    # Iterate through each element in the second tuple\n        # Perform elementwise AND operation on the corresponding elements of the tuples\n        # Append the result to the list of elementwise AND tuples\n\n# Return the list of elementwise AND tuples"
        ],
        "final_plan": [
            "#include <cassert>\n#include <tuple>\n#include <vector>\n\nstd::vector<std::tuple<int, int, int>> extract_elementwise_and_tuples(const std::tuple<int, int, int>& tuple1, const std::tuple<int, int, int>& tuple2) {\n    std::vector<std::tuple<int, int, int>> result;\n\n    for (int i = 0; i < 3; i++) {\n        int element1 = std::get<i>(tuple1);\n        int element2 = std::get<i>(tuple2);\n        int elementwise_and = element1 & element2;\n        result.push_back(std::make_tuple(element1, element2, elementwise_and));\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "430",
        "prompt": "Write a function to find the directrix of a parabola.",
        "solution": "def parabola_directrix(a, b, c): \n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\n  return directrix",
        "code": [
            "def parabola_directrix(a, b, c): \n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\n  return directrix"
        ],
        "pseudo": "To find the directrix of a parabola, we can use the equation of a parabola in vertex form:\n\ny = (1 / (4 * p)) * (x - h)^2 + k\n\nwhere (h, k) is the vertex of the parabola and p is the distance from the vertex to the focus.\n\nThe directrix of the parabola is a horizontal line given by the equation:\n\ny = k - p\n\nTherefore, the logic to find the directrix of a parabola is as follows:\n\n1. Given the vertex coordinates (h, k) and the value of p, calculate the value of the directrix using the equation y = k - p.\n\n2. Return the value of the directrix.\n\nHere is the code implementation:\n\n```python\ndef find_directrix(h, k, p):\n    directrix = k - p\n    return directrix\n```\n\nYou can call this function with the vertex coordinates (h, k) and the value of p to find the directrix of the parabola.",
        "test": [
            "assert parabola_directrix(5,3,2)==-198",
            "assert parabola_directrix(9,8,4)==-2336",
            "assert parabola_directrix(2,4,6)==-130"
        ],
        "draft_plan": [
            "To find the directrix of a parabola, we can use the equation of a parabola in vertex form:\n\ny = (1 / (4 * p)) * (x - h)^2 + k\n\nwhere (h, k) is the vertex of the parabola and p is the distance from the vertex to the focus.\n\nThe directrix of the parabola is a horizontal line given by the equation:\n\ny = k - p\n\nTherefore, the logic to find the directrix of a parabola is as follows:\n\n1. Given the vertex coordinates (h, k) and the value of p, calculate the value of the directrix using the equation y = k - p.\n\n2. Return the value of the directrix.\n\nHere is the code implementation:\n\n```python\ndef find_directrix(h, k, p):\n    directrix = k - p\n    return directrix\n```\n\nYou can call this function with the vertex coordinates (h, k) and the value of p to find the directrix of the parabola."
        ],
        "final_plan": [
            "#include <iostream>\n\ndouble find_directrix(double h, double k, double p) {\n    double directrix = k - p;\n    return directrix;\n}\n\nint main() {\n    double h, k, p;\n    std::cout << \"Enter the vertex coordinates (h, k): \";\n    std::cin >> h >> k;\n    std::cout << \"Enter the value of p: \";\n    std::cin >> p;\n\n    double directrix = find_directrix(h, k, p);\n    std::cout << \"The directrix of the parabola is y = \" << directrix << std::endl;\n\n    return 0;\n}"
        ]
    },
    {
        "id": "431",
        "prompt": "Write a function that takes two lists and returns true if they have at least one common element.",
        "solution": "def common_element(list1, list2):\n     result = False\n     for x in list1:\n         for y in list2:\n             if x == y:\n                 result = True\n                 return result",
        "code": [
            "def common_element(list1, list2):\n     result = False\n     for x in list1:\n         for y in list2:\n             if x == y:\n                 result = True\n                 return result"
        ],
        "pseudo": "# Iterate through each element in the first list\n    # Check if the current element is in the second list\n        # If found, return True\n\n# If no common element is found, return False",
        "test": [
            "assert common_element([1,2,3,4,5], [5,6,7,8,9])==True",
            "assert common_element([1,2,3,4,5], [6,7,8,9])==None",
            "assert common_element(['a','b','c'], ['d','b','e'])==True"
        ],
        "draft_plan": [
            "# Iterate through each element in the first list\n    # Check if the current element is in the second list\n        # If found, return True\n\n# If no common element is found, return False"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nbool has_common_element(std::vector<int> list1, std::vector<int> list2) {\n    for (const auto& num : list1) {\n        if (std::find(list2.begin(), list2.end(), num) != list2.end()) {\n            return true;\n        }\n    }\n    return false;\n}"
        ]
    },
    {
        "id": "432",
        "prompt": "Write a function to find the median length of a trapezium.",
        "solution": "def median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median",
        "code": [
            "def median_trapezium(base1,base2,height):\n median = 0.5 * (base1+ base2)\n return median"
        ],
        "pseudo": "# Define a function to calculate the median length of a trapezium\n    # Calculate the sum of the lengths of the two parallel sides of the trapezium\n    # Divide the sum by 2 to get the average length\n    # Return the average length as the median length of the trapezium",
        "test": [
            "assert median_trapezium(15,25,35)==20",
            "assert median_trapezium(10,20,30)==15",
            "assert median_trapezium(6,9,4)==7.5"
        ],
        "draft_plan": [
            "# Define a function to calculate the median length of a trapezium\n    # Calculate the sum of the lengths of the two parallel sides of the trapezium\n    # Divide the sum by 2 to get the average length\n    # Return the average length as the median length of the trapezium"
        ],
        "final_plan": [
            "#include <iostream>\n\ndouble calculate_median_length(double side1, double side2) {\n    double median_length = (side1 + side2) / 2.0;\n    return median_length;\n}"
        ]
    },
    {
        "id": "433",
        "prompt": "Write a function to check whether the entered number is greater than the elements of the given array.",
        "solution": "def check_greater(arr, number):\n  arr.sort()\n  return number > arr[-1]",
        "code": [
            "def check_greater(arr, number):\n  arr.sort()\n  return number > arr[-1]"
        ],
        "pseudo": "# Define a function that takes a number and an array as input\n    # Iterate through each element in the array\n        # Check if the number is greater than the current element\n            # If it is, return True\n    # If the number is not greater than any element in the array, return False",
        "test": [
            "assert check_greater([1, 2, 3, 4, 5], 4) == False",
            "assert check_greater([2, 3, 4, 5, 6], 8) == True",
            "assert check_greater([9, 7, 4, 8, 6, 1], 11) == True"
        ],
        "draft_plan": [
            "# Define a function that takes a number and an array as input\n    # Iterate through each element in the array\n        # Check if the number is greater than the current element\n            # If it is, return True\n    # If the number is not greater than any element in the array, return False"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\nbool is_greater_than_elements(int number, std::vector<int>& array) {\n    for (int element : array) {\n        if (number <= element) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> array = {1, 2, 3, 4, 5};\n    int number = 6;\n    bool result = is_greater_than_elements(number, array);\n    std::cout << std::boolalpha << result << std::endl;  // Output: true\n    return 0;\n}"
        ]
    },
    {
        "id": "434",
        "prompt": "Write a function that matches a string that has an a followed by one or more b's.",
        "solution": "import re\ndef text_match_one(text):\n        patterns = 'ab+?'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n",
        "code": [
            "import re\ndef text_match_one(text):\n        patterns = 'ab+?'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False\n"
        ],
        "pseudo": "import re\n\ndef match_string(string):\n    pattern = r'a+b+'\n    if re.match(pattern, string):\n        return True\n    else:\n        return False",
        "test": [
            "assert text_match_one(\"ac\")==False",
            "assert text_match_one(\"dc\")==False",
            "assert text_match_one(\"abba\")==True"
        ],
        "draft_plan": [
            "import re\n\ndef match_string(string):\n    pattern = r'a+b+'\n    if re.match(pattern, string):\n        return True\n    else:\n        return False"
        ],
        "final_plan": [
            "#include<assert.h>\n#include<bits/stdc++.h>\n\nbool match_string(std::string text) {\n    std::regex pattern(\"a+b+\");\n    return std::regex_match(text, pattern);\n}"
        ]
    },
    {
        "id": "435",
        "prompt": "Write a python function to find the last digit of a given number.",
        "solution": "def last_Digit(n) :\n    return (n % 10) ",
        "code": [
            "def last_Digit(n) :\n    return (n % 10) "
        ],
        "pseudo": "To find the last digit of a given number, you can use the modulo operator (`%`) to get the remainder when dividing the number by 10. The remainder will be the last digit of the number.\n\nHere's the code logic:\n\n1. Define a function `find_last_digit` that takes a number as input.\n2. Inside the function, calculate the remainder of the number when divided by 10 using the modulo operator: `last_digit = number % 10`.\n3. Return the value of `last_digit`.\n\nHere's the code implementation in Python:\n\n```python\ndef find_last_digit(number):\n    last_digit = number % 10\n    return last_digit\n```\n\nYou can then call this function by passing a number as an argument to get the last digit. For example:\n\n```python\nprint(find_last_digit(12345))  # Output: 5\nprint(find_last_digit(987654321))  # Output: 1\nprint(find_last_digit(0))  # Output: 0\n```",
        "test": [
            "assert last_Digit(123) == 3",
            "assert last_Digit(25) == 5",
            "assert last_Digit(30) == 0"
        ],
        "draft_plan": [
            "To find the last digit of a given number, you can use the modulo operator (`%`) to get the remainder when dividing the number by 10. The remainder will be the last digit of the number.\n\nHere's the code logic:\n\n1. Define a function `find_last_digit` that takes a number as input.\n2. Inside the function, calculate the remainder of the number when divided by 10 using the modulo operator: `last_digit = number % 10`.\n3. Return the value of `last_digit`.\n\nHere's the code implementation in Python:\n\n```python\ndef find_last_digit(number):\n    last_digit = number % 10\n    return last_digit\n```\n\nYou can then call this function by passing a number as an argument to get the last digit. For example:\n\n```python\nprint(find_last_digit(12345))  # Output: 5\nprint(find_last_digit(987654321))  # Output: 1\nprint(find_last_digit(0))  # Output: 0\n```"
        ],
        "final_plan": [
            "Here's the C++ code to find the last digit of a given number:\n\n```cpp\n#include <iostream>\n\nint find_last_digit(int number) {\n    int last_digit = number % 10;\n    return last_digit;\n}\n\nint main() {\n    std::cout << find_last_digit(12345) << std::endl;  // Output: 5\n    std::cout << find_last_digit(987654321) << std::endl;  // Output: 1\n    std::cout << find_last_digit(0) << std::endl;  // Output: 0\n\n    return 0;\n}\n```\n\nIn this code, the `find_last_digit` function takes an integer `number` as input and returns the last digit of that number. The `main` function demonstrates the usage of the `find_last_digit` function by passing different numbers and printing the last digit."
        ]
    },
    {
        "id": "436",
        "prompt": "Write a python function to return the negative numbers in a list.",
        "solution": "def neg_nos(list1):\n  out = []\n  for num in list1: \n    if num < 0: \n      out.append(num)\n  return out ",
        "code": [
            "def neg_nos(list1):\n  out = []\n  for num in list1: \n    if num < 0: \n      out.append(num)\n  return out "
        ],
        "pseudo": "# Initialize an empty list to store the negative numbers\n\n# Iterate through each element in the input list\n    # Check if the current element is less than 0\n        # If the element is negative, append it to the list of negative numbers\n\n# Return the list of negative numbers",
        "test": [
            "assert neg_nos([-1,4,5,-6]) == [-1,-6]",
            "assert neg_nos([-1,-2,3,4]) == [-1,-2]",
            "assert neg_nos([-7,-6,8,9]) == [-7,-6]"
        ],
        "draft_plan": [
            "# Initialize an empty list to store the negative numbers\n\n# Iterate through each element in the input list\n    # Check if the current element is less than 0\n        # If the element is negative, append it to the list of negative numbers\n\n# Return the list of negative numbers"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <vector>\n\nstd::vector<int> get_negative_numbers(std::vector<int> nums) {\n    std::vector<int> negative_nums;\n\n    for (int num : nums) {\n        if (num < 0) {\n            negative_nums.push_back(num);\n        }\n    }\n\n    return negative_nums;\n}"
        ]
    },
    {
        "id": "437",
        "prompt": "Write a function to remove odd characters in a string.",
        "solution": "def remove_odd(str1):\n str2 = ''\n for i in range(1, len(str1) + 1):\n    if(i % 2 == 0):\n        str2 = str2 + str1[i - 1]\n return str2",
        "code": [
            "def remove_odd(str1):\n str2 = ''\n for i in range(1, len(str1) + 1):\n    if(i % 2 == 0):\n        str2 = str2 + str1[i - 1]\n return str2"
        ],
        "pseudo": "# Initialize an empty string to store the result\n\n# Iterate through each character in the input string\n    # Check if the index of the current character is even\n        # If the index is even, append the character to the result string\n\n# Return the result string",
        "test": [
            "assert remove_odd(\"python\")==(\"yhn\")",
            "assert remove_odd(\"program\")==(\"rga\")",
            "assert remove_odd(\"language\")==(\"agae\")"
        ],
        "draft_plan": [
            "# Initialize an empty string to store the result\n\n# Iterate through each character in the input string\n    # Check if the index of the current character is even\n        # If the index is even, append the character to the result string\n\n# Return the result string"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <string>\n\nstd::string remove_odd_characters(std::string str) {\n    std::string result;\n\n    for (int i = 0; i < str.length(); i++) {\n        if (i % 2 == 0) {\n            result += str[i];\n        }\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "438",
        "prompt": "Write a function to count bidirectional tuple pairs.",
        "solution": "def count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res",
        "code": [
            "def count_bidirectional(test_list):\n  res = 0\n  for idx in range(0, len(test_list)):\n    for iidx in range(idx + 1, len(test_list)):\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\n        res += 1\n  return res"
        ],
        "pseudo": "# Initialize a counter variable to 0\n\n# Iterate through each pair in the array\n    # Check if the reverse of the current pair exists in the array\n        # If it does, increment the counter by 1\n\n# Return the counter value",
        "test": [
            "assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 3",
            "assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 2",
            "assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == 4"
        ],
        "draft_plan": [
            "# Initialize a counter variable to 0\n\n# Iterate through each pair in the array\n    # Check if the reverse of the current pair exists in the array\n        # If it does, increment the counter by 1\n\n# Return the counter value"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint count_bidirectional(std::vector<std::pair<int, int>> test_list) {\n    int counter = 0;\n\n    for (int i = 0; i < test_list.size(); i++) {\n        std::pair<int, int> current_pair = test_list[i];\n        std::pair<int, int> reverse_pair = std::make_pair(current_pair.second, current_pair.first);\n\n        if (std::find(test_list.begin(), test_list.end(), reverse_pair) != test_list.end()) {\n            counter++;\n        }\n    }\n\n    return counter;\n}"
        ]
    },
    {
        "id": "439",
        "prompt": "Write a function to join a list of multiple integers into a single integer.",
        "solution": "def multiple_to_single(L):\n  x = int(\"\".join(map(str, L)))\n  return x",
        "code": [
            "def multiple_to_single(L):\n  x = int(\"\".join(map(str, L)))\n  return x"
        ],
        "pseudo": "# Convert each integer in the list to a string\n# Join the list of strings into a single string\n# Convert the resulting string back to an integer and return it",
        "test": [
            "assert multiple_to_single([11, 33, 50])==113350",
            "assert multiple_to_single([-1,2,3,4,5,6])==-123456",
            "assert multiple_to_single([10,15,20,25])==10152025"
        ],
        "draft_plan": [
            "# Convert each integer in the list to a string\n# Join the list of strings into a single string\n# Convert the resulting string back to an integer and return it"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <sstream>\n#include <string>\n#include <vector>\n\nint join_integers(std::vector<int> integer_list) {\n    std::ostringstream oss;\n    for (int i : integer_list) {\n        oss << i;\n    }\n    std::string result_str = oss.str();\n    return std::stoi(result_str);\n}"
        ]
    },
    {
        "id": "440",
        "prompt": "Write a function to find the first adverb and their positions in a given sentence.",
        "solution": "import re\ndef find_adverb_position(text):\n for m in re.finditer(r\"\\w+ly\", text):\n    return (m.start(), m.end(), m.group(0))",
        "code": [
            "import re\ndef find_adverb_position(text):\n for m in re.finditer(r\"\\w+ly\", text):\n    return (m.start(), m.end(), m.group(0))"
        ],
        "pseudo": "# Split the sentence into a list of words\n\n# Iterate through each word and its index in the list\n    # Check if the word ends with \"ly\" (indicating it is an adverb)\n        # If it is an adverb, store its index and break the loop\n\n# If an adverb is found, return its index and the adverb itself\n# If no adverb is found, return None",
        "test": [
            "assert find_adverb_position(\"clearly!! we can see the sky\")==(0, 7, 'clearly')",
            "assert find_adverb_position(\"seriously!! there are many roses\")==(0, 9, 'seriously')",
            "assert find_adverb_position(\"unfortunately!! sita is going to home\")==(0, 13, 'unfortunately')"
        ],
        "draft_plan": [
            "# Split the sentence into a list of words\n\n# Iterate through each word and its index in the list\n    # Check if the word ends with \"ly\" (indicating it is an adverb)\n        # If it is an adverb, store its index and break the loop\n\n# If an adverb is found, return its index and the adverb itself\n# If no adverb is found, return None"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::pair<int, std::string> find_first_adverb(std::string sentence) {\n    std::istringstream iss(sentence);\n    std::vector<std::string> words((std::istream_iterator<std::string>(iss)), std::istream_iterator<std::string>());\n\n    for (int i = 0; i < words.size(); i++) {\n        std::string word = words[i];\n        if (word.size() >= 2 && word.substr(word.size() - 2) == \"ly\") {\n            return std::make_pair(i, word);\n        }\n    }\n\n    return std::make_pair(-1, \"\");\n}"
        ]
    },
    {
        "id": "441",
        "prompt": "Write a function to find the surface area of a cube of a given size.",
        "solution": "def surfacearea_cube(l):\n  surfacearea= 6*l*l\n  return surfacearea",
        "code": [
            "def surfacearea_cube(l):\n  surfacearea= 6*l*l\n  return surfacearea"
        ],
        "pseudo": "To find the surface area of a cube, we can use the formula: surface_area = 6 * side_length^2\n\nHere is the code logic to find the surface area of a cube in Python:\n\n1. Define a function named `calculate_cube_surface_area` that takes a parameter `side_length`.\n2. Calculate the surface area using the formula `surface_area = 6 * side_length^2`.\n3. Return the calculated surface area.\n\nHere is the code implementation:\n\n```python\ndef calculate_cube_surface_area(side_length):\n    surface_area = 6 * side_length**2\n    return surface_area\n```\n\nYou can call this function with the desired `side_length` value to get the surface area of the cube.",
        "test": [
            "assert surfacearea_cube(5)==150",
            "assert surfacearea_cube(3)==54",
            "assert surfacearea_cube(10)==600"
        ],
        "draft_plan": [
            "To find the surface area of a cube, we can use the formula: surface_area = 6 * side_length^2\n\nHere is the code logic to find the surface area of a cube in Python:\n\n1. Define a function named `calculate_cube_surface_area` that takes a parameter `side_length`.\n2. Calculate the surface area using the formula `surface_area = 6 * side_length^2`.\n3. Return the calculated surface area.\n\nHere is the code implementation:\n\n```python\ndef calculate_cube_surface_area(side_length):\n    surface_area = 6 * side_length**2\n    return surface_area\n```\n\nYou can call this function with the desired `side_length` value to get the surface area of the cube."
        ],
        "final_plan": [
            "Here is the C++ code to find the surface area of a cube:\n\n```cpp\n#include <cassert>\n\ndouble calculate_cube_surface_area(double side_length) {\n    double surface_area = 6 * side_length * side_length;\n    return surface_area;\n}\n\nint main() {\n    double side_length = 5.0;\n    double surface_area = calculate_cube_surface_area(side_length);\n    assert(surface_area == 150.0);\n\n    return 0;\n}\n```\n\nIn this code, we define a function `calculate_cube_surface_area` that takes a `double` parameter `side_length` and calculates the surface area using the formula `surface_area = 6 * side_length * side_length`. We then call this function in the `main` function and assert that the calculated surface area is equal to the expected value (in this case, 150.0)."
        ]
    },
    {
        "id": "442",
        "prompt": "Write a function to find the ration of positive numbers in an array of integers.",
        "solution": "from array import array\ndef positive_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)",
        "code": [
            "from array import array\ndef positive_count(nums):\n    n = len(nums)\n    n1 = 0\n    for x in nums:\n        if x > 0:\n            n1 += 1\n        else:\n          None\n    return round(n1/n,2)"
        ],
        "pseudo": "# Initialize a counter for positive numbers\n# Iterate through each element in the array\n    # Check if the element is greater than 0\n        # If it is, increment the counter\n\n# Calculate the ratio of positive numbers by dividing the counter by the length of the array\n# Return the ratio",
        "test": [
            "assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.54",
            "assert positive_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.69",
            "assert positive_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.56"
        ],
        "draft_plan": [
            "# Initialize a counter for positive numbers\n# Iterate through each element in the array\n    # Check if the element is greater than 0\n        # If it is, increment the counter\n\n# Calculate the ratio of positive numbers by dividing the counter by the length of the array\n# Return the ratio"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n\ndouble positive_ratio(const std::vector<int>& arr) {\n    int positive_count = 0;\n    for (int num : arr) {\n        if (num > 0) {\n            positive_count++;\n        }\n    }\n    double ratio = static_cast<double>(positive_count) / arr.size();\n    return ratio;\n}\n\nint main() {\n    std::vector<int> arr = {1, -2, 3, -4, 5};\n    double ratio = positive_ratio(arr);\n    std::cout << \"Positive ratio: \" << ratio << std::endl;\n    return 0;\n}"
        ]
    },
    {
        "id": "443",
        "prompt": "Write a python function to find the largest negative number from the given list.",
        "solution": "def largest_neg(list1): \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max",
        "code": [
            "def largest_neg(list1): \n    max = list1[0] \n    for x in list1: \n        if x < max : \n             max = x  \n    return max"
        ],
        "pseudo": "# Initialize a variable 'largest_negative' to None\n\n# Iterate through each number in the list\n    # Check if the number is negative\n        # If 'largest_negative' is None or the current number is greater than 'largest_negative', update 'largest_negative' to the current number\n\n# Return 'largest_negative'",
        "test": [
            "assert largest_neg([1,2,3,-4,-6]) == -6",
            "assert largest_neg([1,2,3,-8,-9]) == -9",
            "assert largest_neg([1,2,3,4,-1]) == -1"
        ],
        "draft_plan": [
            "# Initialize a variable 'largest_negative' to None\n\n# Iterate through each number in the list\n    # Check if the number is negative\n        # If 'largest_negative' is None or the current number is greater than 'largest_negative', update 'largest_negative' to the current number\n\n# Return 'largest_negative'"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint largest_negative(std::vector<int> numbers) {\n    int largest_negative = INT_MIN;\n\n    for (int num : numbers) {\n        if (num < 0 && (largest_negative == INT_MIN || num > largest_negative)) {\n            largest_negative = num;\n        }\n    }\n\n    return largest_negative;\n}"
        ]
    },
    {
        "id": "444",
        "prompt": "Write a function to trim each tuple by k in the given tuple list.",
        "solution": "def trim_tuple(test_list, K):\n  res = []\n  for ele in test_list:\n    N = len(ele)\n    res.append(tuple(list(ele)[K: N - K]))\n  return (str(res)) ",
        "code": [
            "def trim_tuple(test_list, K):\n  res = []\n  for ele in test_list:\n    N = len(ele)\n    res.append(tuple(list(ele)[K: N - K]))\n  return (str(res)) "
        ],
        "pseudo": "# Create an empty list to store the trimmed tuples\n\n# Iterate through each tuple in the given list\n    # Check if the length of the current tuple is greater than k\n        # If yes, trim the tuple by removing the first k elements\n        # Append the trimmed tuple to the new list\n\n# Return the new list containing the trimmed tuples",
        "test": [
            "assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'",
            "assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'",
            "assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'"
        ],
        "draft_plan": [
            "# Create an empty list to store the trimmed tuples\n\n# Iterate through each tuple in the given list\n    # Check if the length of the current tuple is greater than k\n        # If yes, trim the tuple by removing the first k elements\n        # Append the trimmed tuple to the new list\n\n# Return the new list containing the trimmed tuples"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n#include <assert.h>\n\nstd::vector<std::tuple<int, int, int>> trim_tuples(std::vector<std::tuple<int, int, int>> tuple_list, int k) {\n    std::vector<std::tuple<int, int, int>> trimmed_list;\n\n    for (const auto& tuple : tuple_list) {\n        if (std::tuple_size<decltype(tuple)>::value > k) {\n            std::tuple<int, int, int> trimmed_tuple = tuple;\n            std::get<0>(trimmed_tuple) = std::get<0>(tuple);\n            std::get<1>(trimmed_tuple) = std::get<1>(tuple);\n            std::get<2>(trimmed_tuple) = std::get<2>(tuple);\n            trimmed_list.push_back(trimmed_tuple);\n        }\n    }\n\n    return trimmed_list;\n}"
        ]
    },
    {
        "id": "445",
        "prompt": "Write a function to perform index wise multiplication of tuple elements in the given two tuples.",
        "solution": "def index_multiplication(test_tup1, test_tup2):\n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) ",
        "code": [
            "def index_multiplication(test_tup1, test_tup2):\n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\n   for tup1, tup2 in zip(test_tup1, test_tup2))\n  return (res) "
        ],
        "pseudo": "# Create an empty list to store the result of multiplication\n\n# Iterate through the indexes of the tuples using the range of the length of the tuples\n    # Multiply the elements at the current index of both tuples\n    # Append the result to the list\n\n# Return the list",
        "test": [
            "assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))",
            "assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))",
            "assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))"
        ],
        "draft_plan": [
            "# Create an empty list to store the result of multiplication\n\n# Iterate through the indexes of the tuples using the range of the length of the tuples\n    # Multiply the elements at the current index of both tuples\n    # Append the result to the list\n\n# Return the list"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<int> tuple_multiplication(std::tuple<int, int, int> tuple1, std::tuple<int, int, int> tuple2) {\n    std::vector<int> result;\n\n    for (int i = 0; i < 3; i++) {\n        result.push_back(std::get<i>(tuple1) * std::get<i>(tuple2));\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "446",
        "prompt": "Write a python function to count the occurence of all elements of list in a tuple.",
        "solution": "from collections import Counter \ndef count_Occurrence(tup, lst): \n    count = 0\n    for item in tup: \n        if item in lst: \n            count+= 1 \n    return count  ",
        "code": [
            "from collections import Counter \ndef count_Occurrence(tup, lst): \n    count = 0\n    for item in tup: \n        if item in lst: \n            count+= 1 \n    return count  "
        ],
        "pseudo": "# Initialize an empty dictionary to store the element counts\n\n# Iterate through each element in the list\n    # Check if the element exists in the tuple\n        # If it exists, increment the count in the dictionary by 1\n        # If it doesn't exist, add the element to the dictionary with a count of 1\n\n# Return the dictionary with the element counts",
        "test": [
            "assert count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'] ) == 3",
            "assert count_Occurrence((1, 2, 3, 1, 4, 6, 7, 1, 4),[1, 4, 7]) == 6",
            "assert count_Occurrence((1,2,3,4,5,6),[1,2]) == 2"
        ],
        "draft_plan": [
            "# Initialize an empty dictionary to store the element counts\n\n# Iterate through each element in the list\n    # Check if the element exists in the tuple\n        # If it exists, increment the count in the dictionary by 1\n        # If it doesn't exist, add the element to the dictionary with a count of 1\n\n# Return the dictionary with the element counts"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::map<int, int> count_occurrences(std::vector<int> lst, std::tuple<int, int, int> tpl) {\n    std::map<int, int> element_counts;\n    \n    for (int element : lst) {\n        if (std::get<0>(tpl) == element || std::get<1>(tpl) == element || std::get<2>(tpl) == element) {\n            element_counts[element]++;\n        }\n    }\n    \n    return element_counts;\n}"
        ]
    },
    {
        "id": "447",
        "prompt": "Write a function to find cubes of individual elements in a list.",
        "solution": "def cube_nums(nums):\n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums",
        "code": [
            "def cube_nums(nums):\n cube_nums = list(map(lambda x: x ** 3, nums))\n return cube_nums"
        ],
        "pseudo": "# Create an empty list to store the cubes of individual elements\n# Iterate through each element in the input list\n    # Calculate the cube of the current element by raising it to the power of 3\n    # Append the cube to the result list\n\n# Return the result list containing the cubes of individual elements",
        "test": [
            "assert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]",
            "assert cube_nums([10,20,30])==([1000, 8000, 27000])",
            "assert cube_nums([12,15])==([1728, 3375])"
        ],
        "draft_plan": [
            "# Create an empty list to store the cubes of individual elements\n# Iterate through each element in the input list\n    # Calculate the cube of the current element by raising it to the power of 3\n    # Append the cube to the result list\n\n# Return the result list containing the cubes of individual elements"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n\nstd::vector<int> find_cubes(const std::vector<int>& input_list) {\n    std::vector<int> result;\n\n    for (int num : input_list) {\n        int cube = num * num * num;\n        result.push_back(cube);\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "448",
        "prompt": "Write a function to calculate the sum of perrin numbers.",
        "solution": "def cal_sum(n): \n\ta = 3\n\tb = 0\n\tc = 2\n\tif (n == 0): \n\t\treturn 3\n\tif (n == 1): \n\t\treturn 3\n\tif (n == 2): \n\t\treturn 5\n\tsum = 5\n\twhile (n > 2): \n\t\td = a + b \n\t\tsum = sum + d \n\t\ta = b \n\t\tb = c \n\t\tc = d \n\t\tn = n-1\n\treturn sum",
        "code": [
            "def cal_sum(n): \n\ta = 3\n\tb = 0\n\tc = 2\n\tif (n == 0): \n\t\treturn 3\n\tif (n == 1): \n\t\treturn 3\n\tif (n == 2): \n\t\treturn 5\n\tsum = 5\n\twhile (n > 2): \n\t\td = a + b \n\t\tsum = sum + d \n\t\ta = b \n\t\tb = c \n\t\tc = d \n\t\tn = n-1\n\treturn sum"
        ],
        "pseudo": "# Define a function to calculate the sum of Perrin numbers up to a given limit\n\n# Initialize the first three Perrin numbers\n# Initialize the sum of Perrin numbers to 0\n\n# Iterate from 3 to the given limit\n    # Calculate the next Perrin number by summing the previous three Perrin numbers\n    # Add the current Perrin number to the sum\n\n# Return the sum of Perrin numbers",
        "test": [
            "assert cal_sum(9) == 49",
            "assert cal_sum(10) == 66",
            "assert cal_sum(11) == 88"
        ],
        "draft_plan": [
            "# Define a function to calculate the sum of Perrin numbers up to a given limit\n\n# Initialize the first three Perrin numbers\n# Initialize the sum of Perrin numbers to 0\n\n# Iterate from 3 to the given limit\n    # Calculate the next Perrin number by summing the previous three Perrin numbers\n    # Add the current Perrin number to the sum\n\n# Return the sum of Perrin numbers"
        ],
        "final_plan": [
            "#include <assert.h>\n\nint perrin_sum(int limit) {\n    if (limit == 0) {\n        return 0;\n    } else if (limit == 1) {\n        return 3;\n    } else if (limit == 2) {\n        return 4;\n    }\n\n    int perrin_0 = 3;\n    int perrin_1 = 0;\n    int perrin_2 = 2;\n    int perrin_sum = perrin_0 + perrin_1 + perrin_2;\n\n    for (int i = 3; i <= limit; i++) {\n        int next_perrin = perrin_0 + perrin_1;\n        perrin_sum += next_perrin;\n\n        perrin_0 = perrin_1;\n        perrin_1 = perrin_2;\n        perrin_2 = next_perrin;\n    }\n\n    return perrin_sum;\n}"
        ]
    },
    {
        "id": "450",
        "prompt": "Write a function to extract specified size of strings from a given list of string values.",
        "solution": "def extract_string(str, l):\n    result = [e for e in str if len(e) == l] \n    return result",
        "code": [
            "def extract_string(str, l):\n    result = [e for e in str if len(e) == l] \n    return result"
        ],
        "pseudo": "# Initialize an empty list to store the extracted strings\n\n# Iterate through each string in the given list\n    # Check if the length of the current string is equal to the specified size\n        # If it matches, append the string to the result list\n\n# Return the list of extracted strings",
        "test": [
            "assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,8)==['practice', 'solution']",
            "assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,6)==['Python']",
            "assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,9)==['exercises']"
        ],
        "draft_plan": [
            "# Initialize an empty list to store the extracted strings\n\n# Iterate through each string in the given list\n    # Check if the length of the current string is equal to the specified size\n        # If it matches, append the string to the result list\n\n# Return the list of extracted strings"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\nstd::vector<std::string> extract_strings(std::vector<std::string> string_list, int size) {\n    std::vector<std::string> extracted_strings;\n\n    for (const std::string& str : string_list) {\n        if (str.length() == size) {\n            extracted_strings.push_back(str);\n        }\n    }\n\n    return extracted_strings;\n}"
        ]
    },
    {
        "id": "451",
        "prompt": "Write a function to remove all whitespaces from the given string.",
        "solution": "import re\ndef remove_whitespaces(text1):\n  return (re.sub(r'\\s+', '',text1))",
        "code": [
            "import re\ndef remove_whitespaces(text1):\n  return (re.sub(r'\\s+', '',text1))"
        ],
        "pseudo": "# Initialize an empty string to store the modified string\n\n# Iterate through each character in the input string\n    # Check if the current character is a whitespace\n        # If it is not a whitespace, append it to the modified string\n\n# Return the modified string without whitespaces",
        "test": [
            "assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'",
            "assert remove_whitespaces(' Google    Dart ') == 'GoogleDart'",
            "assert remove_whitespaces(' iOS    Swift ') == 'iOSSwift'"
        ],
        "draft_plan": [
            "# Initialize an empty string to store the modified string\n\n# Iterate through each character in the input string\n    # Check if the current character is a whitespace\n        # If it is not a whitespace, append it to the modified string\n\n# Return the modified string without whitespaces"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <string>\n\nstd::string remove_whitespaces(std::string text) {\n    std::string modified_string = \"\";\n  \n    for (char ch : text) {\n        if (ch != ' ') {\n            modified_string += ch;\n        }\n    }\n\n    return modified_string;\n}\n\nint main() {\n    std::string text = \"Hello,    World!\";\n    std::string modified_text = remove_whitespaces(text);\n    std::cout << modified_text << std::endl;  // Output: Hello,World!\n    return 0;\n}"
        ]
    },
    {
        "id": "452",
        "prompt": "Write a function that gives loss amount on a sale if the given amount has loss else return 0.",
        "solution": "def loss_amount(actual_cost,sale_amount): \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return 0",
        "code": [
            "def loss_amount(actual_cost,sale_amount): \n  if(sale_amount > actual_cost):\n    amount = sale_amount - actual_cost\n    return amount\n  else:\n    return 0"
        ],
        "pseudo": "# Define a function that takes the given amount as input\n    # Check if the given amount is less than the selling price\n        # If it is less, calculate the loss amount by subtracting the given amount from the selling price\n        # Return the loss amount\n    # If the given amount is not less than the selling price, return 0",
        "test": [
            "assert loss_amount(1500,1200)==0",
            "assert loss_amount(100,200)==100",
            "assert loss_amount(2000,5000)==3000"
        ],
        "draft_plan": [
            "# Define a function that takes the given amount as input\n    # Check if the given amount is less than the selling price\n        # If it is less, calculate the loss amount by subtracting the given amount from the selling price\n        # Return the loss amount\n    # If the given amount is not less than the selling price, return 0"
        ],
        "final_plan": [
            "#include <assert.h>\n\ndouble calculate_loss(double given_amount, double selling_price) {\n    if (given_amount < selling_price) {\n        double loss_amount = selling_price - given_amount;\n        return loss_amount;\n    }\n    return 0;\n}"
        ]
    },
    {
        "id": "453",
        "prompt": "Write a python function to find the sum of even factors of a number.",
        "solution": "import math \ndef sumofFactors(n) : \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res",
        "code": [
            "import math \ndef sumofFactors(n) : \n    if (n % 2 != 0) : \n        return 0\n    res = 1\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \n        count = 0\n        curr_sum = 1\n        curr_term = 1\n        while (n % i == 0) : \n            count= count + 1\n            n = n // i \n            if (i == 2 and count == 1) : \n                curr_sum = 0\n            curr_term = curr_term * i \n            curr_sum = curr_sum + curr_term \n        res = res * curr_sum  \n    if (n >= 2) : \n        res = res * (1 + n) \n    return res"
        ],
        "pseudo": "# Initialize the sum of even factors to 0\n\n# Iterate from 1 to the given number (inclusive)\n    # Check if the current number is a factor of the given number\n        # Check if the current number is even\n            # If the current number is even, add it to the sum of even factors\n\n# Return the sum of even factors",
        "test": [
            "assert sumofFactors(18) == 26",
            "assert sumofFactors(30) == 48",
            "assert sumofFactors(6) == 8"
        ],
        "draft_plan": [
            "# Initialize the sum of even factors to 0\n\n# Iterate from 1 to the given number (inclusive)\n    # Check if the current number is a factor of the given number\n        # Check if the current number is even\n            # If the current number is even, add it to the sum of even factors\n\n# Return the sum of even factors"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n\nint sum_even_factors(int num) {\n    int sum = 0;\n\n    for (int i = 1; i <= num; i++) {\n        if (num % i == 0 && i % 2 == 0) {\n            sum += i;\n        }\n    }\n\n    return sum;\n}"
        ]
    },
    {
        "id": "454",
        "prompt": "Write a function that matches a word containing 'z'.",
        "solution": "import re\ndef text_match_wordz(text):\n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False",
        "code": [
            "import re\ndef text_match_wordz(text):\n        patterns = '\\w*z.\\w*'\n        if re.search(patterns,  text):\n                return True\n        else:\n                return False"
        ],
        "pseudo": "# Iterate through each word in the given list\n    # Check if the character 'z' is present in the word\n        # If 'z' is found, add the word to a new list\n\n# Return the new list containing words with 'z'",
        "test": [
            "assert text_match_wordz(\"pythonz.\")==True",
            "assert text_match_wordz(\"xyz.\")==True",
            "assert text_match_wordz(\"  lang  .\")==False"
        ],
        "draft_plan": [
            "# Iterate through each word in the given list\n    # Check if the character 'z' is present in the word\n        # If 'z' is found, add the word to a new list\n\n# Return the new list containing words with 'z'"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> match_words_with_z(const std::vector<std::string>& word_list) {\n    std::vector<std::string> words_with_z;\n\n    for (const std::string& word : word_list) {\n        if (word.find('z') != std::string::npos) {\n            words_with_z.push_back(word);\n        }\n    }\n\n    return words_with_z;\n}\n\nint main() {\n    std::vector<std::string> words = {\"hello\", \"world\", \"zebra\", \"pizza\"};\n    std::vector<std::string> matched_words = match_words_with_z(words);\n\n    for (const std::string& word : matched_words) {\n        std::cout << word << \" \";\n    }\n\n    return 0;\n}"
        ]
    },
    {
        "id": "455",
        "prompt": "Write a function to check whether the given month number contains 31 days or not.",
        "solution": "def check_monthnumb_number(monthnum2):\n  if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):\n    return True\n  else:\n    return False",
        "code": [
            "def check_monthnumb_number(monthnum2):\n  if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):\n    return True\n  else:\n    return False"
        ],
        "pseudo": "# Create a list of months with 31 days\n    # Use the month numbers from 1 to 12\n\n# Check if the given month number is in the list of months with 31 days\n    # If it is, return True\n    # Otherwise, return False",
        "test": [
            "assert check_monthnumb_number(5)==True",
            "assert check_monthnumb_number(2)==False",
            "assert check_monthnumb_number(6)==False"
        ],
        "draft_plan": [
            "# Create a list of months with 31 days\n    # Use the month numbers from 1 to 12\n\n# Check if the given month number is in the list of months with 31 days\n    # If it is, return True\n    # Otherwise, return False"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nbool has_31_days(int month) {\n    std::vector<int> months_with_31_days = {1, 3, 5, 7, 8, 10, 12};\n\n    return std::find(months_with_31_days.begin(), months_with_31_days.end(), month) != months_with_31_days.end();\n}"
        ]
    },
    {
        "id": "456",
        "prompt": "Write a function to reverse each string in a given list of string values.",
        "solution": "def reverse_string_list(stringlist):\n    result = [x[::-1] for x in stringlist]\n    return result",
        "code": [
            "def reverse_string_list(stringlist):\n    result = [x[::-1] for x in stringlist]\n    return result"
        ],
        "pseudo": "# Iterate through each string in the given list\n    # Reverse the current string using string slicing\n    # Update the current string in the list with the reversed string\n\n# Return the modified list",
        "test": [
            "assert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])==['deR', 'neerG', 'eulB', 'etihW', 'kcalB']",
            "assert reverse_string_list(['john','amal','joel','george'])==['nhoj','lama','leoj','egroeg']",
            "assert reverse_string_list(['jack','john','mary'])==['kcaj','nhoj','yram']"
        ],
        "draft_plan": [
            "# Iterate through each string in the given list\n    # Reverse the current string using string slicing\n    # Update the current string in the list with the reversed string\n\n# Return the modified list"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::vector<std::string> reverse_strings(std::vector<std::string> string_list) {\n    for (std::string& str : string_list) {\n        std::reverse(str.begin(), str.end());\n    }\n\n    return string_list;\n}"
        ]
    },
    {
        "id": "457",
        "prompt": "Write a python function to find the sublist having minimum length.",
        "solution": "def Find_Min(lst): \n    return min(lst, key=len) ",
        "code": [
            "def Find_Min(lst): \n    return min(lst, key=len) "
        ],
        "pseudo": "# If the input list is empty, return an empty list\n\n# Initialize the minimum length variable to a large value and the minimum sublist to an empty list\n\n# Iterate through each sublist in the input list\n    # If the length of the current sublist is less than the minimum length\n        # Update the minimum length and the minimum sublist\n\n# Return the minimum sublist",
        "test": [
            "assert Find_Min([[1],[1,2],[1,2,3]]) == [1]",
            "assert Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]",
            "assert Find_Min([['x'],['x','y'],['x','y','z']]) == ['x']"
        ],
        "draft_plan": [
            "# If the input list is empty, return an empty list\n\n# Initialize the minimum length variable to a large value and the minimum sublist to an empty list\n\n# Iterate through each sublist in the input list\n    # If the length of the current sublist is less than the minimum length\n        # Update the minimum length and the minimum sublist\n\n# Return the minimum sublist"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\nstd::vector<int> find_minimum_sublist(const std::vector<std::vector<int>>& input_list) {\n    if (input_list.empty()) {\n        return {};\n    }\n\n    int min_length = INT_MAX;\n    std::vector<int> min_sublist;\n\n    for (const auto& sublist : input_list) {\n        if (sublist.size() < min_length) {\n            min_length = sublist.size();\n            min_sublist = sublist;\n        }\n    }\n\n    return min_sublist;\n}"
        ]
    },
    {
        "id": "458",
        "prompt": "Write a function to find the area of a rectangle.",
        "solution": "def rectangle_area(l,b):\n  area=l*b\n  return area",
        "code": [
            "def rectangle_area(l,b):\n  area=l*b\n  return area"
        ],
        "pseudo": "To find the area of a rectangle, we need the length and width of the rectangle. The formula to calculate the area of a rectangle is:\n\nArea = length * width\n\nHere is the code logic to find the area of a rectangle:\n\n1. Define a function named `calculate_area` that takes two parameters, `length` and `width`.\n2. Inside the function, calculate the area by multiplying the `length` and `width` parameters.\n3. Return the calculated area from the function.\n\nHere is the code implementation in Python:\n\n```python\ndef calculate_area(length, width):\n    area = length * width\n    return area\n\n# Example usage:\nlength = 5\nwidth = 3\narea = calculate_area(length, width)\nprint(\"The area of the rectangle is:\", area)\n```\n\nThis will output:\n```\nThe area of the rectangle is: 15\n```\n\nYou can replace the values of `length` and `width` with your own values to find the area of a different rectangle.",
        "test": [
            "assert rectangle_area(10,20)==200",
            "assert rectangle_area(10,5)==50",
            "assert rectangle_area(4,2)==8"
        ],
        "draft_plan": [
            "To find the area of a rectangle, we need the length and width of the rectangle. The formula to calculate the area of a rectangle is:\n\nArea = length * width\n\nHere is the code logic to find the area of a rectangle:\n\n1. Define a function named `calculate_area` that takes two parameters, `length` and `width`.\n2. Inside the function, calculate the area by multiplying the `length` and `width` parameters.\n3. Return the calculated area from the function.\n\nHere is the code implementation in Python:\n\n```python\ndef calculate_area(length, width):\n    area = length * width\n    return area\n\n# Example usage:\nlength = 5\nwidth = 3\narea = calculate_area(length, width)\nprint(\"The area of the rectangle is:\", area)\n```\n\nThis will output:\n```\nThe area of the rectangle is: 15\n```\n\nYou can replace the values of `length` and `width` with your own values to find the area of a different rectangle."
        ],
        "final_plan": [
            "```cpp\n#include <iostream>\n\nint calculate_area(int length, int width) {\n    int area = length * width;\n    return area;\n}\n\nint main() {\n    int length = 5;\n    int width = 3;\n    int area = calculate_area(length, width);\n    std::cout << \"The area of the rectangle is: \" << area << std::endl;\n    \n    return 0;\n}\n```\n\nThis will output:\n```\nThe area of the rectangle is: 15\n```\n\nYou can replace the values of `length` and `width` with your own values to find the area of a different rectangle."
        ]
    },
    {
        "id": "459",
        "prompt": "Write a function to remove uppercase substrings from a given string.",
        "solution": "import re\ndef remove_uppercase(str1):\n  return re.sub('[A-Z]', '', str1)",
        "code": [
            "import re\ndef remove_uppercase(str1):\n  return re.sub('[A-Z]', '', str1)"
        ],
        "pseudo": "# Initialize an empty string to store the result\n\n# Iterate through each character in the input string\n    # Check if the current character is lowercase\n        # If it is lowercase, append it to the result string\n\n# Return the result string",
        "test": [
            "assert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'",
            "assert remove_uppercase('wAtchTheinTernEtrAdIo') == 'wtchheinerntrdo'",
            "assert remove_uppercase('VoicESeaRchAndreComMendaTionS') == 'oiceachndreomendaion'"
        ],
        "draft_plan": [
            "# Initialize an empty string to store the result\n\n# Iterate through each character in the input string\n    # Check if the current character is lowercase\n        # If it is lowercase, append it to the result string\n\n# Return the result string"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <string>\n\nstd::string remove_uppercase_substrings(const std::string& input_string) {\n    std::string result;\n\n    for (char c : input_string) {\n        if (std::islower(c)) {\n            result += c;\n        }\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "460",
        "prompt": "Write a python function to get the first element of each sublist.",
        "solution": "def Extract(lst): \n    return [item[0] for item in lst] ",
        "code": [
            "def Extract(lst): \n    return [item[0] for item in lst] "
        ],
        "pseudo": "# Create an empty list to store the first elements of each sublist\n\n# Iterate through each sublist in the input list\n    # Append the first element of the current sublist to the result list\n\n# Return the result list",
        "test": [
            "assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]",
            "assert Extract([[1,2,3],[4, 5]]) == [1,4]",
            "assert Extract([[9,8,1],[1,2]]) == [9,1]"
        ],
        "draft_plan": [
            "# Create an empty list to store the first elements of each sublist\n\n# Iterate through each sublist in the input list\n    # Append the first element of the current sublist to the result list\n\n# Return the result list"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\nstd::vector<int> get_first_elements(std::vector<std::vector<int>> input_list) {\n    std::vector<int> result;\n  \n    for (const auto& sublist : input_list) {\n        if (!sublist.empty()) {\n            result.push_back(sublist[0]);\n        }\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "461",
        "prompt": "Write a python function to count the upper case characters in a given string.",
        "solution": "def upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\n          return upper_ctr",
        "code": [
            "def upper_ctr(str):\n    upper_ctr = 0\n    for i in range(len(str)):\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\n          return upper_ctr"
        ],
        "pseudo": "# Initialize a counter variable to keep track of the number of uppercase characters\n\n# Iterate through each character in the input string\n    # Check if the current character is uppercase\n        # If it is, increment the counter variable\n\n# Return the counter variable, which represents the number of uppercase characters in the string",
        "test": [
            "assert upper_ctr('PYthon') == 1",
            "assert upper_ctr('BigData') == 1",
            "assert upper_ctr('program') == 0"
        ],
        "draft_plan": [
            "# Initialize a counter variable to keep track of the number of uppercase characters\n\n# Iterate through each character in the input string\n    # Check if the current character is uppercase\n        # If it is, increment the counter variable\n\n# Return the counter variable, which represents the number of uppercase characters in the string"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint count_uppercase(std::string text) {\n    int count = 0;\n    for (char c : text) {\n        if (std::isupper(c)) {\n            count++;\n        }\n    }\n    return count;\n}"
        ]
    },
    {
        "id": "462",
        "prompt": "Write a function to find all possible combinations of the elements of a given list.",
        "solution": "def combinations_list(list1):\n    if len(list1) == 0:\n        return [[]]\n    result = []\n    for el in combinations_list(list1[1:]):\n        result += [el, el+[list1[0]]]\n    return result",
        "code": [
            "def combinations_list(list1):\n    if len(list1) == 0:\n        return [[]]\n    result = []\n    for el in combinations_list(list1[1:]):\n        result += [el, el+[list1[0]]]\n    return result"
        ],
        "pseudo": "# Import the combinations function from the itertools module\n\n# Define the function to find all possible combinations\n    # Initialize an empty list to store the combinations\n    \n    # Use a for loop to iterate through different combination lengths\n        # Generate all combinations of the given list for the current combination length\n        # Append the combinations to the result list\n    \n    # Return the list of all possible combinations",
        "test": [
            "assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]",
            "assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]",
            "assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]"
        ],
        "draft_plan": [
            "# Import the combinations function from the itertools module\n\n# Define the function to find all possible combinations\n    # Initialize an empty list to store the combinations\n    \n    # Use a for loop to iterate through different combination lengths\n        # Generate all combinations of the given list for the current combination length\n        # Append the combinations to the result list\n    \n    # Return the list of all possible combinations"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> find_combinations(std::vector<int>& nums) {\n    std::vector<std::vector<int>> combinations;\n\n    // Sort the input list to ensure unique combinations\n    std::sort(nums.begin(), nums.end());\n\n    // Find all possible combinations\n    for (int r = 1; r <= nums.size(); r++) {\n        std::vector<int> combination(r);\n        std::vector<bool> chosen(nums.size(), false);\n        \n        generate_combinations(nums, combination, chosen, combinations, 0, 0, r);\n    }\n\n    return combinations;\n}\n\nvoid generate_combinations(std::vector<int>& nums, std::vector<int>& combination, std::vector<bool>& chosen, std::vector<std::vector<int>>& combinations, int start, int current, int r) {\n    if (current == r) {\n        combinations.push_back(combination);\n        return;\n    }\n\n    for (int i = start; i < nums.size(); i++) {\n        if (!chosen[i]) {\n            combination[current] = nums[i];\n            chosen[i] = true;\n            generate_combinations(nums, combination, chosen, combinations, i + 1, current + 1, r);\n            chosen[i] = false;\n        }\n    }\n}\n\nint main() {\n    std::vector<int> nums = {1, 2, 3};\n    std::vector<std::vector<int>> combinations = find_combinations(nums);\n\n    // Print the combinations\n    for (const auto& combination : combinations) {\n        std::cout << \"[\";\n        for (int i = 0; i < combination.size(); i++) {\n            std::cout << combination[i];\n            if (i < combination.size() - 1) {\n                std::cout << \", \";\n            }\n        }\n        std::cout << \"]\" << std::endl;\n    }\n\n    return 0;\n}"
        ]
    },
    {
        "id": "463",
        "prompt": "Write a function to find the maximum product subarray of the given array.",
        "solution": "def max_subarray_product(arr):\n\tn = len(arr)\n\tmax_ending_here = 1\n\tmin_ending_here = 1\n\tmax_so_far = 0\n\tflag = 0\n\tfor i in range(0, n):\n\t\tif arr[i] > 0:\n\t\t\tmax_ending_here = max_ending_here * arr[i]\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\n\t\t\tflag = 1\n\t\telif arr[i] == 0:\n\t\t\tmax_ending_here = 1\n\t\t\tmin_ending_here = 1\n\t\telse:\n\t\t\ttemp = max_ending_here\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\n\t\t\tmin_ending_here = temp * arr[i]\n\t\tif (max_so_far < max_ending_here):\n\t\t\tmax_so_far = max_ending_here\n\tif flag == 0 and max_so_far == 0:\n\t\treturn 0\n\treturn max_so_far",
        "code": [
            "def max_subarray_product(arr):\n\tn = len(arr)\n\tmax_ending_here = 1\n\tmin_ending_here = 1\n\tmax_so_far = 0\n\tflag = 0\n\tfor i in range(0, n):\n\t\tif arr[i] > 0:\n\t\t\tmax_ending_here = max_ending_here * arr[i]\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\n\t\t\tflag = 1\n\t\telif arr[i] == 0:\n\t\t\tmax_ending_here = 1\n\t\t\tmin_ending_here = 1\n\t\telse:\n\t\t\ttemp = max_ending_here\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\n\t\t\tmin_ending_here = temp * arr[i]\n\t\tif (max_so_far < max_ending_here):\n\t\t\tmax_so_far = max_ending_here\n\tif flag == 0 and max_so_far == 0:\n\t\treturn 0\n\treturn max_so_far"
        ],
        "pseudo": "# Initialize variables to store the maximum product, current maximum product, current minimum product, and the result\n# Set the maximum product and current maximum product to the first element of the array\n# Iterate through each element in the array starting from the second element\n    # Update the current maximum product and current minimum product by considering the current element\n    # Check if the current element is negative\n        # If it is negative, swap the current maximum product and current minimum product\n    # Check if the current maximum product is greater than the maximum product\n        # If it is, update the maximum product\n    # Check if the current element is greater than the current maximum product\n        # If it is, update the current maximum product\n    # Check if the current element is less than the current minimum product\n        # If it is, update the current minimum product\n    # Check if the maximum product is greater than the result\n        # If it is, update the result\n\n# Return the result",
        "test": [
            "assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112",
            "assert max_subarray_product([6, -3, -10, 0, 2]) == 180",
            "assert max_subarray_product([-2, -40, 0, -2, -3]) == 80"
        ],
        "draft_plan": [
            "# Initialize variables to store the maximum product, current maximum product, current minimum product, and the result\n# Set the maximum product and current maximum product to the first element of the array\n# Iterate through each element in the array starting from the second element\n    # Update the current maximum product and current minimum product by considering the current element\n    # Check if the current element is negative\n        # If it is negative, swap the current maximum product and current minimum product\n    # Check if the current maximum product is greater than the maximum product\n        # If it is, update the maximum product\n    # Check if the current element is greater than the current maximum product\n        # If it is, update the current maximum product\n    # Check if the current element is less than the current minimum product\n        # If it is, update the current minimum product\n    # Check if the maximum product is greater than the result\n        # If it is, update the result\n\n# Return the result"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <vector>\n\nlong long maxProductSubarray(std::vector<int>& nums) {\n    int n = nums.size();\n    if (n == 0) {\n        return 0;\n    }\n\n    long long maximumProduct = nums[0];\n    long long currentMaximum = nums[0];\n    long long currentMinimum = nums[0];\n    long long result = nums[0];\n\n    for (int i = 1; i < n; i++) {\n        if (nums[i] < 0) {\n            std::swap(currentMaximum, currentMinimum);\n        }\n\n        currentMaximum = std::max((long long)nums[i], currentMaximum * nums[i]);\n        currentMinimum = std::min((long long)nums[i], currentMinimum * nums[i]);\n\n        maximumProduct = std::max(maximumProduct, currentMaximum);\n        result = std::max(result, maximumProduct);\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "464",
        "prompt": "Write a function to check if all values are same in a dictionary.",
        "solution": "def check_value(dict, n):\n    result = all(x == n for x in dict.values()) \n    return result",
        "code": [
            "def check_value(dict, n):\n    result = all(x == n for x in dict.values()) \n    return result"
        ],
        "pseudo": "# Get the first value from the dictionary\n# Iterate through all the values in the dictionary\n    # Check if the current value is equal to the first value\n        # If not equal, return False\n\n# If all values are equal, return True",
        "test": [
            "assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False",
            "assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True",
            "assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False"
        ],
        "draft_plan": [
            "# Get the first value from the dictionary\n# Iterate through all the values in the dictionary\n    # Check if the current value is equal to the first value\n        # If not equal, return False\n\n# If all values are equal, return True"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n\nbool check_all_same_values(std::unordered_map<std::string, int> dict) {\n    if (dict.empty()) {\n        return true;\n    }\n\n    int first_value = dict.begin()->second;\n\n    for (const auto& pair : dict) {\n        if (pair.second != first_value) {\n            return false;\n        }\n    }\n\n    return true;\n}"
        ]
    },
    {
        "id": "465",
        "prompt": "Write a function to drop empty items from a given dictionary.",
        "solution": "def drop_empty(dict1):\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1",
        "code": [
            "def drop_empty(dict1):\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\n  return dict1"
        ],
        "pseudo": "# Initialize an empty dictionary to store the non-empty items\n\n# Iterate through each key-value pair in the given dictionary\n    # Check if the value is not empty\n        # If not empty, add the key-value pair to the new dictionary\n\n# Return the new dictionary",
        "test": [
            "assert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None})=={'c1': 'Red', 'c2': 'Green'}",
            "assert drop_empty({'c1': 'Red', 'c2': None, 'c3':None})=={'c1': 'Red'}",
            "assert drop_empty({'c1': None, 'c2': 'Green', 'c3':None})=={ 'c2': 'Green'}"
        ],
        "draft_plan": [
            "# Initialize an empty dictionary to store the non-empty items\n\n# Iterate through each key-value pair in the given dictionary\n    # Check if the value is not empty\n        # If not empty, add the key-value pair to the new dictionary\n\n# Return the new dictionary"
        ],
        "final_plan": [
            "#include <cassert>\n#include <iostream>\n#include <map>\n#include <string>\n\nstd::map<std::string, std::string> drop_empty_items(const std::map<std::string, std::string>& dictionary) {\n    std::map<std::string, std::string> new_dictionary;\n\n    for (const auto& pair : dictionary) {\n        if (!pair.second.empty()) {\n            new_dictionary[pair.first] = pair.second;\n        }\n    }\n\n    return new_dictionary;\n}"
        ]
    },
    {
        "id": "468",
        "prompt": "Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.",
        "solution": "def max_product(arr):   \n  n = len(arr)\n  mpis = arr[:]\n  for i in range(n): \n    current_prod = arr[i]\n    j = i + 1\n    while j < n:\n      if arr[j-1] > arr[j]: \n        break\n      current_prod *= arr[j]\n      if current_prod > mpis[j]:\n        mpis[j] = current_prod \n      j = j + 1\n  return max(mpis)",
        "code": [
            "def max_product(arr):   \n  n = len(arr)\n  mpis = arr[:]\n  for i in range(n): \n    current_prod = arr[i]\n    j = i + 1\n    while j < n:\n      if arr[j-1] > arr[j]: \n        break\n      current_prod *= arr[j]\n      if current_prod > mpis[j]:\n        mpis[j] = current_prod \n      j = j + 1\n  return max(mpis)"
        ],
        "pseudo": "# Initialize the maximum product as 1\n# Initialize an empty list to store the increasing subsequence\n\n# Iterate through each number in the array\n    # Initialize a temporary list to store the current increasing subsequence\n    # Iterate through each number before the current number\n        # Check if the current number is greater than the previous number and if the product of the current number and the previous maximum product is greater than the current maximum product\n            # If the condition is satisfied, update the maximum product and the temporary list with the current increasing subsequence\n    # Append the current number to the temporary list\n\n# Return the maximum product and the increasing subsequence list",
        "test": [
            "assert max_product([3, 100, 4, 5, 150, 6]) == 3000",
            "assert max_product([4, 42, 55, 68, 80]) == 50265600",
            "assert max_product([10, 22, 9, 33, 21, 50, 41, 60]) == 2460"
        ],
        "draft_plan": [
            "# Initialize the maximum product as 1\n# Initialize an empty list to store the increasing subsequence\n\n# Iterate through each number in the array\n    # Initialize a temporary list to store the current increasing subsequence\n    # Iterate through each number before the current number\n        # Check if the current number is greater than the previous number and if the product of the current number and the previous maximum product is greater than the current maximum product\n            # If the condition is satisfied, update the maximum product and the temporary list with the current increasing subsequence\n    # Append the current number to the temporary list\n\n# Return the maximum product and the increasing subsequence list"
        ],
        "final_plan": [
            "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::pair<long long, std::vector<int>> max_product_increasing_subsequence(std::vector<int> arr) {\n    long long max_product = 1;\n    std::vector<int> increasing_subsequence;\n\n    for (int i = 0; i < arr.size(); i++) {\n        std::vector<int> temp;\n        temp.push_back(arr[i]);\n\n        for (int j = 0; j < i; j++) {\n            if (arr[i] > arr[j] && arr[i] * max_product > max_product) {\n                max_product = arr[i] * max_product;\n                temp = increasing_subsequence;\n            }\n        }\n\n        temp.push_back(arr[i]);\n        increasing_subsequence = temp;\n    }\n\n    return std::make_pair(max_product, increasing_subsequence);\n}"
        ]
    },
    {
        "id": "470",
        "prompt": "Write a function to find the pairwise addition of the neighboring elements of the given tuple.",
        "solution": "def add_pairwise(test_tup):\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) ",
        "code": [
            "def add_pairwise(test_tup):\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\n  return (res) "
        ],
        "pseudo": "# Initialize an empty list to store the pairwise addition results\n\n# Iterate through the elements in the tuple up to the second to last element\n    # Compute the pairwise addition of the current element and its neighboring element\n    # Append the result to the list\n\n# Return the list of pairwise addition results",
        "test": [
            "assert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)",
            "assert add_pairwise((2, 6, 8, 9, 11)) == (8, 14, 17, 20)",
            "assert add_pairwise((3, 7, 9, 10, 12)) == (10, 16, 19, 22)"
        ],
        "draft_plan": [
            "# Initialize an empty list to store the pairwise addition results\n\n# Iterate through the elements in the tuple up to the second to last element\n    # Compute the pairwise addition of the current element and its neighboring element\n    # Append the result to the list\n\n# Return the list of pairwise addition results"
        ],
        "final_plan": [
            "#include <bits/stdc++.h>\n#include <cassert>\n\nstd::vector<int> pairwise_addition(std::tuple<int, int, int, int> t) {\n    std::vector<int> results;\n\n    results.push_back(std::get<0>(t) + std::get<1>(t));\n    results.push_back(std::get<1>(t) + std::get<2>(t));\n    results.push_back(std::get<2>(t) + std::get<3>(t));\n\n    return results;\n}"
        ]
    },
    {
        "id": "471",
        "prompt": "Write a python function to find the product of the array multiplication modulo n.",
        "solution": "def find_remainder(arr, n): \n    mul = 1\n    for i in range(len(arr)):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n ",
        "code": [
            "def find_remainder(arr, n): \n    mul = 1\n    for i in range(len(arr)):  \n        mul = (mul * (arr[i] % n)) % n \n    return mul % n "
        ],
        "pseudo": "# Initialize the product to 1\n\n# Iterate through each element in the array\n    # Multiply the current element with the product\n    # Take the modulo of the product with n\n\n# Return the final product modulo n",
        "test": [
            "assert find_remainder([ 100, 10, 5, 25, 35, 14 ],11) ==9",
            "assert find_remainder([1,1,1],1) == 0",
            "assert find_remainder([1,2,1],2) == 0"
        ],
        "draft_plan": [
            "# Initialize the product to 1\n\n# Iterate through each element in the array\n    # Multiply the current element with the product\n    # Take the modulo of the product with n\n\n# Return the final product modulo n"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n\nint array_product_modulo_n(std::vector<int> arr, int n) {\n    int product = 1;\n\n    for (int num : arr) {\n        product = (product * num) % n;\n    }\n\n    return product;\n}"
        ]
    },
    {
        "id": "472",
        "prompt": "Write a python function to check whether the given list contains consecutive numbers or not.",
        "solution": "def check_Consecutive(l): \n    return sorted(l) == list(range(min(l),max(l)+1)) ",
        "code": [
            "def check_Consecutive(l): \n    return sorted(l) == list(range(min(l),max(l)+1)) "
        ],
        "pseudo": "# Sort the input list in ascending order\n\n# Iterate through each number in the sorted list, starting from the second number\n    # Check if the current number is consecutive to the previous number\n        # If not, return False\n\n# If all numbers are consecutive, return True",
        "test": [
            "assert check_Consecutive([1,2,3,4,5]) == True",
            "assert check_Consecutive([1,2,3,5,6]) == False",
            "assert check_Consecutive([1,2,1]) == False"
        ],
        "draft_plan": [
            "# Sort the input list in ascending order\n\n# Iterate through each number in the sorted list, starting from the second number\n    # Check if the current number is consecutive to the previous number\n        # If not, return False\n\n# If all numbers are consecutive, return True"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nbool contains_consecutive(std::vector<int> nums) {\n    std::sort(nums.begin(), nums.end());\n\n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] != nums[i-1] + 1) {\n            return false;\n        }\n    }\n\n    return true;\n}"
        ]
    },
    {
        "id": "473",
        "prompt": "Write a function to find the tuple intersection of elements in the given tuple list irrespective of their order.",
        "solution": "def tuple_intersection(test_list1, test_list2):\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\n  return (res)",
        "code": [
            "def tuple_intersection(test_list1, test_list2):\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\n  return (res)"
        ],
        "pseudo": "# Initialize the intersection as the first tuple in the given tuple list\n\n# Iterate through each tuple in the given tuple list starting from the second tuple\n    # Initialize the current intersection as an empty list\n\n    # Iterate through each element in the current tuple\n        # Check if the element is present in the previous intersection\n            # If yes, append the element to the current intersection\n\n    # Update the intersection as the current intersection\n\n# Return the intersection",
        "test": [
            "assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}",
            "assert tuple_intersection([(4, 1), (7, 4), (11, 13), (17, 14)] , [(1, 4), (7, 4), (16, 12), (10, 13)]) == {(4, 7), (1, 4)}",
            "assert tuple_intersection([(2, 1), (3, 2), (1, 3), (1, 4)] , [(11, 2), (2, 3), (6, 2), (1, 3)]) == {(1, 3), (2, 3)}"
        ],
        "draft_plan": [
            "# Initialize the intersection as the first tuple in the given tuple list\n\n# Iterate through each tuple in the given tuple list starting from the second tuple\n    # Initialize the current intersection as an empty list\n\n    # Iterate through each element in the current tuple\n        # Check if the element is present in the previous intersection\n            # If yes, append the element to the current intersection\n\n    # Update the intersection as the current intersection\n\n# Return the intersection"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> tuple_intersection(const std::vector<std::vector<int>>& tuple_list) {\n    std::vector<int> intersection = tuple_list[0];\n\n    for (int i = 1; i < tuple_list.size(); i++) {\n        std::vector<int> current_intersection;\n\n        for (int j = 0; j < tuple_list[i].size(); j++) {\n            if (std::find(intersection.begin(), intersection.end(), tuple_list[i][j]) != intersection.end()) {\n                current_intersection.push_back(tuple_list[i][j]);\n            }\n        }\n\n        intersection = current_intersection;\n    }\n\n    return intersection;\n}"
        ]
    },
    {
        "id": "474",
        "prompt": "Write a function to replace characters in a string.",
        "solution": "def replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2",
        "code": [
            "def replace_char(str1,ch,newch):\n str2 = str1.replace(ch, newch)\n return str2"
        ],
        "pseudo": "# Initialize an empty string to store the modified string\n\n# Iterate through each character in the input string\n    # Check if the character needs to be replaced\n        # If replacement is required, append the replacement character to the modified string\n        # Otherwise, append the original character to the modified string\n\n# Return the modified string",
        "test": [
            "assert replace_char(\"polygon\",'y','l')==(\"pollgon\")",
            "assert replace_char(\"character\",'c','a')==(\"aharaater\")",
            "assert replace_char(\"python\",'l','a')==(\"python\")"
        ],
        "draft_plan": [
            "# Initialize an empty string to store the modified string\n\n# Iterate through each character in the input string\n    # Check if the character needs to be replaced\n        # If replacement is required, append the replacement character to the modified string\n        # Otherwise, append the original character to the modified string\n\n# Return the modified string"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::string replace_characters(std::string input_string, char original_char, char replacement_char) {\n    std::string modified_string;\n\n    for (char c : input_string) {\n        if (c == original_char) {\n            modified_string += replacement_char;\n        } else {\n            modified_string += c;\n        }\n    }\n\n    return modified_string;\n}"
        ]
    },
    {
        "id": "475",
        "prompt": "Write a function to sort a dictionary by value.",
        "solution": "from collections import Counter\ndef sort_counter(dict1):\n x = Counter(dict1)\n sort_counter=x.most_common()\n return sort_counter",
        "code": [
            "from collections import Counter\ndef sort_counter(dict1):\n x = Counter(dict1)\n sort_counter=x.most_common()\n return sort_counter"
        ],
        "pseudo": "# Use the sorted() function with a lambda function as the key parameter\n# The lambda function takes each key-value pair from the dictionary and returns the value\n# The sorted() function will sort the dictionary based on the values in ascending order\n# Pass the sorted dictionary to the dict() function to convert it back to a dictionary type\n\ndef sort_dict_by_value(dictionary):\n    sorted_dict = dict(sorted(dictionary.items(), key=lambda item: item[1]))\n    return sorted_dict",
        "test": [
            "assert sort_counter({'Math':81, 'Physics':83, 'Chemistry':87})==[('Chemistry', 87), ('Physics', 83), ('Math', 81)]",
            "assert sort_counter({'Math':400, 'Physics':300, 'Chemistry':250})==[('Math', 400), ('Physics', 300), ('Chemistry', 250)]",
            "assert sort_counter({'Math':900, 'Physics':1000, 'Chemistry':1250})==[('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]"
        ],
        "draft_plan": [
            "# Use the sorted() function with a lambda function as the key parameter\n# The lambda function takes each key-value pair from the dictionary and returns the value\n# The sorted() function will sort the dictionary based on the values in ascending order\n# Pass the sorted dictionary to the dict() function to convert it back to a dictionary type\n\ndef sort_dict_by_value(dictionary):\n    sorted_dict = dict(sorted(dictionary.items(), key=lambda item: item[1]))\n    return sorted_dict"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::map<std::string, int> sort_dict_by_value(std::map<std::string, int> dictionary) {\n    std::vector<std::pair<std::string, int>> dict_vec(dictionary.begin(), dictionary.end());\n    std::sort(dict_vec.begin(), dict_vec.end(), [](const std::pair<std::string, int>& a, const std::pair<std::string, int>& b) {\n        return a.second < b.second;\n    });\n\n    std::map<std::string, int> sorted_dict;\n    for (const auto& pair : dict_vec) {\n        sorted_dict[pair.first] = pair.second;\n    }\n\n    return sorted_dict;\n}"
        ]
    },
    {
        "id": "476",
        "prompt": "Write a python function to find the sum of the largest and smallest value in a given array.",
        "solution": "def big_sum(nums):\n      sum= max(nums)+min(nums)\n      return sum",
        "code": [
            "def big_sum(nums):\n      sum= max(nums)+min(nums)\n      return sum"
        ],
        "pseudo": "# Sort the array in ascending order\n# Initialize variables for the smallest and largest values\n\n# Get the smallest value from the sorted array (first element)\n# Get the largest value from the sorted array (last element)\n\n# Calculate the sum of the smallest and largest values\n\n# Return the sum",
        "test": [
            "assert big_sum([1,2,3]) == 4",
            "assert big_sum([-1,2,3,4]) == 3",
            "assert big_sum([2,3,6]) == 8"
        ],
        "draft_plan": [
            "# Sort the array in ascending order\n# Initialize variables for the smallest and largest values\n\n# Get the smallest value from the sorted array (first element)\n# Get the largest value from the sorted array (last element)\n\n# Calculate the sum of the smallest and largest values\n\n# Return the sum"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nint sum_of_smallest_and_largest(std::vector<int> array) {\n    std::sort(array.begin(), array.end());\n    int smallest = array[0];\n    int largest = array[array.size() - 1];\n    int sum = smallest + largest;\n    return sum;\n}"
        ]
    },
    {
        "id": "477",
        "prompt": "Write a python function to convert the given string to lower case.",
        "solution": "def is_lower(string):\n  return (string.lower())",
        "code": [
            "def is_lower(string):\n  return (string.lower())"
        ],
        "pseudo": "# Convert the input string to lower case using the lower() method\n# Return the lower case string",
        "test": [
            "assert is_lower(\"InValid\") == \"invalid\"",
            "assert is_lower(\"TruE\") == \"true\"",
            "assert is_lower(\"SenTenCE\") == \"sentence\""
        ],
        "draft_plan": [
            "# Convert the input string to lower case using the lower() method\n# Return the lower case string"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <algorithm>\n#include <cctype>\n#include <string>\n\nstd::string to_lower_case(std::string text) {\n    std::transform(text.begin(), text.end(), text.begin(), [](unsigned char c) {\n        return std::tolower(c);\n    });\n    return text;\n}"
        ]
    },
    {
        "id": "478",
        "prompt": "Write a function to remove lowercase substrings from a given string.",
        "solution": "import re\ndef remove_lowercase(str1):\n return re.sub('[a-z]', '', str1)",
        "code": [
            "import re\ndef remove_lowercase(str1):\n return re.sub('[a-z]', '', str1)"
        ],
        "pseudo": "# Initialize an empty string to store the final result\n\n# Iterate through each character in the given string\n    # Check if the character is uppercase\n        # If the character is uppercase, append it to the final result string\n\n# Return the final result string",
        "test": [
            "assert remove_lowercase(\"PYTHon\")==('PYTH')",
            "assert remove_lowercase(\"FInD\")==('FID')",
            "assert remove_lowercase(\"STRinG\")==('STRG')"
        ],
        "draft_plan": [
            "# Initialize an empty string to store the final result\n\n# Iterate through each character in the given string\n    # Check if the character is uppercase\n        # If the character is uppercase, append it to the final result string\n\n# Return the final result string"
        ],
        "final_plan": [
            "#include <assert.h>\n#include <bits/stdc++.h>\n\nstd::string remove_lowercase_substrings(std::string input_string) {\n    std::string result;\n\n    for (char c : input_string) {\n        if (std::isupper(c)) {\n            result += c;\n        }\n    }\n\n    return result;\n}"
        ]
    },
    {
        "id": "479",
        "prompt": "Write a python function to find the first digit of a given number.",
        "solution": "def first_Digit(n) :  \n    while n >= 10:  \n        n = n / 10 \n    return int(n) ",
        "code": [
            "def first_Digit(n) :  \n    while n >= 10:  \n        n = n / 10 \n    return int(n) "
        ],
        "pseudo": "# Convert the given number to a string\n\n# Iterate through each character in the string\n    # Check if the character is a digit\n        # If it is, return the character as the first digit\n\n# If no digit is found, return \"None\"",
        "test": [
            "assert first_Digit(123) == 1",
            "assert first_Digit(456) == 4",
            "assert first_Digit(12) == 1"
        ],
        "draft_plan": [
            "# Convert the given number to a string\n\n# Iterate through each character in the string\n    # Check if the character is a digit\n        # If it is, return the character as the first digit\n\n# If no digit is found, return \"None\""
        ],
        "final_plan": [
            "#include <assert.h>\n#include <iostream>\n#include <string>\n\nstd::string first_digit(int number) {\n    std::string num_str = std::to_string(number);\n\n    for (char digit : num_str) {\n        if (isdigit(digit)) {\n            return std::string(1, digit);\n        }\n    }\n\n    return \"None\";\n}\n\nint main() {\n    // Test cases\n    assert(first_digit(12345) == \"1\");\n    assert(first_digit(-987) == \"9\");\n    assert(first_digit(0) == \"0\");\n    assert(first_digit(99999) == \"9\");\n    assert(first_digit(-123456789) == \"1\");\n\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}"
        ]
    }
]